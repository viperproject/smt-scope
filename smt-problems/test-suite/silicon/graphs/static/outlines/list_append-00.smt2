(get-info :version)
; (:version "4.8.7")
; Started: 2024-11-17 20:12:27
; Silicon.version: 1.1-SNAPSHOT (4d756c79+)
; Input file: /silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Set<$Ref> 0)
(declare-sort Set<Edge> 0)
(declare-sort Set<$Snap> 0)
(declare-sort Edge 0)
(declare-sort TrClo 0)
(declare-sort $FVF<next> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<Edge>To$Snap (Set<Edge>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Edge> ($Snap) Set<Edge>)
(assert (forall ((x Set<Edge>)) (!
    (= x ($SortWrappers.$SnapToSet<Edge>($SortWrappers.Set<Edge>To$Snap x)))
    :pattern (($SortWrappers.Set<Edge>To$Snap x))
    :qid |$Snap.$SnapToSet<Edge>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Edge>To$Snap($SortWrappers.$SnapToSet<Edge> x)))
    :pattern (($SortWrappers.$SnapToSet<Edge> x))
    :qid |$Snap.Set<Edge>To$SnapToSet<Edge>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.EdgeTo$Snap (Edge) $Snap)
(declare-fun $SortWrappers.$SnapToEdge ($Snap) Edge)
(assert (forall ((x Edge)) (!
    (= x ($SortWrappers.$SnapToEdge($SortWrappers.EdgeTo$Snap x)))
    :pattern (($SortWrappers.EdgeTo$Snap x))
    :qid |$Snap.$SnapToEdgeTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.EdgeTo$Snap($SortWrappers.$SnapToEdge x)))
    :pattern (($SortWrappers.$SnapToEdge x))
    :qid |$Snap.EdgeTo$SnapToEdge|
    )))
(declare-fun $SortWrappers.TrCloTo$Snap (TrClo) $Snap)
(declare-fun $SortWrappers.$SnapToTrClo ($Snap) TrClo)
(assert (forall ((x TrClo)) (!
    (= x ($SortWrappers.$SnapToTrClo($SortWrappers.TrCloTo$Snap x)))
    :pattern (($SortWrappers.TrCloTo$Snap x))
    :qid |$Snap.$SnapToTrCloTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.TrCloTo$Snap($SortWrappers.$SnapToTrClo x)))
    :pattern (($SortWrappers.$SnapToTrClo x))
    :qid |$Snap.TrCloTo$SnapToTrClo|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<next>To$Snap ($FVF<next>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<next> ($Snap) $FVF<next>)
(assert (forall ((x $FVF<next>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<next>($SortWrappers.$FVF<next>To$Snap x)))
    :pattern (($SortWrappers.$FVF<next>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<next>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<next>To$Snap($SortWrappers.$SnapTo$FVF<next> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<next> x))
    :qid |$Snap.$FVF<next>To$SnapTo$FVF<next>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<Edge>) Int)
(declare-const Set_empty Set<Edge>)
(declare-fun Set_in (Edge Set<Edge>) Bool)
(declare-fun Set_singleton (Edge) Set<Edge>)
(declare-fun Set_unionone (Set<Edge> Edge) Set<Edge>)
(declare-fun Set_union (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_intersection (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_difference (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_subset (Set<Edge> Set<Edge>) Bool)
(declare-fun Set_equal (Set<Edge> Set<Edge>) Bool)
(declare-fun Set_skolem_diff (Set<Edge> Set<Edge>) Edge)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
(declare-fun edge_pred<Ref> (Edge) $Ref)
(declare-fun edge_succ<Ref> (Edge) $Ref)
(declare-fun create_edge<Edge> ($Ref $Ref) Edge)
(declare-fun create_edge_<Edge> ($Ref $Ref) Edge)
(declare-fun exists_path<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_path_<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_path_2<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_path_2_<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun is_on_path<Bool> (Set<Edge> $Ref $Ref $Ref) Bool)
(declare-fun apply_IND<Bool> (Set<Edge> Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_IND_2<Bool> (Set<Edge> Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_noExit<Bool> (Set<Edge> Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_goOut<Bool> (Set<Edge> Set<$Ref> Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_newStart<Bool> (Set<$Ref> Set<$Ref> Set<Edge> Set<Edge>) Bool)
(declare-fun inst_uReach<Set<Ref>> (Set<Edge> $Ref) Set<$Ref>)
(declare-fun inst_uReach_2<Set<Ref>> (Set<Edge> $Ref) Set<$Ref>)
(declare-fun inst_uReach_rev<Set<Ref>> (Set<Edge> $Ref) Set<$Ref>)
(declare-fun acyclic_graph<Bool> (Set<Edge>) Bool)
(declare-fun unshared_graph<Bool> (Set<Edge>) Bool)
(declare-fun func_graph<Bool> (Set<Edge>) Bool)
(declare-fun edge<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun edge_<Bool> (Set<Edge> $Ref $Ref) Bool)
; /field_value_functions_declarations.smt2 [next: Ref]
(declare-fun $FVF.domain_next ($FVF<next>) Set<$Ref>)
(declare-fun $FVF.lookup_next ($FVF<next> $Ref) $Ref)
(declare-fun $FVF.after_next ($FVF<next> $FVF<next>) Bool)
(declare-fun $FVF.loc_next ($Ref $Ref) Bool)
(declare-fun $FVF.perm_next ($FPM $Ref) $Perm)
(declare-const $fvfTOP_next $FVF<next>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun $$ ($Snap Set<$Ref>) Set<Edge>)
(declare-fun $$%limited ($Snap Set<$Ref>) Set<Edge>)
(declare-fun $$%stateless (Set<$Ref>) Bool)
(declare-fun $$%precondition ($Snap Set<$Ref>) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Edge>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Edge)) (!
  (not (Set_in o (as Set_empty  Set<Edge>)))
  :pattern ((Set_in o (as Set_empty  Set<Edge>)))
  )))
(assert (forall ((s Set<Edge>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Edge>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Edge))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Edge)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Edge) (o Edge)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Edge)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Edge>) (x Edge) (o Edge)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Edge>) (x Edge) (y Edge)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=
    (Set_subset a b)
    (forall ((o Edge)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((p $Ref) (s $Ref)) (!
  (and
    (= (edge_pred<Ref> (create_edge<Edge> p s)) p)
    (= (edge_succ<Ref> (create_edge<Edge> p s)) s))
  :pattern ((create_edge<Edge> p s))
  :qid |prog.edge_injectivity|)))
(assert (forall ((EG Set<Edge>) (p $Ref) (s $Ref)) (!
  (= (edge<Bool> EG p s) (edge_<Bool> EG p s))
  :pattern ((edge<Bool> EG p s))
  :qid |prog.ax_EdgeSynonim|)))
(assert (forall ((EG Set<Edge>) (p $Ref) (s $Ref)) (!
  (= (edge_<Bool> EG p s) (Set_in (create_edge<Edge> p s) EG))
  :pattern ((Set_in (create_edge<Edge> p s) EG))
  :pattern ((edge<Bool> EG p s))
  :qid |prog.ax_Edge|)))
(assert (forall ((EG Set<Edge>) (Z Set<$Ref>) (P Set<$Ref>)) (!
  (=>
    (and
      (apply_IND<Bool> EG Z P)
      (and
        (forall ((z $Ref)) (!
          (=> (Set_in z Z) (Set_in z P))
          :pattern ((Set_in z Z))
          :pattern ((Set_in z P))
          ))
        (forall ((u $Ref) (v $Ref)) (!
          (=> (and (Set_in u P) (edge<Bool> EG u v)) (Set_in v P))
          :pattern ((edge<Bool> EG u v))
          :pattern ((Set_in u P) (Set_in v P))
          ))))
    (forall ((u $Ref) (z $Ref)) (!
      (=> (and (Set_in z Z) (exists_path<Bool> EG z u)) (Set_in u P))
      :pattern ((exists_path<Bool> EG z u))
      :pattern ((Set_in z Z) (Set_in u P))
      )))
  :pattern ((apply_IND<Bool> EG Z P))
  :qid |prog.ax_InductionPrinciple|)))
(assert (forall ((EG Set<Edge>) (Z Set<$Ref>) (P Set<$Ref>)) (!
  (=>
    (and
      (apply_IND_2<Bool> EG Z P)
      (and
        (forall ((z $Ref)) (!
          (=> (Set_in z Z) (Set_in z P))
          :pattern ((Set_in z Z))
          :pattern ((Set_in z P))
          ))
        (forall ((u $Ref) (v $Ref)) (!
          (=> (and (edge<Bool> EG u v) (Set_in v P)) (Set_in u P))
          :pattern ((edge<Bool> EG u v))
          :pattern ((Set_in u P) (Set_in v P))
          ))))
    (forall ((u $Ref) (z $Ref)) (!
      (=> (and (Set_in z Z) (exists_path_2<Bool> EG u z)) (Set_in u P))
      :pattern ((exists_path_2<Bool> EG z u))
      :pattern ((Set_in z Z) (Set_in u P))
      )))
  :pattern ((apply_IND_2<Bool> EG Z P))
  :qid |prog.ax_InductionPrinciple_2|)))
(assert (forall ((EG Set<Edge>) (u $Ref) (y $Ref)) (!
  (= (Set_in u (inst_uReach_rev<Set<Ref>> EG y)) (exists_path<Bool> EG u y))
  :pattern ((Set_in u (inst_uReach_rev<Set<Ref>> EG y)))
  :pattern ((exists_path<Bool> EG u y))
  :qid |prog.ax_instantiation_uReach_rev|)))
(assert (forall ((EG Set<Edge>) (x $Ref) (v $Ref)) (!
  (= (Set_in v (inst_uReach_2<Set<Ref>> EG x)) (exists_path_2<Bool> EG x v))
  :pattern ((Set_in v (inst_uReach_2<Set<Ref>> EG x)))
  :pattern ((exists_path_2<Bool> EG x v))
  :qid |prog.ax_instantiation_uReach_2|)))
(assert (forall ((EG Set<Edge>) (x $Ref) (v $Ref)) (!
  (= (Set_in v (inst_uReach<Set<Ref>> EG x)) (exists_path<Bool> EG x v))
  :pattern ((Set_in v (inst_uReach<Set<Ref>> EG x)))
  :pattern ((exists_path<Bool> EG x v))
  :qid |prog.ax_instantiation_uReach|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (= (exists_path<Bool> EG start end) (exists_path_<Bool> EG start end))
  :pattern ((exists_path<Bool> EG start end))
  :qid |prog.ax_Alias|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (= (exists_path_2<Bool> EG start end) (exists_path_2_<Bool> EG start end))
  :pattern ((exists_path_2<Bool> EG start end))
  :qid |prog.ax_Alias_2|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (=
    (exists_path_<Bool> EG start end)
    (or
      (= start end)
      (exists ((w $Ref)) (!
        (and (edge<Bool> EG start w) (exists_path_<Bool> EG w end))
        :pattern ((edge<Bool> EG start w))
        :pattern ((exists_path_<Bool> EG w end))
        ))))
  :pattern ((exists_path<Bool> EG start end))
  :pattern ((edge<Bool> EG start end))
  :qid |prog.ax_ExistsPath|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (=
    (exists_path_2_<Bool> EG start end)
    (or
      (= start end)
      (exists ((w $Ref)) (!
        (and (exists_path_2_<Bool> EG start w) (edge<Bool> EG w end))
        :pattern ((exists_path_2_<Bool> EG start w))
        :pattern ((edge<Bool> EG w end))
        ))))
  :pattern ((exists_path_2<Bool> EG start end))
  :pattern ((edge<Bool> EG start end))
  :qid |prog.ax_ExistsPath_2|)))
(assert (forall ((EG Set<Edge>) (u $Ref) (v $Ref) (w $Ref)) (!
  (=>
    (and (exists_path_<Bool> EG u w) (exists_path_<Bool> EG w v))
    (exists_path_<Bool> EG u v))
  :pattern ((exists_path<Bool> EG u w) (exists_path<Bool> EG w v))
  :qid |prog.ax_ExistsPathTrans|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (func_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref) (v $Ref)) (!
      (=> (and (edge<Bool> EG v v1) (edge<Bool> EG v v2)) (= v1 v2))
      :pattern ((edge<Bool> EG v v1) (edge<Bool> EG v v2))
      )))
  :pattern ((func_graph<Bool> EG))
  :qid |prog.ax_FuncGraph|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (unshared_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref) (v $Ref)) (!
      (=> (and (edge<Bool> EG v1 v) (edge<Bool> EG v2 v)) (= v1 v2))
      :pattern ((edge<Bool> EG v1 v) (edge<Bool> EG v2 v))
      )))
  :pattern ((unshared_graph<Bool> EG))
  :qid |prog.ax_UnsharedGraph|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (acyclic_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref)) (!
      (or (not (edge<Bool> EG v1 v2)) (not (exists_path<Bool> EG v2 v1)))
      :pattern ((edge<Bool> EG v1 v2))
      :pattern ((exists_path<Bool> EG v2 v1))
      )))
  :pattern ((acyclic_graph<Bool> EG))
  :qid |prog.ax_AcyclicGraph|)))
; /field_value_functions_axioms.smt2 [next: Ref]
(assert (forall ((vs $FVF<next>) (ws $FVF<next>)) (!
    (=>
      (and
        (Set_equal ($FVF.domain_next vs) ($FVF.domain_next ws))
        (forall ((x $Ref)) (!
          (=>
            (Set_in x ($FVF.domain_next vs))
            (= ($FVF.lookup_next vs x) ($FVF.lookup_next ws x)))
          :pattern (($FVF.lookup_next vs x) ($FVF.lookup_next ws x))
          :qid |qp.$FVF<next>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<next>To$Snap vs)
              ($SortWrappers.$FVF<next>To$Snap ws)
              )
    :qid |qp.$FVF<next>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_next pm r))
    :pattern (($FVF.perm_next pm r)))))
(assert (forall ((r $Ref) (f $Ref)) (!
    (= ($FVF.loc_next f r) true)
    :pattern (($FVF.loc_next f r)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun inv@4@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@5@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun sm@3@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun sm@6@00 ($Snap Set<$Ref>) $FVF<next>)
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (= ($$%limited s@$ refs@0@00) ($$ s@$ refs@0@00))
  :pattern (($$ s@$ refs@0@00))
  :qid |quant-u-0|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  ($$%stateless refs@0@00)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-1|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) (and
    (forall ((n@2@00 $Ref)) (!
      (=>
        (Set_in n@2@00 refs@0@00)
        (and
          (= (inv@4@00 s@$ refs@0@00 n@2@00) n@2@00)
          (img@5@00 s@$ refs@0@00 n@2@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) n@2@00) n@2@00))
      :qid |quant-u-3|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@5@00 s@$ refs@0@00 r)
          (Set_in (inv@4@00 s@$ refs@0@00 r) refs@0@00))
        (= (inv@4@00 s@$ refs@0@00 r) r))
      :pattern ((inv@4@00 s@$ refs@0@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@3@00 s@$ refs@0@00) r))
      :qid |qp.fvfResTrgDef0|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@5@00 s@$ refs@0@00 r)
          (Set_in (inv@4@00 s@$ refs@0@00 r) refs@0@00))
        (=
          ($FVF.lookup_next (sm@6@00 s@$ refs@0@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r)))
      :pattern (($FVF.lookup_next (sm@6@00 s@$ refs@0@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r))
      :qid |qp.fvfValDef1|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r) r)
      :pattern (($FVF.lookup_next (sm@6@00 s@$ refs@0@00) r))
      :qid |qp.fvfResTrgDef2|))
    (=>
      ($$%precondition s@$ refs@0@00)
      (forall ((p $Ref) (s $Ref)) (!
        (=
          (and
            (Set_in p refs@0@00)
            (and
              (Set_in s refs@0@00)
              (= ($FVF.lookup_next (sm@6@00 s@$ refs@0@00) p) s)))
          (Set_in (create_edge<Edge> p s) result@1@00))
        :pattern ((create_edge<Edge> p s))
        )))))
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-5|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) true)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-6|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- link ----------
(declare-const g@0@01 Set<$Ref>)
(declare-const x@1@01 $Ref)
(declare-const y@2@01 $Ref)
(declare-const g@3@01 Set<$Ref>)
(declare-const x@4@01 $Ref)
(declare-const y@5@01 $Ref)
(set-option :timeout 0)
(push) ; 1
(declare-const $t@6@01 $Snap)
(assert (= $t@6@01 ($Snap.combine ($Snap.first $t@6@01) ($Snap.second $t@6@01))))
(assert (= ($Snap.first $t@6@01) $Snap.unit))
; [eval] (x in g)
(assert (Set_in x@4@01 g@3@01))
(assert (=
  ($Snap.second $t@6@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@6@01))
    ($Snap.second ($Snap.second $t@6@01)))))
(assert (= ($Snap.first ($Snap.second $t@6@01)) $Snap.unit))
; [eval] y != null ==> (y in g)
; [eval] y != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; [then-branch: 0 | y@5@01 != Null | live]
; [else-branch: 0 | y@5@01 == Null | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 0 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
; [eval] (y in g)
(pop) ; 3
(push) ; 3
; [else-branch: 0 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (= y@5@01 $Ref.null) (not (= y@5@01 $Ref.null))))
(assert (=> (not (= y@5@01 $Ref.null)) (Set_in y@5@01 g@3@01)))
(assert (=
  ($Snap.second ($Snap.second $t@6@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@6@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@6@01))) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@3@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@6@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))))
(declare-const n@7@01 $Ref)
(push) ; 2
; [eval] (n in g)
(assert (Set_in n@7@01 g@3@01))
(declare-const sm@8@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@9@01 ($Ref) $Ref)
(declare-fun img@10@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@7@01 $Ref) (n2@7@01 $Ref)) (!
  (=>
    (and (Set_in n1@7@01 g@3@01) (Set_in n2@7@01 g@3@01) (= n1@7@01 n2@7@01))
    (= n1@7@01 n2@7@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@7@01 $Ref)) (!
  (=>
    (Set_in n@7@01 g@3@01)
    (and (= (inv@9@01 n@7@01) n@7@01) (img@10@01 n@7@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) n@7@01) n@7@01))
  :qid |quant-u-8|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) (= (inv@9@01 r) r))
  :pattern ((inv@9@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@7@01 $Ref)) (!
  (=> (Set_in n@7@01 g@3@01) (not (= n@7@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) n@7@01) n@7@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@11@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@11@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@9@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
  :pattern ((inv@9@01 r))
  :qid |quant-u-9|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))
  $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@12@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 1 | !(n$0@12@01 in g@3@01) | live]
; [else-branch: 1 | n$0@12@01 in g@3@01 | live]
(push) ; 4
; [then-branch: 1 | !(n$0@12@01 in g@3@01)]
(assert (not (Set_in n$0@12@01 g@3@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 1 | n$0@12@01 in g@3@01]
(assert (Set_in n$0@12@01 g@3@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
      (=
        ($FVF.lookup_next (as sm@11@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
    :qid |qp.fvfValDef1|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef2|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01))
(push) ; 5
(assert (not (and (img@10@01 n$0@12@01) (Set_in (inv@9@01 n$0@12@01) g@3@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@11@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (=>
  (Set_in n$0@12@01 g@3@01)
  (and
    (Set_in n$0@12@01 g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01))))
(assert (or (Set_in n$0@12@01 g@3@01) (not (Set_in n$0@12@01 g@3@01))))
(push) ; 3
; [then-branch: 2 | n$0@12@01 in g@3@01 && Lookup(next, sm@11@01, n$0@12@01) != Null | live]
; [else-branch: 2 | !(n$0@12@01 in g@3@01 && Lookup(next, sm@11@01, n$0@12@01) != Null) | live]
(push) ; 4
; [then-branch: 2 | n$0@12@01 in g@3@01 && Lookup(next, sm@11@01, n$0@12@01) != Null]
(assert (and
  (Set_in n$0@12@01 g@3@01)
  (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
      (=
        ($FVF.lookup_next (as sm@11@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
    :qid |qp.fvfValDef1|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef2|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01))
(push) ; 5
(assert (not (and (img@10@01 n$0@12@01) (Set_in (inv@9@01 n$0@12@01) g@3@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 2 | !(n$0@12@01 in g@3@01 && Lookup(next, sm@11@01, n$0@12@01) != Null)]
(assert (not
  (and
    (Set_in n$0@12@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@11@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (=>
  (and
    (Set_in n$0@12@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))
  (and
    (Set_in n$0@12@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@12@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))))
  (and
    (Set_in n$0@12@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@11@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@11@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@12@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@12@01 g@3@01)
      (and
        (Set_in n$0@12@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01)))
    (or (Set_in n$0@12@01 g@3@01) (not (Set_in n$0@12@01 g@3@01)))
    (=>
      (and
        (Set_in n$0@12@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))
      (and
        (Set_in n$0@12@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01)))
    (or
      (not
        (and
          (Set_in n$0@12@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))))
      (and
        (Set_in n$0@12@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) g@3@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22-aux|)))
(assert (forall ((n$0@12@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@12@01 g@3@01)
      (and
        (Set_in n$0@12@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01)))
    (or (Set_in n$0@12@01 g@3@01) (not (Set_in n$0@12@01 g@3@01)))
    (=>
      (and
        (Set_in n$0@12@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))
      (and
        (Set_in n$0@12@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01)))
    (or
      (not
        (and
          (Set_in n$0@12@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null))))
      (and
        (Set_in n$0@12@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))))
  :pattern ((Set_in n$0@12@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22-aux|)))
(assert (forall ((n$0@12@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@12@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) g@3@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) g@3@01))
  :pattern ((Set_in n$0@12@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n$0@12@01) n$0@12@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@13@01 $Snap)
(assert (= $t@13@01 ($Snap.combine ($Snap.first $t@13@01) ($Snap.second $t@13@01))))
(assert (= ($Snap.first $t@13@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@13@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@13@01))
    ($Snap.second ($Snap.second $t@13@01)))))
(declare-const n$1@14@01 $Ref)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@14@01 g@3@01))
(declare-const sm@15@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@16@01 ($Ref) $Ref)
(declare-fun img@17@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@14@01 $Ref) (n$12@14@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@14@01 g@3@01)
      (Set_in n$12@14@01 g@3@01)
      (= n$11@14@01 n$12@14@01))
    (= n$11@14@01 n$12@14@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@14@01 $Ref)) (!
  (=>
    (Set_in n$1@14@01 g@3@01)
    (and (= (inv@16@01 n$1@14@01) n$1@14@01) (img@17@01 n$1@14@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) n$1@14@01) n$1@14@01))
  :qid |quant-u-11|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)) (= (inv@16@01 r) r))
  :pattern ((inv@16@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@14@01 $Ref)) (!
  (=> (Set_in n$1@14@01 g@3@01) (not (= n$1@14@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) n$1@14@01) n$1@14@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@18@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@16@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
  :pattern ((inv@16@01 r))
  :qid |quant-u-12|)))
(assert (=
  ($Snap.second ($Snap.second $t@13@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@13@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@13@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@13@01))) $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@19@01 $Ref)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 3 | !(n$2@19@01 in g@3@01) | live]
; [else-branch: 3 | n$2@19@01 in g@3@01 | live]
(push) ; 5
; [then-branch: 3 | !(n$2@19@01 in g@3@01)]
(assert (not (Set_in n$2@19@01 g@3@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 3 | n$2@19@01 in g@3@01]
(assert (Set_in n$2@19@01 g@3@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
      (=
        ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
    :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
    :qid |qp.fvfValDef4|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef5|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01))
(push) ; 6
(assert (not (and (img@17@01 n$2@19@01) (Set_in (inv@16@01 n$2@19@01) g@3@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (=>
  (Set_in n$2@19@01 g@3@01)
  (and
    (Set_in n$2@19@01 g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01))))
(assert (or (Set_in n$2@19@01 g@3@01) (not (Set_in n$2@19@01 g@3@01))))
(push) ; 4
; [then-branch: 4 | n$2@19@01 in g@3@01 && Lookup(next, sm@18@01, n$2@19@01) != Null | live]
; [else-branch: 4 | !(n$2@19@01 in g@3@01 && Lookup(next, sm@18@01, n$2@19@01) != Null) | live]
(push) ; 5
; [then-branch: 4 | n$2@19@01 in g@3@01 && Lookup(next, sm@18@01, n$2@19@01) != Null]
(assert (and
  (Set_in n$2@19@01 g@3@01)
  (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
      (=
        ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
    :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
    :qid |qp.fvfValDef4|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef5|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01))
(push) ; 6
(assert (not (and (img@17@01 n$2@19@01) (Set_in (inv@16@01 n$2@19@01) g@3@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 4 | !(n$2@19@01 in g@3@01 && Lookup(next, sm@18@01, n$2@19@01) != Null)]
(assert (not
  (and
    (Set_in n$2@19@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (=>
  (and
    (Set_in n$2@19@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))
  (and
    (Set_in n$2@19@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@19@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))))
  (and
    (Set_in n$2@19@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@19@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@19@01 g@3@01)
      (and
        (Set_in n$2@19@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01)))
    (or (Set_in n$2@19@01 g@3@01) (not (Set_in n$2@19@01 g@3@01)))
    (=>
      (and
        (Set_in n$2@19@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))
      (and
        (Set_in n$2@19@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01)))
    (or
      (not
        (and
          (Set_in n$2@19@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))))
      (and
        (Set_in n$2@19@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) g@3@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@288@13@288@21-aux|)))
(assert (forall ((n$2@19@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@19@01 g@3@01)
      (and
        (Set_in n$2@19@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01)))
    (or (Set_in n$2@19@01 g@3@01) (not (Set_in n$2@19@01 g@3@01)))
    (=>
      (and
        (Set_in n$2@19@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))
      (and
        (Set_in n$2@19@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01)))
    (or
      (not
        (and
          (Set_in n$2@19@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null))))
      (and
        (Set_in n$2@19@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))))
  :pattern ((Set_in n$2@19@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@288@13@288@21-aux|)))
(assert (forall ((n$2@19@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@19@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) g@3@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) g@3@01))
  :pattern ((Set_in n$2@19@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n$2@19@01) n$2@19@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@288@13@288@21|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@13@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@13@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@13@01))))
  $Snap.unit))
; [eval] x.next == y
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
      (=
        ($FVF.lookup_next (as sm@18@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
    :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
    :qid |qp.fvfValDef4|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@18@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef5|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) x@4@01) x@4@01))
(push) ; 3
(assert (not (and (img@17@01 x@4@01) (Set_in (inv@16@01 x@4@01) g@3@01))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (= ($FVF.lookup_next (as sm@18@01  $FVF<next>) x@4@01) y@5@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01)))))
  $Snap.unit))
; [eval] y == null ==> $$(g) == old($$(g))
; [eval] y == null
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 5 | y@5@01 == Null | live]
; [else-branch: 5 | y@5@01 != Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 5 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
; [eval] $$(g) == old($$(g))
; [eval] $$(g)
(push) ; 5
(declare-const n@20@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@20@01 g@3@01))
(pop) ; 6
(declare-fun inv@21@01 ($Ref) $Ref)
(declare-fun img@22@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@20@01 $Ref) (n2@20@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@20@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n1@20@01) n1@20@01))
      (and
        (Set_in n2@20@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n2@20@01) n2@20@01))
      (= n1@20@01 n2@20@01))
    (= n1@20@01 n2@20@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@20@01 $Ref)) (!
  (=>
    (Set_in n@20@01 g@3@01)
    (and (= (inv@21@01 n@20@01) n@20@01) (img@22@01 n@20@01)))
  :pattern ((Set_in n@20@01 g@3@01))
  :pattern ((inv@21@01 n@20@01))
  :pattern ((img@22@01 n@20@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@22@01 r) (Set_in (inv@21@01 r) g@3@01)) (= (inv@21@01 r) r))
  :pattern ((inv@21@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@21@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
  :pattern ((inv@21@01 r))
  :qid |quant-u-14|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@23@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r) (= r (inv@21@01 r)))
    ($Perm.min
      (ite
        (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
        $Perm.Write
        $Perm.No)
      (pTaken@23@01 r))
    $Perm.No)
  
  :qid |quant-u-16|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r) (= r (inv@21@01 r)))
    (= (- $Perm.Write (pTaken@23@01 r)) $Perm.No))
  
  :qid |quant-u-17|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@24@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>)))
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r)))
    (=>
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r))
      (Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>))))
  :qid |qp.fvfDomDef8|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@24@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@24@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@24@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef7|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@24@01  $FVF<next>)) g@3@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@20@01 $Ref)) (!
  (=>
    (Set_in n@20@01 g@3@01)
    (and (= (inv@21@01 n@20@01) n@20@01) (img@22@01 n@20@01)))
  :pattern ((Set_in n@20@01 g@3@01))
  :pattern ((inv@21@01 n@20@01))
  :pattern ((img@22@01 n@20@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@22@01 r) (Set_in (inv@21@01 r) g@3@01)) (= (inv@21@01 r) r))
  :pattern ((inv@21@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>)))
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r)))
    (=>
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r))
      (Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>))))
  :qid |qp.fvfDomDef8|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@24@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@24@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@24@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef7|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@21@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
    :pattern ((inv@21@01 r))
    :qid |quant-u-14|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@24@01  $FVF<next>)) g@3@01)))
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 5
(declare-const n@25@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@25@01 g@3@01))
(pop) ; 6
(declare-fun inv@26@01 ($Ref) $Ref)
(declare-fun img@27@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@25@01 $Ref) (n2@25@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@25@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n1@25@01) n1@25@01))
      (and
        (Set_in n2@25@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n2@25@01) n2@25@01))
      (= n1@25@01 n2@25@01))
    (= n1@25@01 n2@25@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@25@01 $Ref)) (!
  (=>
    (Set_in n@25@01 g@3@01)
    (and (= (inv@26@01 n@25@01) n@25@01) (img@27@01 n@25@01)))
  :pattern ((Set_in n@25@01 g@3@01))
  :pattern ((inv@26@01 n@25@01))
  :pattern ((img@27@01 n@25@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@27@01 r) (Set_in (inv@26@01 r) g@3@01)) (= (inv@26@01 r) r))
  :pattern ((inv@26@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@26@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
  :pattern ((inv@26@01 r))
  :qid |quant-u-19|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@28@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r) (= r (inv@26@01 r)))
    ($Perm.min
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      (pTaken@28@01 r))
    $Perm.No)
  
  :qid |quant-u-21|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r) (= r (inv@26@01 r)))
    (= (- $Perm.Write (pTaken@28@01 r)) $Perm.No))
  
  :qid |quant-u-22|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@29@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r)))
    (=>
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef11|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g@3@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@25@01 $Ref)) (!
  (=>
    (Set_in n@25@01 g@3@01)
    (and (= (inv@26@01 n@25@01) n@25@01) (img@27@01 n@25@01)))
  :pattern ((Set_in n@25@01 g@3@01))
  :pattern ((inv@26@01 n@25@01))
  :pattern ((img@27@01 n@25@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@27@01 r) (Set_in (inv@26@01 r) g@3@01)) (= (inv@26@01 r) r))
  :pattern ((inv@26@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r)))
    (=>
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef11|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@26@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
    :pattern ((inv@26@01 r))
    :qid |quant-u-19|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g@3@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 5 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@20@01 $Ref)) (!
  (=>
    (Set_in n@20@01 g@3@01)
    (and (= (inv@21@01 n@20@01) n@20@01) (img@22@01 n@20@01)))
  :pattern ((Set_in n@20@01 g@3@01))
  :pattern ((inv@21@01 n@20@01))
  :pattern ((img@22@01 n@20@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@22@01 r) (Set_in (inv@21@01 r) g@3@01)) (= (inv@21@01 r) r))
  :pattern ((inv@21@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>)))
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r)))
    (=>
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r))
      (Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@24@01  $FVF<next>))))
  :qid |qp.fvfDomDef8|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@21@01 r) g@3@01) (img@22@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@24@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@24@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@24@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef7|)))
(assert (forall ((n@25@01 $Ref)) (!
  (=>
    (Set_in n@25@01 g@3@01)
    (and (= (inv@26@01 n@25@01) n@25@01) (img@27@01 n@25@01)))
  :pattern ((Set_in n@25@01 g@3@01))
  :pattern ((inv@26@01 n@25@01))
  :pattern ((img@27@01 n@25@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@27@01 r) (Set_in (inv@26@01 r) g@3@01)) (= (inv@26@01 r) r))
  :pattern ((inv@26@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r)))
    (=>
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef11|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@26@01 r) g@3@01) (img@27@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (=>
  (= y@5@01 $Ref.null)
  (and
    (= y@5@01 $Ref.null)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@21@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
      :pattern ((inv@21@01 r))
      :qid |quant-u-14|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@24@01  $FVF<next>)) g@3@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@26@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
      :pattern ((inv@26@01 r))
      :qid |quant-u-19|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g@3@01))))
; Joined path conditions
(assert (or (not (= y@5@01 $Ref.null)) (= y@5@01 $Ref.null)))
(assert (=>
  (= y@5@01 $Ref.null)
  (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@24@01  $FVF<next>)) g@3@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g@3@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01))))))
  $Snap.unit))
; [eval] y != null ==> (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y))
; [eval] y != null
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 6 | y@5@01 != Null | live]
; [else-branch: 6 | y@5@01 == Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 6 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y))
(declare-const v1@30@01 $Ref)
(declare-const v2@31@01 $Ref)
(push) ; 5
; [eval] edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y)
; [eval] edge($$(g), v1, v2)
; [eval] $$(g)
(push) ; 6
(declare-const n@32@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@32@01 g@3@01))
(pop) ; 7
(declare-fun inv@33@01 ($Ref) $Ref)
(declare-fun img@34@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@32@01 $Ref) (n2@32@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@32@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n1@32@01) n1@32@01))
      (and
        (Set_in n2@32@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n2@32@01) n2@32@01))
      (= n1@32@01 n2@32@01))
    (= n1@32@01 n2@32@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@32@01 $Ref)) (!
  (=>
    (Set_in n@32@01 g@3@01)
    (and (= (inv@33@01 n@32@01) n@32@01) (img@34@01 n@32@01)))
  :pattern ((Set_in n@32@01 g@3@01))
  :pattern ((inv@33@01 n@32@01))
  :pattern ((img@34@01 n@32@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@34@01 r) (Set_in (inv@33@01 r) g@3@01)) (= (inv@33@01 r) r))
  :pattern ((inv@33@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@33@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
  :pattern ((inv@33@01 r))
  :qid |quant-u-24|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@35@01 ((r $Ref) (v1@30@01 $Ref) (v2@31@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r) (= r (inv@33@01 r)))
    ($Perm.min
      (ite
        (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
        $Perm.Write
        $Perm.No)
      (pTaken@35@01 r v1@30@01 v2@31@01))
    $Perm.No)
  
  :qid |quant-u-26|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r) (= r (inv@33@01 r)))
    (= (- $Perm.Write (pTaken@35@01 r v1@30@01 v2@31@01)) $Perm.No))
  
  :qid |quant-u-27|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@36@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r)))
    (=>
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef14|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@32@01 $Ref)) (!
  (=>
    (Set_in n@32@01 g@3@01)
    (and (= (inv@33@01 n@32@01) n@32@01) (img@34@01 n@32@01)))
  :pattern ((Set_in n@32@01 g@3@01))
  :pattern ((inv@33@01 n@32@01))
  :pattern ((img@34@01 n@32@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@34@01 r) (Set_in (inv@33@01 r) g@3@01)) (= (inv@33@01 r) r))
  :pattern ((inv@33@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r)))
    (=>
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@33@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
    :pattern ((inv@33@01 r))
    :qid |quant-u-24|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g@3@01)))
; [eval] edge(old($$(g)), v1, v2) || v1 == x && v2 == y
; [eval] edge(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 6
(declare-const n@37@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@37@01 g@3@01))
(pop) ; 7
(declare-fun inv@38@01 ($Ref) $Ref)
(declare-fun img@39@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@37@01 $Ref) (n2@37@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@37@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n1@37@01) n1@37@01))
      (and
        (Set_in n2@37@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n2@37@01) n2@37@01))
      (= n1@37@01 n2@37@01))
    (= n1@37@01 n2@37@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@37@01 $Ref)) (!
  (=>
    (Set_in n@37@01 g@3@01)
    (and (= (inv@38@01 n@37@01) n@37@01) (img@39@01 n@37@01)))
  :pattern ((Set_in n@37@01 g@3@01))
  :pattern ((inv@38@01 n@37@01))
  :pattern ((img@39@01 n@37@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@39@01 r) (Set_in (inv@38@01 r) g@3@01)) (= (inv@38@01 r) r))
  :pattern ((inv@38@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@38@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
  :pattern ((inv@38@01 r))
  :qid |quant-u-29|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@40@01 ((r $Ref) (v1@30@01 $Ref) (v2@31@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r) (= r (inv@38@01 r)))
    ($Perm.min
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      (pTaken@40@01 r v1@30@01 v2@31@01))
    $Perm.No)
  
  :qid |quant-u-31|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r) (= r (inv@38@01 r)))
    (= (- $Perm.Write (pTaken@40@01 r v1@30@01 v2@31@01)) $Perm.No))
  
  :qid |quant-u-32|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@41@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r)))
    (=>
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@37@01 $Ref)) (!
  (=>
    (Set_in n@37@01 g@3@01)
    (and (= (inv@38@01 n@37@01) n@37@01) (img@39@01 n@37@01)))
  :pattern ((Set_in n@37@01 g@3@01))
  :pattern ((inv@38@01 n@37@01))
  :pattern ((img@39@01 n@37@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@39@01 r) (Set_in (inv@38@01 r) g@3@01)) (= (inv@38@01 r) r))
  :pattern ((inv@38@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r)))
    (=>
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@38@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
    :pattern ((inv@38@01 r))
    :qid |quant-u-29|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01)))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 7 | edge[Bool]($$(sm@41@01, g@3@01), v1@30@01, v2@31@01) | live]
; [else-branch: 7 | !(edge[Bool]($$(sm@41@01, g@3@01), v1@30@01, v2@31@01)) | live]
(push) ; 7
; [then-branch: 7 | edge[Bool]($$(sm@41@01, g@3@01), v1@30@01, v2@31@01)]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
(pop) ; 7
(push) ; 7
; [else-branch: 7 | !(edge[Bool]($$(sm@41@01, g@3@01), v1@30@01, v2@31@01))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01)))
; [eval] v1 == x && v2 == y
; [eval] v1 == x
(push) ; 8
; [then-branch: 8 | v1@30@01 != x@4@01 | live]
; [else-branch: 8 | v1@30@01 == x@4@01 | live]
(push) ; 9
; [then-branch: 8 | v1@30@01 != x@4@01]
(assert (not (= v1@30@01 x@4@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 8 | v1@30@01 == x@4@01]
(assert (= v1@30@01 x@4@01))
; [eval] v2 == y
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or (= v1@30@01 x@4@01) (not (= v1@30@01 x@4@01))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (=>
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
  (and
    (not
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
    (or (= v1@30@01 x@4@01) (not (= v1@30@01 x@4@01))))))
(assert (or
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@32@01 $Ref)) (!
  (=>
    (Set_in n@32@01 g@3@01)
    (and (= (inv@33@01 n@32@01) n@32@01) (img@34@01 n@32@01)))
  :pattern ((Set_in n@32@01 g@3@01))
  :pattern ((inv@33@01 n@32@01))
  :pattern ((img@34@01 n@32@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@34@01 r) (Set_in (inv@33@01 r) g@3@01)) (= (inv@33@01 r) r))
  :pattern ((inv@33@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r)))
    (=>
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((n@37@01 $Ref)) (!
  (=>
    (Set_in n@37@01 g@3@01)
    (and (= (inv@38@01 n@37@01) n@37@01) (img@39@01 n@37@01)))
  :pattern ((Set_in n@37@01 g@3@01))
  :pattern ((inv@38@01 n@37@01))
  :pattern ((img@39@01 n@37@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@39@01 r) (Set_in (inv@38@01 r) g@3@01)) (= (inv@38@01 r) r))
  :pattern ((inv@38@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r)))
    (=>
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@33@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
  :pattern ((inv@33@01 r))
  :qid |quant-u-24|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g@3@01))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@38@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
  :pattern ((inv@38@01 r))
  :qid |quant-u-29|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@30@01 $Ref) (v2@31@01 $Ref)) (!
  (and
    (=>
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
      (and
        (not
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
        (or (= v1@30@01 x@4@01) (not (= v1@30@01 x@4@01)))))
    (or
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01)))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@291@27@293@78-aux|)))
(pop) ; 4
(push) ; 4
; [else-branch: 6 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@32@01 $Ref)) (!
  (=>
    (Set_in n@32@01 g@3@01)
    (and (= (inv@33@01 n@32@01) n@32@01) (img@34@01 n@32@01)))
  :pattern ((Set_in n@32@01 g@3@01))
  :pattern ((inv@33@01 n@32@01))
  :pattern ((img@34@01 n@32@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@34@01 r) (Set_in (inv@33@01 r) g@3@01)) (= (inv@33@01 r) r))
  :pattern ((inv@33@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r)))
    (=>
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@33@01 r) g@3@01) (img@34@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((n@37@01 $Ref)) (!
  (=>
    (Set_in n@37@01 g@3@01)
    (and (= (inv@38@01 n@37@01) n@37@01) (img@39@01 n@37@01)))
  :pattern ((Set_in n@37@01 g@3@01))
  :pattern ((inv@38@01 n@37@01))
  :pattern ((img@39@01 n@37@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@39@01 r) (Set_in (inv@38@01 r) g@3@01)) (= (inv@38@01 r) r))
  :pattern ((inv@38@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r)))
    (=>
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g@3@01) (img@39@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (=>
  (not (= y@5@01 $Ref.null))
  (and
    (not (= y@5@01 $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@33@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
      :pattern ((inv@33@01 r))
      :qid |quant-u-24|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g@3@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@38@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
      :pattern ((inv@38@01 r))
      :qid |quant-u-29|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01)
    (forall ((v1@30@01 $Ref) (v2@31@01 $Ref)) (!
      (and
        (=>
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
          (and
            (not
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
            (or (= v1@30@01 x@4@01) (not (= v1@30@01 x@4@01)))))
        (or
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01)))
      :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@291@27@293@78-aux|)))))
; Joined path conditions
(assert (=>
  (not (= y@5@01 $Ref.null))
  (forall ((v1@30@01 $Ref) (v2@31@01 $Ref)) (!
    (=
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01)
      (or
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01)
        (and (= v1@30@01 x@4@01) (= v2@31@01 y@5@01))))
    :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@30@01 v2@31@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@291@27@293@78|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@13@01))))))
  $Snap.unit))
; [eval] y != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)))
; [eval] y != null
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; [then-branch: 9 | y@5@01 != Null | live]
; [else-branch: 9 | y@5@01 == Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 9 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)))
(declare-const v1@42@01 $Ref)
(declare-const v2@43@01 $Ref)
(push) ; 5
; [eval] exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2))
; [eval] exists_path($$(g), v1, v2)
; [eval] $$(g)
(push) ; 6
(declare-const n@44@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@44@01 g@3@01))
(pop) ; 7
(declare-fun inv@45@01 ($Ref) $Ref)
(declare-fun img@46@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@44@01 $Ref) (n2@44@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@44@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n1@44@01) n1@44@01))
      (and
        (Set_in n2@44@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) n2@44@01) n2@44@01))
      (= n1@44@01 n2@44@01))
    (= n1@44@01 n2@44@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@44@01 $Ref)) (!
  (=>
    (Set_in n@44@01 g@3@01)
    (and (= (inv@45@01 n@44@01) n@44@01) (img@46@01 n@44@01)))
  :pattern ((Set_in n@44@01 g@3@01))
  :pattern ((inv@45@01 n@44@01))
  :pattern ((img@46@01 n@44@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@46@01 r) (Set_in (inv@45@01 r) g@3@01)) (= (inv@45@01 r) r))
  :pattern ((inv@45@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@45@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
  :pattern ((inv@45@01 r))
  :qid |quant-u-34|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@47@01 ((r $Ref) (v1@42@01 $Ref) (v2@43@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r) (= r (inv@45@01 r)))
    ($Perm.min
      (ite
        (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01))
        $Perm.Write
        $Perm.No)
      (pTaken@47@01 r v1@42@01 v2@43@01))
    $Perm.No)
  
  :qid |quant-u-36|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r) (= r (inv@45@01 r)))
    (= (- $Perm.Write (pTaken@47@01 r v1@42@01 v2@43@01)) $Perm.No))
  
  :qid |quant-u-37|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@48@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r)))
    (=>
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>))))
  :qid |qp.fvfDomDef20|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@48@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@44@01 $Ref)) (!
  (=>
    (Set_in n@44@01 g@3@01)
    (and (= (inv@45@01 n@44@01) n@44@01) (img@46@01 n@44@01)))
  :pattern ((Set_in n@44@01 g@3@01))
  :pattern ((inv@45@01 n@44@01))
  :pattern ((img@46@01 n@44@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@46@01 r) (Set_in (inv@45@01 r) g@3@01)) (= (inv@45@01 r) r))
  :pattern ((inv@45@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r)))
    (=>
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>))))
  :qid |qp.fvfDomDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@48@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@45@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
    :pattern ((inv@45@01 r))
    :qid |quant-u-34|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01)))
; [eval] exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)
; [eval] exists_path(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 6
(declare-const n@49@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@49@01 g@3@01))
(pop) ; 7
(declare-fun inv@50@01 ($Ref) $Ref)
(declare-fun img@51@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@49@01 $Ref) (n2@49@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@49@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n1@49@01) n1@49@01))
      (and
        (Set_in n2@49@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) n2@49@01) n2@49@01))
      (= n1@49@01 n2@49@01))
    (= n1@49@01 n2@49@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@49@01 $Ref)) (!
  (=>
    (Set_in n@49@01 g@3@01)
    (and (= (inv@50@01 n@49@01) n@49@01) (img@51@01 n@49@01)))
  :pattern ((Set_in n@49@01 g@3@01))
  :pattern ((inv@50@01 n@49@01))
  :pattern ((img@51@01 n@49@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@51@01 r) (Set_in (inv@50@01 r) g@3@01)) (= (inv@50@01 r) r))
  :pattern ((inv@50@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@50@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
  :pattern ((inv@50@01 r))
  :qid |quant-u-39|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@52@01 ((r $Ref) (v1@42@01 $Ref) (v2@43@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r) (= r (inv@50@01 r)))
    ($Perm.min
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      (pTaken@52@01 r v1@42@01 v2@43@01))
    $Perm.No)
  
  :qid |quant-u-41|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r) (= r (inv@50@01 r)))
    (= (- $Perm.Write (pTaken@52@01 r v1@42@01 v2@43@01)) $Perm.No))
  
  :qid |quant-u-42|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@53@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r)))
    (=>
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@53@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@49@01 $Ref)) (!
  (=>
    (Set_in n@49@01 g@3@01)
    (and (= (inv@50@01 n@49@01) n@49@01) (img@51@01 n@49@01)))
  :pattern ((Set_in n@49@01 g@3@01))
  :pattern ((inv@50@01 n@49@01))
  :pattern ((img@51@01 n@49@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@51@01 r) (Set_in (inv@50@01 r) g@3@01)) (= (inv@50@01 r) r))
  :pattern ((inv@50@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r)))
    (=>
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@53@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@50@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
    :pattern ((inv@50@01 r))
    :qid |quant-u-39|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01)))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 10 | exists_path[Bool]($$(sm@53@01, g@3@01), v1@42@01, v2@43@01) | live]
; [else-branch: 10 | !(exists_path[Bool]($$(sm@53@01, g@3@01), v1@42@01, v2@43@01)) | live]
(push) ; 7
; [then-branch: 10 | exists_path[Bool]($$(sm@53@01, g@3@01), v1@42@01, v2@43@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
(pop) ; 7
(push) ; 7
; [else-branch: 10 | !(exists_path[Bool]($$(sm@53@01, g@3@01), v1@42@01, v2@43@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01)))
; [eval] exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)
; [eval] exists_path(old($$(g)), v1, x)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 8
(declare-const n@54@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@54@01 g@3@01))
(pop) ; 9
(declare-fun inv@55@01 ($Ref) $Ref)
(declare-fun img@56@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@57@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef25|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@54@01 $Ref) (n2@54@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@54@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) n1@54@01) n1@54@01))
      (and
        (Set_in n2@54@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) n2@54@01) n2@54@01))
      (= n1@54@01 n2@54@01))
    (= n1@54@01 n2@54@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@54@01 $Ref)) (!
  (=>
    (Set_in n@54@01 g@3@01)
    (and (= (inv@55@01 n@54@01) n@54@01) (img@56@01 n@54@01)))
  :pattern ((Set_in n@54@01 g@3@01))
  :pattern ((inv@55@01 n@54@01))
  :pattern ((img@56@01 n@54@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@56@01 r) (Set_in (inv@55@01 r) g@3@01)) (= (inv@55@01 r) r))
  :pattern ((inv@55@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@55@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) r) r))
  :pattern ((inv@55@01 r))
  :qid |quant-u-44|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@58@01 ((r $Ref) (v1@42@01 $Ref) (v2@43@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r) (= r (inv@55@01 r)))
    ($Perm.min
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      (pTaken@58@01 r v1@42@01 v2@43@01))
    $Perm.No)
  
  :qid |quant-u-46|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r) (= r (inv@55@01 r)))
    (= (- $Perm.Write (pTaken@58@01 r v1@42@01 v2@43@01)) $Perm.No))
  
  :qid |quant-u-47|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@59@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r)))
    (=>
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>))))
  :qid |qp.fvfDomDef28|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@59@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef27|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((n@54@01 $Ref)) (!
  (=>
    (Set_in n@54@01 g@3@01)
    (and (= (inv@55@01 n@54@01) n@54@01) (img@56@01 n@54@01)))
  :pattern ((Set_in n@54@01 g@3@01))
  :pattern ((inv@55@01 n@54@01))
  :pattern ((img@56@01 n@54@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@56@01 r) (Set_in (inv@55@01 r) g@3@01)) (= (inv@55@01 r) r))
  :pattern ((inv@55@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r)))
    (=>
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>))))
  :qid |qp.fvfDomDef28|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@59@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef27|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@55@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) r) r))
    :pattern ((inv@55@01 r))
    :qid |quant-u-44|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 11 | !(exists_path[Bool]($$(sm@59@01, g@3@01), v1@42@01, x@4@01)) | live]
; [else-branch: 11 | exists_path[Bool]($$(sm@59@01, g@3@01), v1@42@01, x@4@01) | live]
(push) ; 9
; [then-branch: 11 | !(exists_path[Bool]($$(sm@59@01, g@3@01), v1@42@01, x@4@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 11 | exists_path[Bool]($$(sm@59@01, g@3@01), v1@42@01, x@4@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01))
; [eval] exists_path(old($$(g)), y, v2)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 10
(declare-const n@60@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@60@01 g@3@01))
(pop) ; 11
(declare-fun inv@61@01 ($Ref) $Ref)
(declare-fun img@62@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@63@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@63@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef30|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@60@01 $Ref) (n2@60@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@60@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) n1@60@01) n1@60@01))
      (and
        (Set_in n2@60@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) n2@60@01) n2@60@01))
      (= n1@60@01 n2@60@01))
    (= n1@60@01 n2@60@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@60@01 $Ref)) (!
  (=>
    (Set_in n@60@01 g@3@01)
    (and (= (inv@61@01 n@60@01) n@60@01) (img@62@01 n@60@01)))
  :pattern ((Set_in n@60@01 g@3@01))
  :pattern ((inv@61@01 n@60@01))
  :pattern ((img@62@01 n@60@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@62@01 r) (Set_in (inv@61@01 r) g@3@01)) (= (inv@61@01 r) r))
  :pattern ((inv@61@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@61@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) r) r))
  :pattern ((inv@61@01 r))
  :qid |quant-u-49|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@64@01 ((r $Ref) (v1@42@01 $Ref) (v2@43@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r) (= r (inv@61@01 r)))
    ($Perm.min
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)) $Perm.Write $Perm.No)
      (pTaken@64@01 r v1@42@01 v2@43@01))
    $Perm.No)
  
  :qid |quant-u-51|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r) (= r (inv@61@01 r)))
    (= (- $Perm.Write (pTaken@64@01 r v1@42@01 v2@43@01)) $Perm.No))
  
  :qid |quant-u-52|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@65@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r)))
    (=>
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@63@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((n@60@01 $Ref)) (!
  (=>
    (Set_in n@60@01 g@3@01)
    (and (= (inv@61@01 n@60@01) n@60@01) (img@62@01 n@60@01)))
  :pattern ((Set_in n@60@01 g@3@01))
  :pattern ((inv@61@01 n@60@01))
  :pattern ((img@62@01 n@60@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@62@01 r) (Set_in (inv@61@01 r) g@3@01)) (= (inv@61@01 r) r))
  :pattern ((inv@61@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r)))
    (=>
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@61@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) r) r))
    :pattern ((inv@61@01 r))
    :qid |quant-u-49|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@63@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((n@60@01 $Ref)) (!
  (=>
    (Set_in n@60@01 g@3@01)
    (and (= (inv@61@01 n@60@01) n@60@01) (img@62@01 n@60@01)))
  :pattern ((Set_in n@60@01 g@3@01))
  :pattern ((inv@61@01 n@60@01))
  :pattern ((img@62@01 n@60@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@62@01 r) (Set_in (inv@61@01 r) g@3@01)) (= (inv@61@01 r) r))
  :pattern ((inv@61@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r)))
    (=>
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@61@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) r) r))
      :pattern ((inv@61@01 r))
      :qid |quant-u-49|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((n@54@01 $Ref)) (!
  (=>
    (Set_in n@54@01 g@3@01)
    (and (= (inv@55@01 n@54@01) n@54@01) (img@56@01 n@54@01)))
  :pattern ((Set_in n@54@01 g@3@01))
  :pattern ((inv@55@01 n@54@01))
  :pattern ((img@56@01 n@54@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@56@01 r) (Set_in (inv@55@01 r) g@3@01)) (= (inv@55@01 r) r))
  :pattern ((inv@55@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r)))
    (=>
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>))))
  :qid |qp.fvfDomDef28|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@59@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@63@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((n@60@01 $Ref)) (!
  (=>
    (Set_in n@60@01 g@3@01)
    (and (= (inv@61@01 n@60@01) n@60@01) (img@62@01 n@60@01)))
  :pattern ((Set_in n@60@01 g@3@01))
  :pattern ((inv@61@01 n@60@01))
  :pattern ((img@62@01 n@60@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@62@01 r) (Set_in (inv@61@01 r) g@3@01)) (= (inv@61@01 r) r))
  :pattern ((inv@61@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r)))
    (=>
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@55@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) r) r))
      :pattern ((inv@55@01 r))
      :qid |quant-u-44|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@61@01 r) g@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) r) r))
          :pattern ((inv@61@01 r))
          :qid |quant-u-49|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01))))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@44@01 $Ref)) (!
  (=>
    (Set_in n@44@01 g@3@01)
    (and (= (inv@45@01 n@44@01) n@44@01) (img@46@01 n@44@01)))
  :pattern ((Set_in n@44@01 g@3@01))
  :pattern ((inv@45@01 n@44@01))
  :pattern ((img@46@01 n@44@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@46@01 r) (Set_in (inv@45@01 r) g@3@01)) (= (inv@45@01 r) r))
  :pattern ((inv@45@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r)))
    (=>
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>))))
  :qid |qp.fvfDomDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@48@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (forall ((n@49@01 $Ref)) (!
  (=>
    (Set_in n@49@01 g@3@01)
    (and (= (inv@50@01 n@49@01) n@49@01) (img@51@01 n@49@01)))
  :pattern ((Set_in n@49@01 g@3@01))
  :pattern ((inv@50@01 n@49@01))
  :pattern ((img@51@01 n@49@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@51@01 r) (Set_in (inv@50@01 r) g@3@01)) (= (inv@50@01 r) r))
  :pattern ((inv@50@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r)))
    (=>
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@53@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((n@54@01 $Ref)) (!
  (=>
    (Set_in n@54@01 g@3@01)
    (and (= (inv@55@01 n@54@01) n@54@01) (img@56@01 n@54@01)))
  :pattern ((Set_in n@54@01 g@3@01))
  :pattern ((inv@55@01 n@54@01))
  :pattern ((img@56@01 n@54@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@56@01 r) (Set_in (inv@55@01 r) g@3@01)) (= (inv@55@01 r) r))
  :pattern ((inv@55@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r)))
    (=>
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>))))
  :qid |qp.fvfDomDef28|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@59@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@63@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((n@60@01 $Ref)) (!
  (=>
    (Set_in n@60@01 g@3@01)
    (and (= (inv@61@01 n@60@01) n@60@01) (img@62@01 n@60@01)))
  :pattern ((Set_in n@60@01 g@3@01))
  :pattern ((inv@61@01 n@60@01))
  :pattern ((img@62@01 n@60@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@62@01 r) (Set_in (inv@61@01 r) g@3@01)) (= (inv@61@01 r) r))
  :pattern ((inv@61@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r)))
    (=>
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@45@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
  :pattern ((inv@45@01 r))
  :qid |quant-u-34|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@50@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
  :pattern ((inv@50@01 r))
  :qid |quant-u-39|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@42@01 $Ref) (v2@43@01 $Ref)) (!
  (and
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@55@01 r) g@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) r) r))
          :pattern ((inv@55@01 r))
          :qid |quant-u-44|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@61@01 r) g@3@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) r) r))
              :pattern ((inv@61@01 r))
              :qid |quant-u-49|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)))))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@294@27@296@138-aux|)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 9 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@44@01 $Ref)) (!
  (=>
    (Set_in n@44@01 g@3@01)
    (and (= (inv@45@01 n@44@01) n@44@01) (img@46@01 n@44@01)))
  :pattern ((Set_in n@44@01 g@3@01))
  :pattern ((inv@45@01 n@44@01))
  :pattern ((img@46@01 n@44@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@46@01 r) (Set_in (inv@45@01 r) g@3@01)) (= (inv@45@01 r) r))
  :pattern ((inv@45@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r)))
    (=>
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@48@01  $FVF<next>))))
  :qid |qp.fvfDomDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g@3@01) (img@46@01 r))
      (and (img@17@01 r) (Set_in (inv@16@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@48@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r)))
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@13@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@48@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (forall ((n@49@01 $Ref)) (!
  (=>
    (Set_in n@49@01 g@3@01)
    (and (= (inv@50@01 n@49@01) n@49@01) (img@51@01 n@49@01)))
  :pattern ((Set_in n@49@01 g@3@01))
  :pattern ((inv@50@01 n@49@01))
  :pattern ((img@51@01 n@49@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@51@01 r) (Set_in (inv@50@01 r) g@3@01)) (= (inv@50@01 r) r))
  :pattern ((inv@50@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r)))
    (=>
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@53@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@50@01 r) g@3@01) (img@51@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@53@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@53@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef25|)))
(assert (forall ((n@54@01 $Ref)) (!
  (=>
    (Set_in n@54@01 g@3@01)
    (and (= (inv@55@01 n@54@01) n@54@01) (img@56@01 n@54@01)))
  :pattern ((Set_in n@54@01 g@3@01))
  :pattern ((inv@55@01 n@54@01))
  :pattern ((img@56@01 n@54@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@56@01 r) (Set_in (inv@55@01 r) g@3@01)) (= (inv@55@01 r) r))
  :pattern ((inv@55@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r)))
    (=>
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@59@01  $FVF<next>))))
  :qid |qp.fvfDomDef28|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@55@01 r) g@3@01) (img@56@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@59@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@59@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef27|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01))
    (=
      ($FVF.lookup_next (as sm@63@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef29|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@63@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef30|)))
(assert (forall ((n@60@01 $Ref)) (!
  (=>
    (Set_in n@60@01 g@3@01)
    (and (= (inv@61@01 n@60@01) n@60@01) (img@62@01 n@60@01)))
  :pattern ((Set_in n@60@01 g@3@01))
  :pattern ((inv@61@01 n@60@01))
  :pattern ((img@62@01 n@60@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@62@01 r) (Set_in (inv@61@01 r) g@3@01)) (= (inv@61@01 r) r))
  :pattern ((inv@61@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r)))
    (=>
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@65@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@61@01 r) g@3@01) (img@62@01 r))
      (and (img@10@01 r) (Set_in (inv@9@01 r) g@3@01)))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (=>
  (not (= y@5@01 $Ref.null))
  (and
    (not (= y@5@01 $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@45@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@18@01  $FVF<next>) r) r))
      :pattern ((inv@45@01 r))
      :qid |quant-u-34|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@50@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@11@01  $FVF<next>) r) r))
      :pattern ((inv@50@01 r))
      :qid |quant-u-39|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01)
    (forall ((v1@42@01 $Ref) (v2@43@01 $Ref)) (!
      (and
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@55@01 r) g@3@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@57@01  $FVF<next>) r) r))
              :pattern ((inv@55@01 r))
              :qid |quant-u-44|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01)
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@61@01 r) g@3@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@63@01  $FVF<next>) r) r))
                  :pattern ((inv@61@01 r))
                  :qid |quant-u-49|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01)))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)))))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01)))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@294@27@296@138-aux|)))))
; Joined path conditions
(assert (=>
  (not (= y@5@01 $Ref.null))
  (forall ((v1@42@01 $Ref) (v2@43@01 $Ref)) (!
    (=
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01)
      (or
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@53@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01)
        (and
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@59@01  $FVF<next>)) g@3@01) v1@42@01 x@4@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@65@01  $FVF<next>)) g@3@01) y@5@01 v2@43@01))))
    :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@48@01  $FVF<next>)) g@3@01) v1@42@01 v2@43@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@294@27@296@138|))))
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- lemma_T2_a ----------
(declare-const g@66@01 Set<$Ref>)
(declare-const u@67@01 $Ref)
(declare-const v@68@01 $Ref)
(declare-const g@69@01 Set<$Ref>)
(declare-const u@70@01 $Ref)
(declare-const v@71@01 $Ref)
(push) ; 1
(declare-const $t@72@01 $Snap)
(assert (= $t@72@01 ($Snap.combine ($Snap.first $t@72@01) ($Snap.second $t@72@01))))
(assert (= ($Snap.first $t@72@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@69@01)))
(assert (=
  ($Snap.second $t@72@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@72@01))
    ($Snap.second ($Snap.second $t@72@01)))))
(declare-const n@73@01 $Ref)
(push) ; 2
; [eval] (n in g)
(assert (Set_in n@73@01 g@69@01))
(declare-const sm@74@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@75@01 ($Ref) $Ref)
(declare-fun img@76@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@73@01 $Ref) (n2@73@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@73@01 g@69@01)
      (Set_in n2@73@01 g@69@01)
      (= n1@73@01 n2@73@01))
    (= n1@73@01 n2@73@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@73@01 $Ref)) (!
  (=>
    (Set_in n@73@01 g@69@01)
    (and (= (inv@75@01 n@73@01) n@73@01) (img@76@01 n@73@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) n@73@01) n@73@01))
  :qid |quant-u-54|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)) (= (inv@75@01 r) r))
  :pattern ((inv@75@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@73@01 $Ref)) (!
  (=> (Set_in n@73@01 g@69@01) (not (= n@73@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) n@73@01) n@73@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@77@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@77@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@75@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) r) r))
  :pattern ((inv@75@01 r))
  :qid |quant-u-55|)))
(assert (=
  ($Snap.second ($Snap.second $t@72@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@72@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@72@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@72@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@78@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 12 | !(n$0@78@01 in g@69@01) | live]
; [else-branch: 12 | n$0@78@01 in g@69@01 | live]
(push) ; 4
; [then-branch: 12 | !(n$0@78@01 in g@69@01)]
(assert (not (Set_in n$0@78@01 g@69@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 12 | n$0@78@01 in g@69@01]
(assert (Set_in n$0@78@01 g@69@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
      (=
        ($FVF.lookup_next (as sm@77@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
    :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
    :qid |qp.fvfValDef35|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef36|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01))
(push) ; 5
(assert (not (and (img@76@01 n$0@78@01) (Set_in (inv@75@01 n$0@78@01) g@69@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@77@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (=>
  (Set_in n$0@78@01 g@69@01)
  (and
    (Set_in n$0@78@01 g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01))))
(assert (or (Set_in n$0@78@01 g@69@01) (not (Set_in n$0@78@01 g@69@01))))
(push) ; 3
; [then-branch: 13 | n$0@78@01 in g@69@01 && Lookup(next, sm@77@01, n$0@78@01) != Null | live]
; [else-branch: 13 | !(n$0@78@01 in g@69@01 && Lookup(next, sm@77@01, n$0@78@01) != Null) | live]
(push) ; 4
; [then-branch: 13 | n$0@78@01 in g@69@01 && Lookup(next, sm@77@01, n$0@78@01) != Null]
(assert (and
  (Set_in n$0@78@01 g@69@01)
  (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
      (=
        ($FVF.lookup_next (as sm@77@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
    :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
    :qid |qp.fvfValDef35|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef36|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01))
(push) ; 5
(assert (not (and (img@76@01 n$0@78@01) (Set_in (inv@75@01 n$0@78@01) g@69@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 13 | !(n$0@78@01 in g@69@01 && Lookup(next, sm@77@01, n$0@78@01) != Null)]
(assert (not
  (and
    (Set_in n$0@78@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@77@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (=>
  (and
    (Set_in n$0@78@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))
  (and
    (Set_in n$0@78@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@78@01 g@69@01)
      (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))))
  (and
    (Set_in n$0@78@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@77@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@77@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@78@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@78@01 g@69@01)
      (and
        (Set_in n$0@78@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01)))
    (or (Set_in n$0@78@01 g@69@01) (not (Set_in n$0@78@01 g@69@01)))
    (=>
      (and
        (Set_in n$0@78@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))
      (and
        (Set_in n$0@78@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01)))
    (or
      (not
        (and
          (Set_in n$0@78@01 g@69@01)
          (not
            (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))))
      (and
        (Set_in n$0@78@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) g@69@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@302@14@302@22-aux|)))
(assert (forall ((n$0@78@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@78@01 g@69@01)
      (and
        (Set_in n$0@78@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01)))
    (or (Set_in n$0@78@01 g@69@01) (not (Set_in n$0@78@01 g@69@01)))
    (=>
      (and
        (Set_in n$0@78@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))
      (and
        (Set_in n$0@78@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01)))
    (or
      (not
        (and
          (Set_in n$0@78@01 g@69@01)
          (not
            (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null))))
      (and
        (Set_in n$0@78@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))))
  :pattern ((Set_in n$0@78@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@302@14@302@22-aux|)))
(assert (forall ((n$0@78@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@78@01 g@69@01)
      (not (= ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) g@69@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) g@69@01))
  :pattern ((Set_in n$0@78@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n$0@78@01) n$0@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@302@14@302@22|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@72@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@72@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@72@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@72@01))))
  $Snap.unit))
; [eval] (u in g)
(assert (Set_in u@70@01 g@69@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@72@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@72@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@72@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@72@01)))))
  $Snap.unit))
; [eval] (v in g)
(assert (Set_in v@71@01 g@69@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@72@01)))))
  $Snap.unit))
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 2
(declare-const n@79@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@79@01 g@69@01))
(pop) ; 3
(declare-fun inv@80@01 ($Ref) $Ref)
(declare-fun img@81@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@79@01 $Ref) (n2@79@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@79@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n1@79@01) n1@79@01))
      (and
        (Set_in n2@79@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) n2@79@01) n2@79@01))
      (= n1@79@01 n2@79@01))
    (= n1@79@01 n2@79@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@79@01 $Ref)) (!
  (=>
    (Set_in n@79@01 g@69@01)
    (and (= (inv@80@01 n@79@01) n@79@01) (img@81@01 n@79@01)))
  :pattern ((Set_in n@79@01 g@69@01))
  :pattern ((inv@80@01 n@79@01))
  :pattern ((img@81@01 n@79@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@81@01 r) (Set_in (inv@80@01 r) g@69@01)) (= (inv@80@01 r) r))
  :pattern ((inv@80@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@80@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) r) r))
  :pattern ((inv@80@01 r))
  :qid |quant-u-57|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@82@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r) (= r (inv@80@01 r)))
    ($Perm.min
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      (pTaken@82@01 r))
    $Perm.No)
  
  :qid |quant-u-59|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r) (= r (inv@80@01 r)))
    (= (- $Perm.Write (pTaken@82@01 r)) $Perm.No))
  
  :qid |quant-u-60|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@83@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@83@01  $FVF<next>)))
      (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r)))
    (=>
      (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r))
      (Set_in r ($FVF.domain_next (as sm@83@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@83@01  $FVF<next>))))
  :qid |qp.fvfDomDef39|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@83@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@83@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@83@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef38|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@83@01  $FVF<next>)) g@69@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@79@01 $Ref)) (!
  (=>
    (Set_in n@79@01 g@69@01)
    (and (= (inv@80@01 n@79@01) n@79@01) (img@81@01 n@79@01)))
  :pattern ((Set_in n@79@01 g@69@01))
  :pattern ((inv@80@01 n@79@01))
  :pattern ((img@81@01 n@79@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@81@01 r) (Set_in (inv@80@01 r) g@69@01)) (= (inv@80@01 r) r))
  :pattern ((inv@80@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@83@01  $FVF<next>)))
      (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r)))
    (=>
      (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r))
      (Set_in r ($FVF.domain_next (as sm@83@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@83@01  $FVF<next>))))
  :qid |qp.fvfDomDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@80@01 r) g@69@01) (img@81@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@83@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@83@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@83@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@80@01 r) g@69@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@77@01  $FVF<next>) r) r))
    :pattern ((inv@80@01 r))
    :qid |quant-u-57|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@83@01  $FVF<next>)) g@69@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@83@01  $FVF<next>)) g@69@01) u@70@01 v@71@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@84@01 $Snap)
(assert (= $t@84@01 ($Snap.combine ($Snap.first $t@84@01) ($Snap.second $t@84@01))))
(assert (= ($Snap.first $t@84@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@84@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@84@01))
    ($Snap.second ($Snap.second $t@84@01)))))
(declare-const n$1@85@01 $Ref)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@85@01 g@69@01))
(declare-const sm@86@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@87@01 ($Ref) $Ref)
(declare-fun img@88@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@85@01 $Ref) (n$12@85@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@85@01 g@69@01)
      (Set_in n$12@85@01 g@69@01)
      (= n$11@85@01 n$12@85@01))
    (= n$11@85@01 n$12@85@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@85@01 $Ref)) (!
  (=>
    (Set_in n$1@85@01 g@69@01)
    (and (= (inv@87@01 n$1@85@01) n$1@85@01) (img@88@01 n$1@85@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) n$1@85@01) n$1@85@01))
  :qid |quant-u-62|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01)) (= (inv@87@01 r) r))
  :pattern ((inv@87@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@85@01 $Ref)) (!
  (=> (Set_in n$1@85@01 g@69@01) (not (= n$1@85@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) n$1@85@01) n$1@85@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@89@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@87@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r))
  :pattern ((inv@87@01 r))
  :qid |quant-u-63|)))
(assert (=
  ($Snap.second ($Snap.second $t@84@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@84@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@84@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@84@01))) $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@90@01 $Ref)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 14 | !(n$2@90@01 in g@69@01) | live]
; [else-branch: 14 | n$2@90@01 in g@69@01 | live]
(push) ; 5
; [then-branch: 14 | !(n$2@90@01 in g@69@01)]
(assert (not (Set_in n$2@90@01 g@69@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 14 | n$2@90@01 in g@69@01]
(assert (Set_in n$2@90@01 g@69@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
      (=
        ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
    :qid |qp.fvfValDef41|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef42|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01))
(push) ; 6
(assert (not (and (img@88@01 n$2@90@01) (Set_in (inv@87@01 n$2@90@01) g@69@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (=>
  (Set_in n$2@90@01 g@69@01)
  (and
    (Set_in n$2@90@01 g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01))))
(assert (or (Set_in n$2@90@01 g@69@01) (not (Set_in n$2@90@01 g@69@01))))
(push) ; 4
; [then-branch: 15 | n$2@90@01 in g@69@01 && Lookup(next, sm@89@01, n$2@90@01) != Null | live]
; [else-branch: 15 | !(n$2@90@01 in g@69@01 && Lookup(next, sm@89@01, n$2@90@01) != Null) | live]
(push) ; 5
; [then-branch: 15 | n$2@90@01 in g@69@01 && Lookup(next, sm@89@01, n$2@90@01) != Null]
(assert (and
  (Set_in n$2@90@01 g@69@01)
  (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
      (=
        ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
    :qid |qp.fvfValDef41|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef42|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01))
(push) ; 6
(assert (not (and (img@88@01 n$2@90@01) (Set_in (inv@87@01 n$2@90@01) g@69@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 15 | !(n$2@90@01 in g@69@01 && Lookup(next, sm@89@01, n$2@90@01) != Null)]
(assert (not
  (and
    (Set_in n$2@90@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef42|)))
(assert (=>
  (and
    (Set_in n$2@90@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))
  (and
    (Set_in n$2@90@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@90@01 g@69@01)
      (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))))
  (and
    (Set_in n$2@90@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef42|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@90@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@90@01 g@69@01)
      (and
        (Set_in n$2@90@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01)))
    (or (Set_in n$2@90@01 g@69@01) (not (Set_in n$2@90@01 g@69@01)))
    (=>
      (and
        (Set_in n$2@90@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))
      (and
        (Set_in n$2@90@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01)))
    (or
      (not
        (and
          (Set_in n$2@90@01 g@69@01)
          (not
            (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))))
      (and
        (Set_in n$2@90@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) g@69@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21-aux|)))
(assert (forall ((n$2@90@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@90@01 g@69@01)
      (and
        (Set_in n$2@90@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01)))
    (or (Set_in n$2@90@01 g@69@01) (not (Set_in n$2@90@01 g@69@01)))
    (=>
      (and
        (Set_in n$2@90@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))
      (and
        (Set_in n$2@90@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01)))
    (or
      (not
        (and
          (Set_in n$2@90@01 g@69@01)
          (not
            (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null))))
      (and
        (Set_in n$2@90@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))))
  :pattern ((Set_in n$2@90@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21-aux|)))
(assert (forall ((n$2@90@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@90@01 g@69@01)
      (not (= ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) g@69@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) g@69@01))
  :pattern ((Set_in n$2@90@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n$2@90@01) n$2@90@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21|)))
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@84@01))) $Snap.unit))
; [eval] exists_path_2($$(g), u, v)
; [eval] $$(g)
(push) ; 3
(declare-const n@91@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@91@01 g@69@01))
(pop) ; 4
(declare-fun inv@92@01 ($Ref) $Ref)
(declare-fun img@93@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@91@01 $Ref) (n2@91@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@91@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n1@91@01) n1@91@01))
      (and
        (Set_in n2@91@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) n2@91@01) n2@91@01))
      (= n1@91@01 n2@91@01))
    (= n1@91@01 n2@91@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@91@01 $Ref)) (!
  (=>
    (Set_in n@91@01 g@69@01)
    (and (= (inv@92@01 n@91@01) n@91@01) (img@93@01 n@91@01)))
  :pattern ((Set_in n@91@01 g@69@01))
  :pattern ((inv@92@01 n@91@01))
  :pattern ((img@93@01 n@91@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@93@01 r) (Set_in (inv@92@01 r) g@69@01)) (= (inv@92@01 r) r))
  :pattern ((inv@92@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@92@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r))
  :pattern ((inv@92@01 r))
  :qid |quant-u-65|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@94@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r) (= r (inv@92@01 r)))
    ($Perm.min
      (ite
        (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      (pTaken@94@01 r))
    $Perm.No)
  
  :qid |quant-u-67|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r) (= r (inv@92@01 r)))
    (= (- $Perm.Write (pTaken@94@01 r)) $Perm.No))
  
  :qid |quant-u-68|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@95@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@95@01  $FVF<next>)))
      (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r)))
    (=>
      (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r))
      (Set_in r ($FVF.domain_next (as sm@95@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@95@01  $FVF<next>))))
  :qid |qp.fvfDomDef45|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r))
      (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@95@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
  :pattern (($FVF.lookup_next (as sm@95@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@95@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef44|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@95@01  $FVF<next>)) g@69@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@91@01 $Ref)) (!
  (=>
    (Set_in n@91@01 g@69@01)
    (and (= (inv@92@01 n@91@01) n@91@01) (img@93@01 n@91@01)))
  :pattern ((Set_in n@91@01 g@69@01))
  :pattern ((inv@92@01 n@91@01))
  :pattern ((img@93@01 n@91@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@93@01 r) (Set_in (inv@92@01 r) g@69@01)) (= (inv@92@01 r) r))
  :pattern ((inv@92@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@95@01  $FVF<next>)))
      (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r)))
    (=>
      (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r))
      (Set_in r ($FVF.domain_next (as sm@95@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@95@01  $FVF<next>))))
  :qid |qp.fvfDomDef45|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@92@01 r) g@69@01) (img@93@01 r))
      (and (img@88@01 r) (Set_in (inv@87@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@95@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r)))
  :pattern (($FVF.lookup_next (as sm@95@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@84@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@95@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef44|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@92@01 r) g@69@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r))
    :pattern ((inv@92@01 r))
    :qid |quant-u-65|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@95@01  $FVF<next>)) g@69@01)))
(assert (exists_path_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@95@01  $FVF<next>)) g@69@01) u@70@01 v@71@01))
(pop) ; 2
(set-option :timeout 0)
(push) ; 2
; [exec]
; inhale apply_IND($$(g), Set(u), inst_uReach_2($$(g), u))
(declare-const $t@96@01 $Snap)
(assert (= $t@96@01 $Snap.unit))
; [eval] apply_IND($$(g), Set(u), inst_uReach_2($$(g), u))
; [eval] $$(g)
(push) ; 3
(declare-const n@97@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@97@01 g@69@01))
(pop) ; 4
(declare-fun inv@98@01 ($Ref) $Ref)
(declare-fun img@99@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@100@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@100@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@100@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@100@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef47|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@97@01 $Ref) (n2@97@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@97@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@100@01  $FVF<next>) n1@97@01) n1@97@01))
      (and
        (Set_in n2@97@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@100@01  $FVF<next>) n2@97@01) n2@97@01))
      (= n1@97@01 n2@97@01))
    (= n1@97@01 n2@97@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@97@01 $Ref)) (!
  (=>
    (Set_in n@97@01 g@69@01)
    (and (= (inv@98@01 n@97@01) n@97@01) (img@99@01 n@97@01)))
  :pattern ((Set_in n@97@01 g@69@01))
  :pattern ((inv@98@01 n@97@01))
  :pattern ((img@99@01 n@97@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@99@01 r) (Set_in (inv@98@01 r) g@69@01)) (= (inv@98@01 r) r))
  :pattern ((inv@98@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@98@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@100@01  $FVF<next>) r) r))
  :pattern ((inv@98@01 r))
  :qid |quant-u-70|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@101@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r) (= r (inv@98@01 r)))
    ($Perm.min
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      (pTaken@101@01 r))
    $Perm.No)
  
  :qid |quant-u-72|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r) (= r (inv@98@01 r)))
    (= (- $Perm.Write (pTaken@101@01 r)) $Perm.No))
  
  :qid |quant-u-73|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@102@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@102@01  $FVF<next>)))
      (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r)))
    (=>
      (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r))
      (Set_in r ($FVF.domain_next (as sm@102@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@102@01  $FVF<next>))))
  :qid |qp.fvfDomDef50|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@102@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@102@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@102@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef49|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@102@01  $FVF<next>)) g@69@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@100@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@100@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@100@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (forall ((n@97@01 $Ref)) (!
  (=>
    (Set_in n@97@01 g@69@01)
    (and (= (inv@98@01 n@97@01) n@97@01) (img@99@01 n@97@01)))
  :pattern ((Set_in n@97@01 g@69@01))
  :pattern ((inv@98@01 n@97@01))
  :pattern ((img@99@01 n@97@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@99@01 r) (Set_in (inv@98@01 r) g@69@01)) (= (inv@98@01 r) r))
  :pattern ((inv@98@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@102@01  $FVF<next>)))
      (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r)))
    (=>
      (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r))
      (Set_in r ($FVF.domain_next (as sm@102@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@102@01  $FVF<next>))))
  :qid |qp.fvfDomDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@98@01 r) g@69@01) (img@99@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@102@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@102@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@102@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef49|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@98@01 r) g@69@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@100@01  $FVF<next>) r) r))
    :pattern ((inv@98@01 r))
    :qid |quant-u-70|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@102@01  $FVF<next>)) g@69@01)))
; [eval] Set(u)
; [eval] inst_uReach_2($$(g), u)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 3
(declare-const n@103@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@103@01 g@69@01))
(pop) ; 4
(declare-fun inv@104@01 ($Ref) $Ref)
(declare-fun img@105@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@106@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@106@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@106@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@106@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef52|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@103@01 $Ref) (n2@103@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@103@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@106@01  $FVF<next>) n1@103@01) n1@103@01))
      (and
        (Set_in n2@103@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@106@01  $FVF<next>) n2@103@01) n2@103@01))
      (= n1@103@01 n2@103@01))
    (= n1@103@01 n2@103@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@103@01 $Ref)) (!
  (=>
    (Set_in n@103@01 g@69@01)
    (and (= (inv@104@01 n@103@01) n@103@01) (img@105@01 n@103@01)))
  :pattern ((Set_in n@103@01 g@69@01))
  :pattern ((inv@104@01 n@103@01))
  :pattern ((img@105@01 n@103@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@105@01 r) (Set_in (inv@104@01 r) g@69@01)) (= (inv@104@01 r) r))
  :pattern ((inv@104@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@104@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@106@01  $FVF<next>) r) r))
  :pattern ((inv@104@01 r))
  :qid |quant-u-75|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@107@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r) (= r (inv@104@01 r)))
    ($Perm.min
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      (pTaken@107@01 r))
    $Perm.No)
  
  :qid |quant-u-77|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r) (= r (inv@104@01 r)))
    (= (- $Perm.Write (pTaken@107@01 r)) $Perm.No))
  
  :qid |quant-u-78|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@108@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@108@01  $FVF<next>)))
      (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r)))
    (=>
      (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r))
      (Set_in r ($FVF.domain_next (as sm@108@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@108@01  $FVF<next>))))
  :qid |qp.fvfDomDef55|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@108@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@108@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@108@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef54|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@108@01  $FVF<next>)) g@69@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@106@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@106@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@106@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef52|)))
(assert (forall ((n@103@01 $Ref)) (!
  (=>
    (Set_in n@103@01 g@69@01)
    (and (= (inv@104@01 n@103@01) n@103@01) (img@105@01 n@103@01)))
  :pattern ((Set_in n@103@01 g@69@01))
  :pattern ((inv@104@01 n@103@01))
  :pattern ((img@105@01 n@103@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@105@01 r) (Set_in (inv@104@01 r) g@69@01)) (= (inv@104@01 r) r))
  :pattern ((inv@104@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@108@01  $FVF<next>)))
      (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r)))
    (=>
      (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r))
      (Set_in r ($FVF.domain_next (as sm@108@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@108@01  $FVF<next>))))
  :qid |qp.fvfDomDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@104@01 r) g@69@01) (img@105@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@108@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@108@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@108@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef54|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@104@01 r) g@69@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@106@01  $FVF<next>) r) r))
    :pattern ((inv@104@01 r))
    :qid |quant-u-75|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@108@01  $FVF<next>)) g@69@01)))
(assert (apply_IND<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@102@01  $FVF<next>)) g@69@01) (Set_singleton u@70@01) (inst_uReach_2<Set<Ref>> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@108@01  $FVF<next>)) g@69@01) u@70@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$1@109@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@109@01 g@69@01))
(declare-const sm@110@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@110@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@110@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@110@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef57|)))
(pop) ; 3
(declare-fun inv@111@01 ($Ref) $Ref)
(declare-fun img@112@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@110@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@110@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@110@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef57|)))
; Nested auxiliary terms: non-globals
(declare-const sm@113@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@113@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@109@01 $Ref) (n$12@109@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@109@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$11@109@01) n$11@109@01))
      (and
        (Set_in n$12@109@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$12@109@01) n$12@109@01))
      (= n$11@109@01 n$12@109@01))
    (= n$11@109@01 n$12@109@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@109@01 $Ref)) (!
  (=>
    (Set_in n$1@109@01 g@69@01)
    (and (= (inv@111@01 n$1@109@01) n$1@109@01) (img@112@01 n$1@109@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@110@01  $FVF<next>) n$1@109@01) n$1@109@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@112@01 r) (Set_in (inv@111@01 r) g@69@01)) (= (inv@111@01 r) r))
  :pattern ((inv@111@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@111@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) r) r))
  :pattern ((inv@111@01 r))
  :qid |quant-u-80|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@114@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@111@01 r) g@69@01) (img@112@01 r) (= r (inv@111@01 r)))
    ($Perm.min
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      (pTaken@114@01 r))
    $Perm.No)
  
  :qid |quant-u-82|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@111@01 r) g@69@01) (img@112@01 r) (= r (inv@111@01 r)))
    (= (- $Perm.Write (pTaken@114@01 r)) $Perm.No))
  
  :qid |quant-u-83|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@115@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 16 | !(n$2@115@01 in g@69@01) | live]
; [else-branch: 16 | n$2@115@01 in g@69@01 | live]
(push) ; 5
; [then-branch: 16 | !(n$2@115@01 in g@69@01)]
(assert (not (Set_in n$2@115@01 g@69@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 16 | n$2@115@01 in g@69@01]
(assert (Set_in n$2@115@01 g@69@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
      (=
        ($FVF.lookup_next (as sm@113@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
    :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
    :qid |qp.fvfValDef58|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef59|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))
(push) ; 6
(assert (not (and (img@76@01 n$2@115@01) (Set_in (inv@75@01 n$2@115@01) g@69@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@113@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
(assert (=>
  (Set_in n$2@115@01 g@69@01)
  (and
    (Set_in n$2@115@01 g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))))
(assert (or (Set_in n$2@115@01 g@69@01) (not (Set_in n$2@115@01 g@69@01))))
(push) ; 4
; [then-branch: 17 | n$2@115@01 in g@69@01 && Lookup(next, sm@113@01, n$2@115@01) != Null | live]
; [else-branch: 17 | !(n$2@115@01 in g@69@01 && Lookup(next, sm@113@01, n$2@115@01) != Null) | live]
(push) ; 5
; [then-branch: 17 | n$2@115@01 in g@69@01 && Lookup(next, sm@113@01, n$2@115@01) != Null]
(assert (and
  (Set_in n$2@115@01 g@69@01)
  (not (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
      (=
        ($FVF.lookup_next (as sm@113@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
    :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
    :qid |qp.fvfValDef58|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef59|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))
(push) ; 6
(assert (not (and (img@76@01 n$2@115@01) (Set_in (inv@75@01 n$2@115@01) g@69@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 17 | !(n$2@115@01 in g@69@01 && Lookup(next, sm@113@01, n$2@115@01) != Null)]
(assert (not
  (and
    (Set_in n$2@115@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@113@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
(assert (=>
  (and
    (Set_in n$2@115@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))
  (and
    (Set_in n$2@115@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@115@01 g@69@01)
      (not
        (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null))))
  (and
    (Set_in n$2@115@01 g@69@01)
    (not (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
    (=
      ($FVF.lookup_next (as sm@113@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@113@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@115@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@115@01 g@69@01)
      (and
        (Set_in n$2@115@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01)))
    (or (Set_in n$2@115@01 g@69@01) (not (Set_in n$2@115@01 g@69@01)))
    (=>
      (and
        (Set_in n$2@115@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))
      (and
        (Set_in n$2@115@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01)))
    (or
      (not
        (and
          (Set_in n$2@115@01 g@69@01)
          (not
            (=
              ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01)
              $Ref.null))))
      (and
        (Set_in n$2@115@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) g@69@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21-aux|)))
(assert (forall ((n$2@115@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@115@01 g@69@01)
      (and
        (Set_in n$2@115@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01)))
    (or (Set_in n$2@115@01 g@69@01) (not (Set_in n$2@115@01 g@69@01)))
    (=>
      (and
        (Set_in n$2@115@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))
      (and
        (Set_in n$2@115@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01)))
    (or
      (not
        (and
          (Set_in n$2@115@01 g@69@01)
          (not
            (=
              ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01)
              $Ref.null))))
      (and
        (Set_in n$2@115@01 g@69@01)
        (not
          (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))))
  :pattern ((Set_in n$2@115@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21-aux|)))
(push) ; 3
(assert (not (forall ((n$2@115@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@115@01 g@69@01)
      (not
        (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) g@69@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) g@69@01))
  :pattern ((Set_in n$2@115@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@115@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@115@01 g@69@01)
      (not
        (= ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) g@69@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) g@69@01))
  :pattern ((Set_in n$2@115@01 g@69@01) ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n$2@115@01) n$2@115@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@305@13@305@21|)))
; [eval] exists_path_2($$(g), u, v)
; [eval] $$(g)
(push) ; 3
(declare-const n@116@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@116@01 g@69@01))
(pop) ; 4
(declare-fun inv@117@01 ($Ref) $Ref)
(declare-fun img@118@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@116@01 $Ref) (n2@116@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@116@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n1@116@01) n1@116@01))
      (and
        (Set_in n2@116@01 g@69@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) n2@116@01) n2@116@01))
      (= n1@116@01 n2@116@01))
    (= n1@116@01 n2@116@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@116@01 $Ref)) (!
  (=>
    (Set_in n@116@01 g@69@01)
    (and (= (inv@117@01 n@116@01) n@116@01) (img@118@01 n@116@01)))
  :pattern ((Set_in n@116@01 g@69@01))
  :pattern ((inv@117@01 n@116@01))
  :pattern ((img@118@01 n@116@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@118@01 r) (Set_in (inv@117@01 r) g@69@01)) (= (inv@117@01 r) r))
  :pattern ((inv@117@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@117@01 r) g@69@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) r) r))
  :pattern ((inv@117@01 r))
  :qid |quant-u-85|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@119@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r) (= r (inv@117@01 r)))
    ($Perm.min
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01))
        $Perm.Write
        $Perm.No)
      (pTaken@119@01 r))
    $Perm.No)
  
  :qid |quant-u-87|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r) (= r (inv@117@01 r)))
    (= (- $Perm.Write (pTaken@119@01 r)) $Perm.No))
  
  :qid |quant-u-88|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@120@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@120@01  $FVF<next>)))
      (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r)))
    (=>
      (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r))
      (Set_in r ($FVF.domain_next (as sm@120@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@120@01  $FVF<next>))))
  :qid |qp.fvfDomDef62|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@120@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@120@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@120@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@120@01  $FVF<next>)) g@69@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@116@01 $Ref)) (!
  (=>
    (Set_in n@116@01 g@69@01)
    (and (= (inv@117@01 n@116@01) n@116@01) (img@118@01 n@116@01)))
  :pattern ((Set_in n@116@01 g@69@01))
  :pattern ((inv@117@01 n@116@01))
  :pattern ((img@118@01 n@116@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@118@01 r) (Set_in (inv@117@01 r) g@69@01)) (= (inv@117@01 r) r))
  :pattern ((inv@117@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@120@01  $FVF<next>)))
      (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r)))
    (=>
      (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r))
      (Set_in r ($FVF.domain_next (as sm@120@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@120@01  $FVF<next>))))
  :qid |qp.fvfDomDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@117@01 r) g@69@01) (img@118@01 r))
      (and (img@76@01 r) (Set_in (inv@75@01 r) g@69@01)))
    (=
      ($FVF.lookup_next (as sm@120@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r)))
  :pattern (($FVF.lookup_next (as sm@120@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@72@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@120@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@117@01 r) g@69@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@113@01  $FVF<next>) r) r))
    :pattern ((inv@117@01 r))
    :qid |quant-u-85|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@120@01  $FVF<next>)) g@69@01)))
(set-option :timeout 0)
(push) ; 3
(assert (not (exists_path_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@120@01  $FVF<next>)) g@69@01) u@70@01 v@71@01)))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (exists_path_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@120@01  $FVF<next>)) g@69@01) u@70@01 v@71@01))
(pop) ; 2
(pop) ; 1
; ---------- lemma_T2_b ----------
(declare-const g@121@01 Set<$Ref>)
(declare-const u@122@01 $Ref)
(declare-const v@123@01 $Ref)
(declare-const g@124@01 Set<$Ref>)
(declare-const u@125@01 $Ref)
(declare-const v@126@01 $Ref)
(push) ; 1
(declare-const $t@127@01 $Snap)
(assert (= $t@127@01 ($Snap.combine ($Snap.first $t@127@01) ($Snap.second $t@127@01))))
(assert (= ($Snap.first $t@127@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@124@01)))
(assert (=
  ($Snap.second $t@127@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@127@01))
    ($Snap.second ($Snap.second $t@127@01)))))
(declare-const n@128@01 $Ref)
(push) ; 2
; [eval] (n in g)
(assert (Set_in n@128@01 g@124@01))
(declare-const sm@129@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@130@01 ($Ref) $Ref)
(declare-fun img@131@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@128@01 $Ref) (n2@128@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@128@01 g@124@01)
      (Set_in n2@128@01 g@124@01)
      (= n1@128@01 n2@128@01))
    (= n1@128@01 n2@128@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@128@01 $Ref)) (!
  (=>
    (Set_in n@128@01 g@124@01)
    (and (= (inv@130@01 n@128@01) n@128@01) (img@131@01 n@128@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) n@128@01) n@128@01))
  :qid |quant-u-90|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)) (= (inv@130@01 r) r))
  :pattern ((inv@130@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@128@01 $Ref)) (!
  (=> (Set_in n@128@01 g@124@01) (not (= n@128@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) n@128@01) n@128@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@132@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@130@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) r) r))
  :pattern ((inv@130@01 r))
  :qid |quant-u-91|)))
(assert (=
  ($Snap.second ($Snap.second $t@127@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@127@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@127@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@127@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@133@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 18 | !(n$0@133@01 in g@124@01) | live]
; [else-branch: 18 | n$0@133@01 in g@124@01 | live]
(push) ; 4
; [then-branch: 18 | !(n$0@133@01 in g@124@01)]
(assert (not (Set_in n$0@133@01 g@124@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 18 | n$0@133@01 in g@124@01]
(assert (Set_in n$0@133@01 g@124@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
      (=
        ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
    :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
    :qid |qp.fvfValDef64|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef65|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01))
(push) ; 5
(assert (not (and (img@131@01 n$0@133@01) (Set_in (inv@130@01 n$0@133@01) g@124@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (=>
  (Set_in n$0@133@01 g@124@01)
  (and
    (Set_in n$0@133@01 g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01))))
(assert (or (Set_in n$0@133@01 g@124@01) (not (Set_in n$0@133@01 g@124@01))))
(push) ; 3
; [then-branch: 19 | n$0@133@01 in g@124@01 && Lookup(next, sm@132@01, n$0@133@01) != Null | live]
; [else-branch: 19 | !(n$0@133@01 in g@124@01 && Lookup(next, sm@132@01, n$0@133@01) != Null) | live]
(push) ; 4
; [then-branch: 19 | n$0@133@01 in g@124@01 && Lookup(next, sm@132@01, n$0@133@01) != Null]
(assert (and
  (Set_in n$0@133@01 g@124@01)
  (not (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
      (=
        ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
    :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
    :qid |qp.fvfValDef64|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef65|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01))
(push) ; 5
(assert (not (and (img@131@01 n$0@133@01) (Set_in (inv@130@01 n$0@133@01) g@124@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 19 | !(n$0@133@01 in g@124@01 && Lookup(next, sm@132@01, n$0@133@01) != Null)]
(assert (not
  (and
    (Set_in n$0@133@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef65|)))
(assert (=>
  (and
    (Set_in n$0@133@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))
  (and
    (Set_in n$0@133@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@133@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null))))
  (and
    (Set_in n$0@133@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef65|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@133@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@133@01 g@124@01)
      (and
        (Set_in n$0@133@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01)))
    (or (Set_in n$0@133@01 g@124@01) (not (Set_in n$0@133@01 g@124@01)))
    (=>
      (and
        (Set_in n$0@133@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))
      (and
        (Set_in n$0@133@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01)))
    (or
      (not
        (and
          (Set_in n$0@133@01 g@124@01)
          (not
            (=
              ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01)
              $Ref.null))))
      (and
        (Set_in n$0@133@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) g@124@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@312@14@312@22-aux|)))
(assert (forall ((n$0@133@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@133@01 g@124@01)
      (and
        (Set_in n$0@133@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01)))
    (or (Set_in n$0@133@01 g@124@01) (not (Set_in n$0@133@01 g@124@01)))
    (=>
      (and
        (Set_in n$0@133@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))
      (and
        (Set_in n$0@133@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01)))
    (or
      (not
        (and
          (Set_in n$0@133@01 g@124@01)
          (not
            (=
              ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01)
              $Ref.null))))
      (and
        (Set_in n$0@133@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))))
  :pattern ((Set_in n$0@133@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@312@14@312@22-aux|)))
(assert (forall ((n$0@133@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@133@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) g@124@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) g@124@01))
  :pattern ((Set_in n$0@133@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n$0@133@01) n$0@133@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@312@14@312@22|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@127@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@127@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@127@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@127@01))))
  $Snap.unit))
; [eval] (u in g)
(assert (Set_in u@125@01 g@124@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@127@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@127@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@127@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@127@01)))))
  $Snap.unit))
; [eval] (v in g)
(assert (Set_in v@126@01 g@124@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@127@01)))))
  $Snap.unit))
; [eval] exists_path_2($$(g), u, v)
; [eval] $$(g)
(push) ; 2
(declare-const n@134@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@134@01 g@124@01))
(pop) ; 3
(declare-fun inv@135@01 ($Ref) $Ref)
(declare-fun img@136@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@134@01 $Ref) (n2@134@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@134@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n1@134@01) n1@134@01))
      (and
        (Set_in n2@134@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) n2@134@01) n2@134@01))
      (= n1@134@01 n2@134@01))
    (= n1@134@01 n2@134@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@134@01 $Ref)) (!
  (=>
    (Set_in n@134@01 g@124@01)
    (and (= (inv@135@01 n@134@01) n@134@01) (img@136@01 n@134@01)))
  :pattern ((Set_in n@134@01 g@124@01))
  :pattern ((inv@135@01 n@134@01))
  :pattern ((img@136@01 n@134@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@136@01 r) (Set_in (inv@135@01 r) g@124@01)) (= (inv@135@01 r) r))
  :pattern ((inv@135@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@135@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) r) r))
  :pattern ((inv@135@01 r))
  :qid |quant-u-93|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@137@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r) (= r (inv@135@01 r)))
    ($Perm.min
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      (pTaken@137@01 r))
    $Perm.No)
  
  :qid |quant-u-95|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r) (= r (inv@135@01 r)))
    (= (- $Perm.Write (pTaken@137@01 r)) $Perm.No))
  
  :qid |quant-u-96|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@138@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@138@01  $FVF<next>)))
      (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r)))
    (=>
      (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r))
      (Set_in r ($FVF.domain_next (as sm@138@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@138@01  $FVF<next>))))
  :qid |qp.fvfDomDef68|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@138@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@138@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@138@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef67|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@138@01  $FVF<next>)) g@124@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@134@01 $Ref)) (!
  (=>
    (Set_in n@134@01 g@124@01)
    (and (= (inv@135@01 n@134@01) n@134@01) (img@136@01 n@134@01)))
  :pattern ((Set_in n@134@01 g@124@01))
  :pattern ((inv@135@01 n@134@01))
  :pattern ((img@136@01 n@134@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@136@01 r) (Set_in (inv@135@01 r) g@124@01)) (= (inv@135@01 r) r))
  :pattern ((inv@135@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@138@01  $FVF<next>)))
      (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r)))
    (=>
      (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r))
      (Set_in r ($FVF.domain_next (as sm@138@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@138@01  $FVF<next>))))
  :qid |qp.fvfDomDef68|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@135@01 r) g@124@01) (img@136@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@138@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@138@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@138@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef67|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@135@01 r) g@124@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@132@01  $FVF<next>) r) r))
    :pattern ((inv@135@01 r))
    :qid |quant-u-93|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@138@01  $FVF<next>)) g@124@01)))
(assert (exists_path_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@138@01  $FVF<next>)) g@124@01) u@125@01 v@126@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@139@01 $Snap)
(assert (= $t@139@01 ($Snap.combine ($Snap.first $t@139@01) ($Snap.second $t@139@01))))
(assert (= ($Snap.first $t@139@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@139@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@139@01))
    ($Snap.second ($Snap.second $t@139@01)))))
(declare-const n$1@140@01 $Ref)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@140@01 g@124@01))
(declare-const sm@141@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@142@01 ($Ref) $Ref)
(declare-fun img@143@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@140@01 $Ref) (n$12@140@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@140@01 g@124@01)
      (Set_in n$12@140@01 g@124@01)
      (= n$11@140@01 n$12@140@01))
    (= n$11@140@01 n$12@140@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@140@01 $Ref)) (!
  (=>
    (Set_in n$1@140@01 g@124@01)
    (and (= (inv@142@01 n$1@140@01) n$1@140@01) (img@143@01 n$1@140@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) n$1@140@01) n$1@140@01))
  :qid |quant-u-98|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01)) (= (inv@142@01 r) r))
  :pattern ((inv@142@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@140@01 $Ref)) (!
  (=> (Set_in n$1@140@01 g@124@01) (not (= n$1@140@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) n$1@140@01) n$1@140@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@144@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@142@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) r) r))
  :pattern ((inv@142@01 r))
  :qid |quant-u-99|)))
(assert (=
  ($Snap.second ($Snap.second $t@139@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@139@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@139@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@139@01))) $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@145@01 $Ref)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 20 | !(n$2@145@01 in g@124@01) | live]
; [else-branch: 20 | n$2@145@01 in g@124@01 | live]
(push) ; 5
; [then-branch: 20 | !(n$2@145@01 in g@124@01)]
(assert (not (Set_in n$2@145@01 g@124@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 20 | n$2@145@01 in g@124@01]
(assert (Set_in n$2@145@01 g@124@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
      (=
        ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
    :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
    :qid |qp.fvfValDef70|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef71|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01))
(push) ; 6
(assert (not (and (img@143@01 n$2@145@01) (Set_in (inv@142@01 n$2@145@01) g@124@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef71|)))
(assert (=>
  (Set_in n$2@145@01 g@124@01)
  (and
    (Set_in n$2@145@01 g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01))))
(assert (or (Set_in n$2@145@01 g@124@01) (not (Set_in n$2@145@01 g@124@01))))
(push) ; 4
; [then-branch: 21 | n$2@145@01 in g@124@01 && Lookup(next, sm@144@01, n$2@145@01) != Null | live]
; [else-branch: 21 | !(n$2@145@01 in g@124@01 && Lookup(next, sm@144@01, n$2@145@01) != Null) | live]
(push) ; 5
; [then-branch: 21 | n$2@145@01 in g@124@01 && Lookup(next, sm@144@01, n$2@145@01) != Null]
(assert (and
  (Set_in n$2@145@01 g@124@01)
  (not (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
      (=
        ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
    :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
    :qid |qp.fvfValDef70|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef71|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01))
(push) ; 6
(assert (not (and (img@143@01 n$2@145@01) (Set_in (inv@142@01 n$2@145@01) g@124@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 21 | !(n$2@145@01 in g@124@01 && Lookup(next, sm@144@01, n$2@145@01) != Null)]
(assert (not
  (and
    (Set_in n$2@145@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef71|)))
(assert (=>
  (and
    (Set_in n$2@145@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))
  (and
    (Set_in n$2@145@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@145@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null))))
  (and
    (Set_in n$2@145@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef71|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@145@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@145@01 g@124@01)
      (and
        (Set_in n$2@145@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01)))
    (or (Set_in n$2@145@01 g@124@01) (not (Set_in n$2@145@01 g@124@01)))
    (=>
      (and
        (Set_in n$2@145@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))
      (and
        (Set_in n$2@145@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01)))
    (or
      (not
        (and
          (Set_in n$2@145@01 g@124@01)
          (not
            (=
              ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01)
              $Ref.null))))
      (and
        (Set_in n$2@145@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) g@124@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21-aux|)))
(assert (forall ((n$2@145@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@145@01 g@124@01)
      (and
        (Set_in n$2@145@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01)))
    (or (Set_in n$2@145@01 g@124@01) (not (Set_in n$2@145@01 g@124@01)))
    (=>
      (and
        (Set_in n$2@145@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))
      (and
        (Set_in n$2@145@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01)))
    (or
      (not
        (and
          (Set_in n$2@145@01 g@124@01)
          (not
            (=
              ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01)
              $Ref.null))))
      (and
        (Set_in n$2@145@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))))
  :pattern ((Set_in n$2@145@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21-aux|)))
(assert (forall ((n$2@145@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@145@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) g@124@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) g@124@01))
  :pattern ((Set_in n$2@145@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n$2@145@01) n$2@145@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21|)))
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@139@01))) $Snap.unit))
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 3
(declare-const n@146@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@146@01 g@124@01))
(pop) ; 4
(declare-fun inv@147@01 ($Ref) $Ref)
(declare-fun img@148@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@146@01 $Ref) (n2@146@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@146@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n1@146@01) n1@146@01))
      (and
        (Set_in n2@146@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n2@146@01) n2@146@01))
      (= n1@146@01 n2@146@01))
    (= n1@146@01 n2@146@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@146@01 $Ref)) (!
  (=>
    (Set_in n@146@01 g@124@01)
    (and (= (inv@147@01 n@146@01) n@146@01) (img@148@01 n@146@01)))
  :pattern ((Set_in n@146@01 g@124@01))
  :pattern ((inv@147@01 n@146@01))
  :pattern ((img@148@01 n@146@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@148@01 r) (Set_in (inv@147@01 r) g@124@01)) (= (inv@147@01 r) r))
  :pattern ((inv@147@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@147@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) r) r))
  :pattern ((inv@147@01 r))
  :qid |quant-u-101|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@149@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r) (= r (inv@147@01 r)))
    ($Perm.min
      (ite
        (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      (pTaken@149@01 r))
    $Perm.No)
  
  :qid |quant-u-103|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r) (= r (inv@147@01 r)))
    (= (- $Perm.Write (pTaken@149@01 r)) $Perm.No))
  
  :qid |quant-u-104|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@150@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@150@01  $FVF<next>)))
      (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r)))
    (=>
      (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r))
      (Set_in r ($FVF.domain_next (as sm@150@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@150@01  $FVF<next>))))
  :qid |qp.fvfDomDef74|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r))
      (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@150@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
  :pattern (($FVF.lookup_next (as sm@150@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@150@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@150@01  $FVF<next>)) g@124@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@146@01 $Ref)) (!
  (=>
    (Set_in n@146@01 g@124@01)
    (and (= (inv@147@01 n@146@01) n@146@01) (img@148@01 n@146@01)))
  :pattern ((Set_in n@146@01 g@124@01))
  :pattern ((inv@147@01 n@146@01))
  :pattern ((img@148@01 n@146@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@148@01 r) (Set_in (inv@147@01 r) g@124@01)) (= (inv@147@01 r) r))
  :pattern ((inv@147@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@150@01  $FVF<next>)))
      (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r)))
    (=>
      (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r))
      (Set_in r ($FVF.domain_next (as sm@150@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@150@01  $FVF<next>))))
  :qid |qp.fvfDomDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@147@01 r) g@124@01) (img@148@01 r))
      (and (img@143@01 r) (Set_in (inv@142@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@150@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r)))
  :pattern (($FVF.lookup_next (as sm@150@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@139@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@150@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef73|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@147@01 r) g@124@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) r) r))
    :pattern ((inv@147@01 r))
    :qid |quant-u-101|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@150@01  $FVF<next>)) g@124@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@150@01  $FVF<next>)) g@124@01) u@125@01 v@126@01))
(pop) ; 2
(set-option :timeout 0)
(push) ; 2
; [exec]
; inhale apply_IND_2($$(g), Set(v), inst_uReach_rev($$(g), v))
(declare-const $t@151@01 $Snap)
(assert (= $t@151@01 $Snap.unit))
; [eval] apply_IND_2($$(g), Set(v), inst_uReach_rev($$(g), v))
; [eval] $$(g)
(push) ; 3
(declare-const n@152@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@152@01 g@124@01))
(pop) ; 4
(declare-fun inv@153@01 ($Ref) $Ref)
(declare-fun img@154@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@155@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@155@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@155@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@155@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@152@01 $Ref) (n2@152@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@152@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@155@01  $FVF<next>) n1@152@01) n1@152@01))
      (and
        (Set_in n2@152@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@155@01  $FVF<next>) n2@152@01) n2@152@01))
      (= n1@152@01 n2@152@01))
    (= n1@152@01 n2@152@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@152@01 $Ref)) (!
  (=>
    (Set_in n@152@01 g@124@01)
    (and (= (inv@153@01 n@152@01) n@152@01) (img@154@01 n@152@01)))
  :pattern ((Set_in n@152@01 g@124@01))
  :pattern ((inv@153@01 n@152@01))
  :pattern ((img@154@01 n@152@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@154@01 r) (Set_in (inv@153@01 r) g@124@01)) (= (inv@153@01 r) r))
  :pattern ((inv@153@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@153@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@155@01  $FVF<next>) r) r))
  :pattern ((inv@153@01 r))
  :qid |quant-u-106|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@156@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r) (= r (inv@153@01 r)))
    ($Perm.min
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      (pTaken@156@01 r))
    $Perm.No)
  
  :qid |quant-u-108|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r) (= r (inv@153@01 r)))
    (= (- $Perm.Write (pTaken@156@01 r)) $Perm.No))
  
  :qid |quant-u-109|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@157@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@157@01  $FVF<next>)))
      (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r)))
    (=>
      (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r))
      (Set_in r ($FVF.domain_next (as sm@157@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@157@01  $FVF<next>))))
  :qid |qp.fvfDomDef79|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@157@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@157@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef77|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@157@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef78|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@157@01  $FVF<next>)) g@124@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@155@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@155@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@155@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((n@152@01 $Ref)) (!
  (=>
    (Set_in n@152@01 g@124@01)
    (and (= (inv@153@01 n@152@01) n@152@01) (img@154@01 n@152@01)))
  :pattern ((Set_in n@152@01 g@124@01))
  :pattern ((inv@153@01 n@152@01))
  :pattern ((img@154@01 n@152@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@154@01 r) (Set_in (inv@153@01 r) g@124@01)) (= (inv@153@01 r) r))
  :pattern ((inv@153@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@157@01  $FVF<next>)))
      (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r)))
    (=>
      (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r))
      (Set_in r ($FVF.domain_next (as sm@157@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@157@01  $FVF<next>))))
  :qid |qp.fvfDomDef79|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@153@01 r) g@124@01) (img@154@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@157@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@157@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef77|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@157@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef78|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@153@01 r) g@124@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@155@01  $FVF<next>) r) r))
    :pattern ((inv@153@01 r))
    :qid |quant-u-106|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@157@01  $FVF<next>)) g@124@01)))
; [eval] Set(v)
; [eval] inst_uReach_rev($$(g), v)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 3
(declare-const n@158@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@158@01 g@124@01))
(pop) ; 4
(declare-fun inv@159@01 ($Ref) $Ref)
(declare-fun img@160@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@161@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@161@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@161@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@161@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@158@01 $Ref) (n2@158@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@158@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@161@01  $FVF<next>) n1@158@01) n1@158@01))
      (and
        (Set_in n2@158@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@161@01  $FVF<next>) n2@158@01) n2@158@01))
      (= n1@158@01 n2@158@01))
    (= n1@158@01 n2@158@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@158@01 $Ref)) (!
  (=>
    (Set_in n@158@01 g@124@01)
    (and (= (inv@159@01 n@158@01) n@158@01) (img@160@01 n@158@01)))
  :pattern ((Set_in n@158@01 g@124@01))
  :pattern ((inv@159@01 n@158@01))
  :pattern ((img@160@01 n@158@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@160@01 r) (Set_in (inv@159@01 r) g@124@01)) (= (inv@159@01 r) r))
  :pattern ((inv@159@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@159@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@161@01  $FVF<next>) r) r))
  :pattern ((inv@159@01 r))
  :qid |quant-u-111|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@162@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r) (= r (inv@159@01 r)))
    ($Perm.min
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      (pTaken@162@01 r))
    $Perm.No)
  
  :qid |quant-u-113|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r) (= r (inv@159@01 r)))
    (= (- $Perm.Write (pTaken@162@01 r)) $Perm.No))
  
  :qid |quant-u-114|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@163@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@163@01  $FVF<next>)))
      (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r)))
    (=>
      (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r))
      (Set_in r ($FVF.domain_next (as sm@163@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@163@01  $FVF<next>))))
  :qid |qp.fvfDomDef84|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@163@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@163@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@163@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef83|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@163@01  $FVF<next>)) g@124@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@161@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@161@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@161@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert (forall ((n@158@01 $Ref)) (!
  (=>
    (Set_in n@158@01 g@124@01)
    (and (= (inv@159@01 n@158@01) n@158@01) (img@160@01 n@158@01)))
  :pattern ((Set_in n@158@01 g@124@01))
  :pattern ((inv@159@01 n@158@01))
  :pattern ((img@160@01 n@158@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@160@01 r) (Set_in (inv@159@01 r) g@124@01)) (= (inv@159@01 r) r))
  :pattern ((inv@159@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@163@01  $FVF<next>)))
      (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r)))
    (=>
      (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r))
      (Set_in r ($FVF.domain_next (as sm@163@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@163@01  $FVF<next>))))
  :qid |qp.fvfDomDef84|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@159@01 r) g@124@01) (img@160@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@163@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@163@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@163@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef83|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@159@01 r) g@124@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@161@01  $FVF<next>) r) r))
    :pattern ((inv@159@01 r))
    :qid |quant-u-111|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@163@01  $FVF<next>)) g@124@01)))
(assert (apply_IND_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@157@01  $FVF<next>)) g@124@01) (Set_singleton v@126@01) (inst_uReach_rev<Set<Ref>> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@163@01  $FVF<next>)) g@124@01) v@126@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$1@164@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@164@01 g@124@01))
(declare-const sm@165@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@165@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@165@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@165@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef86|)))
(pop) ; 3
(declare-fun inv@166@01 ($Ref) $Ref)
(declare-fun img@167@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@165@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@165@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@165@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef86|)))
; Nested auxiliary terms: non-globals
(declare-const sm@168@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@168@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef88|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@164@01 $Ref) (n$12@164@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@164@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$11@164@01) n$11@164@01))
      (and
        (Set_in n$12@164@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$12@164@01) n$12@164@01))
      (= n$11@164@01 n$12@164@01))
    (= n$11@164@01 n$12@164@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@164@01 $Ref)) (!
  (=>
    (Set_in n$1@164@01 g@124@01)
    (and (= (inv@166@01 n$1@164@01) n$1@164@01) (img@167@01 n$1@164@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@165@01  $FVF<next>) n$1@164@01) n$1@164@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@167@01 r) (Set_in (inv@166@01 r) g@124@01)) (= (inv@166@01 r) r))
  :pattern ((inv@166@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@166@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) r) r))
  :pattern ((inv@166@01 r))
  :qid |quant-u-116|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@169@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@166@01 r) g@124@01) (img@167@01 r) (= r (inv@166@01 r)))
    ($Perm.min
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      (pTaken@169@01 r))
    $Perm.No)
  
  :qid |quant-u-118|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@166@01 r) g@124@01) (img@167@01 r) (= r (inv@166@01 r)))
    (= (- $Perm.Write (pTaken@169@01 r)) $Perm.No))
  
  :qid |quant-u-119|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@170@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 22 | !(n$2@170@01 in g@124@01) | live]
; [else-branch: 22 | n$2@170@01 in g@124@01 | live]
(push) ; 5
; [then-branch: 22 | !(n$2@170@01 in g@124@01)]
(assert (not (Set_in n$2@170@01 g@124@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 22 | n$2@170@01 in g@124@01]
(assert (Set_in n$2@170@01 g@124@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
      (=
        ($FVF.lookup_next (as sm@168@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
    :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
    :qid |qp.fvfValDef87|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef88|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))
(push) ; 6
(assert (not (and (img@131@01 n$2@170@01) (Set_in (inv@130@01 n$2@170@01) g@124@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@168@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef88|)))
(assert (=>
  (Set_in n$2@170@01 g@124@01)
  (and
    (Set_in n$2@170@01 g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))))
(assert (or (Set_in n$2@170@01 g@124@01) (not (Set_in n$2@170@01 g@124@01))))
(push) ; 4
; [then-branch: 23 | n$2@170@01 in g@124@01 && Lookup(next, sm@168@01, n$2@170@01) != Null | live]
; [else-branch: 23 | !(n$2@170@01 in g@124@01 && Lookup(next, sm@168@01, n$2@170@01) != Null) | live]
(push) ; 5
; [then-branch: 23 | n$2@170@01 in g@124@01 && Lookup(next, sm@168@01, n$2@170@01) != Null]
(assert (and
  (Set_in n$2@170@01 g@124@01)
  (not (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
      (=
        ($FVF.lookup_next (as sm@168@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
    :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
    :qid |qp.fvfValDef87|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef88|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))
(push) ; 6
(assert (not (and (img@131@01 n$2@170@01) (Set_in (inv@130@01 n$2@170@01) g@124@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 23 | !(n$2@170@01 in g@124@01 && Lookup(next, sm@168@01, n$2@170@01) != Null)]
(assert (not
  (and
    (Set_in n$2@170@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@168@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef88|)))
(assert (=>
  (and
    (Set_in n$2@170@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))
  (and
    (Set_in n$2@170@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@170@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null))))
  (and
    (Set_in n$2@170@01 g@124@01)
    (not (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
    (=
      ($FVF.lookup_next (as sm@168@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@168@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef88|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@170@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@170@01 g@124@01)
      (and
        (Set_in n$2@170@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01)))
    (or (Set_in n$2@170@01 g@124@01) (not (Set_in n$2@170@01 g@124@01)))
    (=>
      (and
        (Set_in n$2@170@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))
      (and
        (Set_in n$2@170@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01)))
    (or
      (not
        (and
          (Set_in n$2@170@01 g@124@01)
          (not
            (=
              ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01)
              $Ref.null))))
      (and
        (Set_in n$2@170@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) g@124@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21-aux|)))
(assert (forall ((n$2@170@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@170@01 g@124@01)
      (and
        (Set_in n$2@170@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01)))
    (or (Set_in n$2@170@01 g@124@01) (not (Set_in n$2@170@01 g@124@01)))
    (=>
      (and
        (Set_in n$2@170@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))
      (and
        (Set_in n$2@170@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01)))
    (or
      (not
        (and
          (Set_in n$2@170@01 g@124@01)
          (not
            (=
              ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01)
              $Ref.null))))
      (and
        (Set_in n$2@170@01 g@124@01)
        (not
          (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))))
  :pattern ((Set_in n$2@170@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21-aux|)))
(push) ; 3
(assert (not (forall ((n$2@170@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@170@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) g@124@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) g@124@01))
  :pattern ((Set_in n$2@170@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@170@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@170@01 g@124@01)
      (not
        (= ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) g@124@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) g@124@01))
  :pattern ((Set_in n$2@170@01 g@124@01) ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n$2@170@01) n$2@170@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@315@13@315@21|)))
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 3
(declare-const n@171@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@171@01 g@124@01))
(pop) ; 4
(declare-fun inv@172@01 ($Ref) $Ref)
(declare-fun img@173@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@171@01 $Ref) (n2@171@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@171@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n1@171@01) n1@171@01))
      (and
        (Set_in n2@171@01 g@124@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) n2@171@01) n2@171@01))
      (= n1@171@01 n2@171@01))
    (= n1@171@01 n2@171@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@171@01 $Ref)) (!
  (=>
    (Set_in n@171@01 g@124@01)
    (and (= (inv@172@01 n@171@01) n@171@01) (img@173@01 n@171@01)))
  :pattern ((Set_in n@171@01 g@124@01))
  :pattern ((inv@172@01 n@171@01))
  :pattern ((img@173@01 n@171@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@173@01 r) (Set_in (inv@172@01 r) g@124@01)) (= (inv@172@01 r) r))
  :pattern ((inv@172@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@172@01 r) g@124@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) r) r))
  :pattern ((inv@172@01 r))
  :qid |quant-u-121|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@174@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r) (= r (inv@172@01 r)))
    ($Perm.min
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01))
        $Perm.Write
        $Perm.No)
      (pTaken@174@01 r))
    $Perm.No)
  
  :qid |quant-u-123|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r) (= r (inv@172@01 r)))
    (= (- $Perm.Write (pTaken@174@01 r)) $Perm.No))
  
  :qid |quant-u-124|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@175@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@175@01  $FVF<next>)))
      (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r)))
    (=>
      (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r))
      (Set_in r ($FVF.domain_next (as sm@175@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@175@01  $FVF<next>))))
  :qid |qp.fvfDomDef91|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@175@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@175@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@175@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@175@01  $FVF<next>)) g@124@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@171@01 $Ref)) (!
  (=>
    (Set_in n@171@01 g@124@01)
    (and (= (inv@172@01 n@171@01) n@171@01) (img@173@01 n@171@01)))
  :pattern ((Set_in n@171@01 g@124@01))
  :pattern ((inv@172@01 n@171@01))
  :pattern ((img@173@01 n@171@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@173@01 r) (Set_in (inv@172@01 r) g@124@01)) (= (inv@172@01 r) r))
  :pattern ((inv@172@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@175@01  $FVF<next>)))
      (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r)))
    (=>
      (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r))
      (Set_in r ($FVF.domain_next (as sm@175@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@175@01  $FVF<next>))))
  :qid |qp.fvfDomDef91|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@172@01 r) g@124@01) (img@173@01 r))
      (and (img@131@01 r) (Set_in (inv@130@01 r) g@124@01)))
    (=
      ($FVF.lookup_next (as sm@175@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r)))
  :pattern (($FVF.lookup_next (as sm@175@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@127@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@175@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@172@01 r) g@124@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@168@01  $FVF<next>) r) r))
    :pattern ((inv@172@01 r))
    :qid |quant-u-121|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@175@01  $FVF<next>)) g@124@01)))
(set-option :timeout 0)
(push) ; 3
(assert (not (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@175@01  $FVF<next>)) g@124@01) u@125@01 v@126@01)))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@175@01  $FVF<next>)) g@124@01) u@125@01 v@126@01))
(pop) ; 2
(pop) ; 1
; ---------- test_trans ----------
(declare-const g@176@01 Set<$Ref>)
(declare-const u@177@01 $Ref)
(declare-const w@178@01 $Ref)
(declare-const v@179@01 $Ref)
(declare-const g@180@01 Set<$Ref>)
(declare-const u@181@01 $Ref)
(declare-const w@182@01 $Ref)
(declare-const v@183@01 $Ref)
(push) ; 1
(declare-const $t@184@01 $Snap)
(assert (= $t@184@01 ($Snap.combine ($Snap.first $t@184@01) ($Snap.second $t@184@01))))
(assert (= ($Snap.first $t@184@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@180@01)))
(assert (=
  ($Snap.second $t@184@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@184@01))
    ($Snap.second ($Snap.second $t@184@01)))))
(declare-const n@185@01 $Ref)
(push) ; 2
; [eval] (n in g)
(assert (Set_in n@185@01 g@180@01))
(declare-const sm@186@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@187@01 ($Ref) $Ref)
(declare-fun img@188@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@185@01 $Ref) (n2@185@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@185@01 g@180@01)
      (Set_in n2@185@01 g@180@01)
      (= n1@185@01 n2@185@01))
    (= n1@185@01 n2@185@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@185@01 $Ref)) (!
  (=>
    (Set_in n@185@01 g@180@01)
    (and (= (inv@187@01 n@185@01) n@185@01) (img@188@01 n@185@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) n@185@01) n@185@01))
  :qid |quant-u-126|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)) (= (inv@187@01 r) r))
  :pattern ((inv@187@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@185@01 $Ref)) (!
  (=> (Set_in n@185@01 g@180@01) (not (= n@185@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) n@185@01) n@185@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@189@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@187@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) r) r))
  :pattern ((inv@187@01 r))
  :qid |quant-u-127|)))
(assert (=
  ($Snap.second ($Snap.second $t@184@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@184@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@184@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@184@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@190@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 24 | !(n$0@190@01 in g@180@01) | live]
; [else-branch: 24 | n$0@190@01 in g@180@01 | live]
(push) ; 4
; [then-branch: 24 | !(n$0@190@01 in g@180@01)]
(assert (not (Set_in n$0@190@01 g@180@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 24 | n$0@190@01 in g@180@01]
(assert (Set_in n$0@190@01 g@180@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
      (=
        ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
    :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01))
(push) ; 5
(assert (not (and (img@188@01 n$0@190@01) (Set_in (inv@187@01 n$0@190@01) g@180@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (Set_in n$0@190@01 g@180@01)
  (and
    (Set_in n$0@190@01 g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01))))
(assert (or (Set_in n$0@190@01 g@180@01) (not (Set_in n$0@190@01 g@180@01))))
(push) ; 3
; [then-branch: 25 | n$0@190@01 in g@180@01 && Lookup(next, sm@189@01, n$0@190@01) != Null | live]
; [else-branch: 25 | !(n$0@190@01 in g@180@01 && Lookup(next, sm@189@01, n$0@190@01) != Null) | live]
(push) ; 4
; [then-branch: 25 | n$0@190@01 in g@180@01 && Lookup(next, sm@189@01, n$0@190@01) != Null]
(assert (and
  (Set_in n$0@190@01 g@180@01)
  (not (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
      (=
        ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
    :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01))
(push) ; 5
(assert (not (and (img@188@01 n$0@190@01) (Set_in (inv@187@01 n$0@190@01) g@180@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 25 | !(n$0@190@01 in g@180@01 && Lookup(next, sm@189@01, n$0@190@01) != Null)]
(assert (not
  (and
    (Set_in n$0@190@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (and
    (Set_in n$0@190@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))
  (and
    (Set_in n$0@190@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@190@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null))))
  (and
    (Set_in n$0@190@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@190@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@190@01 g@180@01)
      (and
        (Set_in n$0@190@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01)))
    (or (Set_in n$0@190@01 g@180@01) (not (Set_in n$0@190@01 g@180@01)))
    (=>
      (and
        (Set_in n$0@190@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))
      (and
        (Set_in n$0@190@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01)))
    (or
      (not
        (and
          (Set_in n$0@190@01 g@180@01)
          (not
            (=
              ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01)
              $Ref.null))))
      (and
        (Set_in n$0@190@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) g@180@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@322@14@322@22-aux|)))
(assert (forall ((n$0@190@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@190@01 g@180@01)
      (and
        (Set_in n$0@190@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01)))
    (or (Set_in n$0@190@01 g@180@01) (not (Set_in n$0@190@01 g@180@01)))
    (=>
      (and
        (Set_in n$0@190@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))
      (and
        (Set_in n$0@190@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01)))
    (or
      (not
        (and
          (Set_in n$0@190@01 g@180@01)
          (not
            (=
              ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01)
              $Ref.null))))
      (and
        (Set_in n$0@190@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))))
  :pattern ((Set_in n$0@190@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@322@14@322@22-aux|)))
(assert (forall ((n$0@190@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@190@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) g@180@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) g@180@01))
  :pattern ((Set_in n$0@190@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n$0@190@01) n$0@190@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@322@14@322@22|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@184@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@184@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@184@01))))
  $Snap.unit))
; [eval] (u in g)
(assert (Set_in u@181@01 g@180@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))
  $Snap.unit))
; [eval] (w in g)
(assert (Set_in w@182@01 g@180@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01))))))
  $Snap.unit))
; [eval] (v in g)
(assert (Set_in v@183@01 g@180@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))))
  $Snap.unit))
; [eval] exists_path($$(g), u, w)
; [eval] $$(g)
(push) ; 2
(declare-const n@191@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@191@01 g@180@01))
(pop) ; 3
(declare-fun inv@192@01 ($Ref) $Ref)
(declare-fun img@193@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@191@01 $Ref) (n2@191@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@191@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n1@191@01) n1@191@01))
      (and
        (Set_in n2@191@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) n2@191@01) n2@191@01))
      (= n1@191@01 n2@191@01))
    (= n1@191@01 n2@191@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@191@01 $Ref)) (!
  (=>
    (Set_in n@191@01 g@180@01)
    (and (= (inv@192@01 n@191@01) n@191@01) (img@193@01 n@191@01)))
  :pattern ((Set_in n@191@01 g@180@01))
  :pattern ((inv@192@01 n@191@01))
  :pattern ((img@193@01 n@191@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@193@01 r) (Set_in (inv@192@01 r) g@180@01)) (= (inv@192@01 r) r))
  :pattern ((inv@192@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@192@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) r) r))
  :pattern ((inv@192@01 r))
  :qid |quant-u-129|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@194@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r) (= r (inv@192@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@194@01 r))
    $Perm.No)
  
  :qid |quant-u-131|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r) (= r (inv@192@01 r)))
    (= (- $Perm.Write (pTaken@194@01 r)) $Perm.No))
  
  :qid |quant-u-132|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@195@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r)))
    (=>
      (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef97|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g@180@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@191@01 $Ref)) (!
  (=>
    (Set_in n@191@01 g@180@01)
    (and (= (inv@192@01 n@191@01) n@191@01) (img@193@01 n@191@01)))
  :pattern ((Set_in n@191@01 g@180@01))
  :pattern ((inv@192@01 n@191@01))
  :pattern ((img@193@01 n@191@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@193@01 r) (Set_in (inv@192@01 r) g@180@01)) (= (inv@192@01 r) r))
  :pattern ((inv@192@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r)))
    (=>
      (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@192@01 r) g@180@01) (img@193@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@192@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@189@01  $FVF<next>) r) r))
    :pattern ((inv@192@01 r))
    :qid |quant-u-129|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g@180@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g@180@01) u@181@01 w@182@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@184@01)))))))
  $Snap.unit))
; [eval] exists_path($$(g), w, v)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 2
(declare-const n@196@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@196@01 g@180@01))
(pop) ; 3
(declare-fun inv@197@01 ($Ref) $Ref)
(declare-fun img@198@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@199@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@196@01 $Ref) (n2@196@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@196@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) n1@196@01) n1@196@01))
      (and
        (Set_in n2@196@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) n2@196@01) n2@196@01))
      (= n1@196@01 n2@196@01))
    (= n1@196@01 n2@196@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@196@01 $Ref)) (!
  (=>
    (Set_in n@196@01 g@180@01)
    (and (= (inv@197@01 n@196@01) n@196@01) (img@198@01 n@196@01)))
  :pattern ((Set_in n@196@01 g@180@01))
  :pattern ((inv@197@01 n@196@01))
  :pattern ((img@198@01 n@196@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@198@01 r) (Set_in (inv@197@01 r) g@180@01)) (= (inv@197@01 r) r))
  :pattern ((inv@197@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@197@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
  :pattern ((inv@197@01 r))
  :qid |quant-u-134|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@200@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r) (= r (inv@197@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@200@01 r))
    $Perm.No)
  
  :qid |quant-u-136|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r) (= r (inv@197@01 r)))
    (= (- $Perm.Write (pTaken@200@01 r)) $Perm.No))
  
  :qid |quant-u-137|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@201@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))
      (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r)))
    (=>
      (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r))
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>))))
  :qid |qp.fvfDomDef102|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@201@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef101|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@201@01  $FVF<next>)) g@180@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((n@196@01 $Ref)) (!
  (=>
    (Set_in n@196@01 g@180@01)
    (and (= (inv@197@01 n@196@01) n@196@01) (img@198@01 n@196@01)))
  :pattern ((Set_in n@196@01 g@180@01))
  :pattern ((inv@197@01 n@196@01))
  :pattern ((img@198@01 n@196@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@198@01 r) (Set_in (inv@197@01 r) g@180@01)) (= (inv@197@01 r) r))
  :pattern ((inv@197@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))
      (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r)))
    (=>
      (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r))
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>))))
  :qid |qp.fvfDomDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) g@180@01) (img@198@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@201@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef101|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@197@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
    :pattern ((inv@197@01 r))
    :qid |quant-u-134|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@201@01  $FVF<next>)) g@180@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@201@01  $FVF<next>)) g@180@01) w@182@01 v@183@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@202@01 $Snap)
(assert (= $t@202@01 ($Snap.combine ($Snap.first $t@202@01) ($Snap.second $t@202@01))))
(assert (= ($Snap.first $t@202@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@202@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@202@01))
    ($Snap.second ($Snap.second $t@202@01)))))
(declare-const n$1@203@01 $Ref)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@203@01 g@180@01))
(declare-const sm@204@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@205@01 ($Ref) $Ref)
(declare-fun img@206@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@203@01 $Ref) (n$12@203@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@203@01 g@180@01)
      (Set_in n$12@203@01 g@180@01)
      (= n$11@203@01 n$12@203@01))
    (= n$11@203@01 n$12@203@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@203@01 $Ref)) (!
  (=>
    (Set_in n$1@203@01 g@180@01)
    (and (= (inv@205@01 n$1@203@01) n$1@203@01) (img@206@01 n$1@203@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) n$1@203@01) n$1@203@01))
  :qid |quant-u-139|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01)) (= (inv@205@01 r) r))
  :pattern ((inv@205@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@203@01 $Ref)) (!
  (=> (Set_in n$1@203@01 g@180@01) (not (= n$1@203@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) n$1@203@01) n$1@203@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@207@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@205@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) r) r))
  :pattern ((inv@205@01 r))
  :qid |quant-u-140|)))
(assert (=
  ($Snap.second ($Snap.second $t@202@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@202@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@202@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@202@01))) $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@208@01 $Ref)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 26 | !(n$2@208@01 in g@180@01) | live]
; [else-branch: 26 | n$2@208@01 in g@180@01 | live]
(push) ; 5
; [then-branch: 26 | !(n$2@208@01 in g@180@01)]
(assert (not (Set_in n$2@208@01 g@180@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 26 | n$2@208@01 in g@180@01]
(assert (Set_in n$2@208@01 g@180@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
      (=
        ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
    :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
    :qid |qp.fvfValDef104|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef105|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01))
(push) ; 6
(assert (not (and (img@206@01 n$2@208@01) (Set_in (inv@205@01 n$2@208@01) g@180@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef105|)))
(assert (=>
  (Set_in n$2@208@01 g@180@01)
  (and
    (Set_in n$2@208@01 g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01))))
(assert (or (Set_in n$2@208@01 g@180@01) (not (Set_in n$2@208@01 g@180@01))))
(push) ; 4
; [then-branch: 27 | n$2@208@01 in g@180@01 && Lookup(next, sm@207@01, n$2@208@01) != Null | live]
; [else-branch: 27 | !(n$2@208@01 in g@180@01 && Lookup(next, sm@207@01, n$2@208@01) != Null) | live]
(push) ; 5
; [then-branch: 27 | n$2@208@01 in g@180@01 && Lookup(next, sm@207@01, n$2@208@01) != Null]
(assert (and
  (Set_in n$2@208@01 g@180@01)
  (not (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
      (=
        ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
    :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
    :qid |qp.fvfValDef104|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef105|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01))
(push) ; 6
(assert (not (and (img@206@01 n$2@208@01) (Set_in (inv@205@01 n$2@208@01) g@180@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 27 | !(n$2@208@01 in g@180@01 && Lookup(next, sm@207@01, n$2@208@01) != Null)]
(assert (not
  (and
    (Set_in n$2@208@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef105|)))
(assert (=>
  (and
    (Set_in n$2@208@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))
  (and
    (Set_in n$2@208@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@208@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null))))
  (and
    (Set_in n$2@208@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef105|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@208@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@208@01 g@180@01)
      (and
        (Set_in n$2@208@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01)))
    (or (Set_in n$2@208@01 g@180@01) (not (Set_in n$2@208@01 g@180@01)))
    (=>
      (and
        (Set_in n$2@208@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))
      (and
        (Set_in n$2@208@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01)))
    (or
      (not
        (and
          (Set_in n$2@208@01 g@180@01)
          (not
            (=
              ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01)
              $Ref.null))))
      (and
        (Set_in n$2@208@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) g@180@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21-aux|)))
(assert (forall ((n$2@208@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@208@01 g@180@01)
      (and
        (Set_in n$2@208@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01)))
    (or (Set_in n$2@208@01 g@180@01) (not (Set_in n$2@208@01 g@180@01)))
    (=>
      (and
        (Set_in n$2@208@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))
      (and
        (Set_in n$2@208@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01)))
    (or
      (not
        (and
          (Set_in n$2@208@01 g@180@01)
          (not
            (=
              ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01)
              $Ref.null))))
      (and
        (Set_in n$2@208@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))))
  :pattern ((Set_in n$2@208@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21-aux|)))
(assert (forall ((n$2@208@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@208@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) g@180@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) g@180@01))
  :pattern ((Set_in n$2@208@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n$2@208@01) n$2@208@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21|)))
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@202@01))) $Snap.unit))
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 3
(declare-const n@209@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@209@01 g@180@01))
(pop) ; 4
(declare-fun inv@210@01 ($Ref) $Ref)
(declare-fun img@211@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@209@01 $Ref) (n2@209@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@209@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n1@209@01) n1@209@01))
      (and
        (Set_in n2@209@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) n2@209@01) n2@209@01))
      (= n1@209@01 n2@209@01))
    (= n1@209@01 n2@209@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@209@01 $Ref)) (!
  (=>
    (Set_in n@209@01 g@180@01)
    (and (= (inv@210@01 n@209@01) n@209@01) (img@211@01 n@209@01)))
  :pattern ((Set_in n@209@01 g@180@01))
  :pattern ((inv@210@01 n@209@01))
  :pattern ((img@211@01 n@209@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@211@01 r) (Set_in (inv@210@01 r) g@180@01)) (= (inv@210@01 r) r))
  :pattern ((inv@210@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@210@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) r) r))
  :pattern ((inv@210@01 r))
  :qid |quant-u-142|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@212@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r) (= r (inv@210@01 r)))
    ($Perm.min
      (ite
        (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@212@01 r))
    $Perm.No)
  
  :qid |quant-u-144|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r) (= r (inv@210@01 r)))
    (= (- $Perm.Write (pTaken@212@01 r)) $Perm.No))
  
  :qid |quant-u-145|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@213@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))
      (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r)))
    (=>
      (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r))
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>))))
  :qid |qp.fvfDomDef108|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r))
      (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@213@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@213@01  $FVF<next>)) g@180@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@209@01 $Ref)) (!
  (=>
    (Set_in n@209@01 g@180@01)
    (and (= (inv@210@01 n@209@01) n@209@01) (img@211@01 n@209@01)))
  :pattern ((Set_in n@209@01 g@180@01))
  :pattern ((inv@210@01 n@209@01))
  :pattern ((img@211@01 n@209@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@211@01 r) (Set_in (inv@210@01 r) g@180@01)) (= (inv@210@01 r) r))
  :pattern ((inv@210@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))
      (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r)))
    (=>
      (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r))
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>))))
  :qid |qp.fvfDomDef108|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@210@01 r) g@180@01) (img@211@01 r))
      (and (img@206@01 r) (Set_in (inv@205@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@213@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r)))
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@202@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef107|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@210@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@207@01  $FVF<next>) r) r))
    :pattern ((inv@210@01 r))
    :qid |quant-u-142|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@213@01  $FVF<next>)) g@180@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@213@01  $FVF<next>)) g@180@01) u@181@01 v@183@01))
(pop) ; 2
(set-option :timeout 0)
(push) ; 2
; [exec]
; inhale apply_IND_2($$(g), Set(w), inst_uReach_rev($$(g), v))
(declare-const $t@214@01 $Snap)
(assert (= $t@214@01 $Snap.unit))
; [eval] apply_IND_2($$(g), Set(w), inst_uReach_rev($$(g), v))
; [eval] $$(g)
(push) ; 3
(declare-const n@215@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@215@01 g@180@01))
(pop) ; 4
(declare-fun inv@216@01 ($Ref) $Ref)
(declare-fun img@217@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@218@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@218@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@218@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@218@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef110|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@215@01 $Ref) (n2@215@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@215@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@218@01  $FVF<next>) n1@215@01) n1@215@01))
      (and
        (Set_in n2@215@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@218@01  $FVF<next>) n2@215@01) n2@215@01))
      (= n1@215@01 n2@215@01))
    (= n1@215@01 n2@215@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@215@01 $Ref)) (!
  (=>
    (Set_in n@215@01 g@180@01)
    (and (= (inv@216@01 n@215@01) n@215@01) (img@217@01 n@215@01)))
  :pattern ((Set_in n@215@01 g@180@01))
  :pattern ((inv@216@01 n@215@01))
  :pattern ((img@217@01 n@215@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@217@01 r) (Set_in (inv@216@01 r) g@180@01)) (= (inv@216@01 r) r))
  :pattern ((inv@216@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@216@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@218@01  $FVF<next>) r) r))
  :pattern ((inv@216@01 r))
  :qid |quant-u-147|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@219@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r) (= r (inv@216@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@219@01 r))
    $Perm.No)
  
  :qid |quant-u-149|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r) (= r (inv@216@01 r)))
    (= (- $Perm.Write (pTaken@219@01 r)) $Perm.No))
  
  :qid |quant-u-150|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@220@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@220@01  $FVF<next>)))
      (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r)))
    (=>
      (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r))
      (Set_in r ($FVF.domain_next (as sm@220@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@220@01  $FVF<next>))))
  :qid |qp.fvfDomDef113|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@220@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@220@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@220@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef112|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@220@01  $FVF<next>)) g@180@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@218@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@218@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@218@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef110|)))
(assert (forall ((n@215@01 $Ref)) (!
  (=>
    (Set_in n@215@01 g@180@01)
    (and (= (inv@216@01 n@215@01) n@215@01) (img@217@01 n@215@01)))
  :pattern ((Set_in n@215@01 g@180@01))
  :pattern ((inv@216@01 n@215@01))
  :pattern ((img@217@01 n@215@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@217@01 r) (Set_in (inv@216@01 r) g@180@01)) (= (inv@216@01 r) r))
  :pattern ((inv@216@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@220@01  $FVF<next>)))
      (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r)))
    (=>
      (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r))
      (Set_in r ($FVF.domain_next (as sm@220@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@220@01  $FVF<next>))))
  :qid |qp.fvfDomDef113|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@216@01 r) g@180@01) (img@217@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@220@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@220@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@220@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef112|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@216@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@218@01  $FVF<next>) r) r))
    :pattern ((inv@216@01 r))
    :qid |quant-u-147|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@220@01  $FVF<next>)) g@180@01)))
; [eval] Set(w)
; [eval] inst_uReach_rev($$(g), v)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 3
(declare-const n@221@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@221@01 g@180@01))
(pop) ; 4
(declare-fun inv@222@01 ($Ref) $Ref)
(declare-fun img@223@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@224@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef115|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@221@01 $Ref) (n2@221@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@221@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n1@221@01) n1@221@01))
      (and
        (Set_in n2@221@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n2@221@01) n2@221@01))
      (= n1@221@01 n2@221@01))
    (= n1@221@01 n2@221@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@221@01 $Ref)) (!
  (=>
    (Set_in n@221@01 g@180@01)
    (and (= (inv@222@01 n@221@01) n@221@01) (img@223@01 n@221@01)))
  :pattern ((Set_in n@221@01 g@180@01))
  :pattern ((inv@222@01 n@221@01))
  :pattern ((img@223@01 n@221@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@223@01 r) (Set_in (inv@222@01 r) g@180@01)) (= (inv@222@01 r) r))
  :pattern ((inv@222@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@222@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
  :pattern ((inv@222@01 r))
  :qid |quant-u-152|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@225@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r) (= r (inv@222@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@225@01 r))
    $Perm.No)
  
  :qid |quant-u-154|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r) (= r (inv@222@01 r)))
    (= (- $Perm.Write (pTaken@225@01 r)) $Perm.No))
  
  :qid |quant-u-155|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@226@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@226@01  $FVF<next>)))
      (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r)))
    (=>
      (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r))
      (Set_in r ($FVF.domain_next (as sm@226@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@226@01  $FVF<next>))))
  :qid |qp.fvfDomDef118|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@226@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@226@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef116|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@226@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef117|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@226@01  $FVF<next>)) g@180@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef115|)))
(assert (forall ((n@221@01 $Ref)) (!
  (=>
    (Set_in n@221@01 g@180@01)
    (and (= (inv@222@01 n@221@01) n@221@01) (img@223@01 n@221@01)))
  :pattern ((Set_in n@221@01 g@180@01))
  :pattern ((inv@222@01 n@221@01))
  :pattern ((img@223@01 n@221@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@223@01 r) (Set_in (inv@222@01 r) g@180@01)) (= (inv@222@01 r) r))
  :pattern ((inv@222@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@226@01  $FVF<next>)))
      (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r)))
    (=>
      (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r))
      (Set_in r ($FVF.domain_next (as sm@226@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@226@01  $FVF<next>))))
  :qid |qp.fvfDomDef118|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@222@01 r) g@180@01) (img@223@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@226@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@226@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef116|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@226@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef117|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@222@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
    :pattern ((inv@222@01 r))
    :qid |quant-u-152|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@226@01  $FVF<next>)) g@180@01)))
(assert (apply_IND_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@220@01  $FVF<next>)) g@180@01) (Set_singleton w@182@01) (inst_uReach_rev<Set<Ref>> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@226@01  $FVF<next>)) g@180@01) v@183@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale apply_IND($$(g), Set(u), inst_uReach_2($$(g), u))
(declare-const $t@227@01 $Snap)
(assert (= $t@227@01 $Snap.unit))
; [eval] apply_IND($$(g), Set(u), inst_uReach_2($$(g), u))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 3
(declare-const n@228@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@228@01 g@180@01))
(pop) ; 4
(declare-fun inv@229@01 ($Ref) $Ref)
(declare-fun img@230@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@231@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@231@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@231@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@231@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef120|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@228@01 $Ref) (n2@228@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@228@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@231@01  $FVF<next>) n1@228@01) n1@228@01))
      (and
        (Set_in n2@228@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@231@01  $FVF<next>) n2@228@01) n2@228@01))
      (= n1@228@01 n2@228@01))
    (= n1@228@01 n2@228@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@228@01 $Ref)) (!
  (=>
    (Set_in n@228@01 g@180@01)
    (and (= (inv@229@01 n@228@01) n@228@01) (img@230@01 n@228@01)))
  :pattern ((Set_in n@228@01 g@180@01))
  :pattern ((inv@229@01 n@228@01))
  :pattern ((img@230@01 n@228@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@230@01 r) (Set_in (inv@229@01 r) g@180@01)) (= (inv@229@01 r) r))
  :pattern ((inv@229@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@229@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@231@01  $FVF<next>) r) r))
  :pattern ((inv@229@01 r))
  :qid |quant-u-157|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@232@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r) (= r (inv@229@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@232@01 r))
    $Perm.No)
  
  :qid |quant-u-159|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r) (= r (inv@229@01 r)))
    (= (- $Perm.Write (pTaken@232@01 r)) $Perm.No))
  
  :qid |quant-u-160|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@233@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@233@01  $FVF<next>)))
      (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r)))
    (=>
      (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r))
      (Set_in r ($FVF.domain_next (as sm@233@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@233@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@233@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@233@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@233@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@233@01  $FVF<next>)) g@180@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@231@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@231@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@231@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef120|)))
(assert (forall ((n@228@01 $Ref)) (!
  (=>
    (Set_in n@228@01 g@180@01)
    (and (= (inv@229@01 n@228@01) n@228@01) (img@230@01 n@228@01)))
  :pattern ((Set_in n@228@01 g@180@01))
  :pattern ((inv@229@01 n@228@01))
  :pattern ((img@230@01 n@228@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@230@01 r) (Set_in (inv@229@01 r) g@180@01)) (= (inv@229@01 r) r))
  :pattern ((inv@229@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@233@01  $FVF<next>)))
      (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r)))
    (=>
      (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r))
      (Set_in r ($FVF.domain_next (as sm@233@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@233@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@229@01 r) g@180@01) (img@230@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@233@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@233@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@233@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@229@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@231@01  $FVF<next>) r) r))
    :pattern ((inv@229@01 r))
    :qid |quant-u-157|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@233@01  $FVF<next>)) g@180@01)))
; [eval] Set(u)
; [eval] inst_uReach_2($$(g), u)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 3
(declare-const n@234@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@234@01 g@180@01))
(pop) ; 4
(declare-fun inv@235@01 ($Ref) $Ref)
(declare-fun img@236@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@237@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@237@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef125|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@234@01 $Ref) (n2@234@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@234@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) n1@234@01) n1@234@01))
      (and
        (Set_in n2@234@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) n2@234@01) n2@234@01))
      (= n1@234@01 n2@234@01))
    (= n1@234@01 n2@234@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@234@01 $Ref)) (!
  (=>
    (Set_in n@234@01 g@180@01)
    (and (= (inv@235@01 n@234@01) n@234@01) (img@236@01 n@234@01)))
  :pattern ((Set_in n@234@01 g@180@01))
  :pattern ((inv@235@01 n@234@01))
  :pattern ((img@236@01 n@234@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@236@01 r) (Set_in (inv@235@01 r) g@180@01)) (= (inv@235@01 r) r))
  :pattern ((inv@235@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@235@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) r) r))
  :pattern ((inv@235@01 r))
  :qid |quant-u-162|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@238@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r) (= r (inv@235@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@238@01 r))
    $Perm.No)
  
  :qid |quant-u-164|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r) (= r (inv@235@01 r)))
    (= (- $Perm.Write (pTaken@238@01 r)) $Perm.No))
  
  :qid |quant-u-165|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@239@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))
      (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r)))
    (=>
      (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r))
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>))))
  :qid |qp.fvfDomDef128|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@239@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef127|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@239@01  $FVF<next>)) g@180@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@237@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef125|)))
(assert (forall ((n@234@01 $Ref)) (!
  (=>
    (Set_in n@234@01 g@180@01)
    (and (= (inv@235@01 n@234@01) n@234@01) (img@236@01 n@234@01)))
  :pattern ((Set_in n@234@01 g@180@01))
  :pattern ((inv@235@01 n@234@01))
  :pattern ((img@236@01 n@234@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@236@01 r) (Set_in (inv@235@01 r) g@180@01)) (= (inv@235@01 r) r))
  :pattern ((inv@235@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))
      (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r)))
    (=>
      (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r))
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>))))
  :qid |qp.fvfDomDef128|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@235@01 r) g@180@01) (img@236@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@239@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef127|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@235@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) r) r))
    :pattern ((inv@235@01 r))
    :qid |quant-u-162|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@239@01  $FVF<next>)) g@180@01)))
(assert (apply_IND<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@233@01  $FVF<next>)) g@180@01) (Set_singleton u@181@01) (inst_uReach_2<Set<Ref>> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@239@01  $FVF<next>)) g@180@01) u@181@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$1@240@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$1 in g)
(assert (Set_in n$1@240@01 g@180@01))
(declare-const sm@241@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@241@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@241@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@241@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef130|)))
(pop) ; 3
(declare-fun inv@242@01 ($Ref) $Ref)
(declare-fun img@243@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@241@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@241@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@241@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef130|)))
; Nested auxiliary terms: non-globals
(declare-const sm@244@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@244@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef132|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@240@01 $Ref) (n$12@240@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@240@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$11@240@01) n$11@240@01))
      (and
        (Set_in n$12@240@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$12@240@01) n$12@240@01))
      (= n$11@240@01 n$12@240@01))
    (= n$11@240@01 n$12@240@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@240@01 $Ref)) (!
  (=>
    (Set_in n$1@240@01 g@180@01)
    (and (= (inv@242@01 n$1@240@01) n$1@240@01) (img@243@01 n$1@240@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@241@01  $FVF<next>) n$1@240@01) n$1@240@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@243@01 r) (Set_in (inv@242@01 r) g@180@01)) (= (inv@242@01 r) r))
  :pattern ((inv@242@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@242@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) r) r))
  :pattern ((inv@242@01 r))
  :qid |quant-u-167|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@245@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@242@01 r) g@180@01) (img@243@01 r) (= r (inv@242@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@245@01 r))
    $Perm.No)
  
  :qid |quant-u-169|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@242@01 r) g@180@01) (img@243@01 r) (= r (inv@242@01 r)))
    (= (- $Perm.Write (pTaken@245@01 r)) $Perm.No))
  
  :qid |quant-u-170|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@246@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 28 | !(n$2@246@01 in g@180@01) | live]
; [else-branch: 28 | n$2@246@01 in g@180@01 | live]
(push) ; 5
; [then-branch: 28 | !(n$2@246@01 in g@180@01)]
(assert (not (Set_in n$2@246@01 g@180@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 28 | n$2@246@01 in g@180@01]
(assert (Set_in n$2@246@01 g@180@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
      (=
        ($FVF.lookup_next (as sm@244@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
    :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
    :qid |qp.fvfValDef131|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef132|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))
(push) ; 6
(assert (not (and (img@188@01 n$2@246@01) (Set_in (inv@187@01 n$2@246@01) g@180@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@244@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef132|)))
(assert (=>
  (Set_in n$2@246@01 g@180@01)
  (and
    (Set_in n$2@246@01 g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))))
(assert (or (Set_in n$2@246@01 g@180@01) (not (Set_in n$2@246@01 g@180@01))))
(push) ; 4
; [then-branch: 29 | n$2@246@01 in g@180@01 && Lookup(next, sm@244@01, n$2@246@01) != Null | live]
; [else-branch: 29 | !(n$2@246@01 in g@180@01 && Lookup(next, sm@244@01, n$2@246@01) != Null) | live]
(push) ; 5
; [then-branch: 29 | n$2@246@01 in g@180@01 && Lookup(next, sm@244@01, n$2@246@01) != Null]
(assert (and
  (Set_in n$2@246@01 g@180@01)
  (not (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
      (=
        ($FVF.lookup_next (as sm@244@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
    :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
    :qid |qp.fvfValDef131|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef132|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))
(push) ; 6
(assert (not (and (img@188@01 n$2@246@01) (Set_in (inv@187@01 n$2@246@01) g@180@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 29 | !(n$2@246@01 in g@180@01 && Lookup(next, sm@244@01, n$2@246@01) != Null)]
(assert (not
  (and
    (Set_in n$2@246@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@244@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef132|)))
(assert (=>
  (and
    (Set_in n$2@246@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))
  (and
    (Set_in n$2@246@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@246@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null))))
  (and
    (Set_in n$2@246@01 g@180@01)
    (not (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
    (=
      ($FVF.lookup_next (as sm@244@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@244@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef132|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@246@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@246@01 g@180@01)
      (and
        (Set_in n$2@246@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01)))
    (or (Set_in n$2@246@01 g@180@01) (not (Set_in n$2@246@01 g@180@01)))
    (=>
      (and
        (Set_in n$2@246@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))
      (and
        (Set_in n$2@246@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01)))
    (or
      (not
        (and
          (Set_in n$2@246@01 g@180@01)
          (not
            (=
              ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01)
              $Ref.null))))
      (and
        (Set_in n$2@246@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) g@180@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21-aux|)))
(assert (forall ((n$2@246@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@246@01 g@180@01)
      (and
        (Set_in n$2@246@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01)))
    (or (Set_in n$2@246@01 g@180@01) (not (Set_in n$2@246@01 g@180@01)))
    (=>
      (and
        (Set_in n$2@246@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))
      (and
        (Set_in n$2@246@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01)))
    (or
      (not
        (and
          (Set_in n$2@246@01 g@180@01)
          (not
            (=
              ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01)
              $Ref.null))))
      (and
        (Set_in n$2@246@01 g@180@01)
        (not
          (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))))
  :pattern ((Set_in n$2@246@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21-aux|)))
(push) ; 3
(assert (not (forall ((n$2@246@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@246@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) g@180@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) g@180@01))
  :pattern ((Set_in n$2@246@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@246@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@246@01 g@180@01)
      (not
        (= ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) g@180@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) g@180@01))
  :pattern ((Set_in n$2@246@01 g@180@01) ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n$2@246@01) n$2@246@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@325@13@325@21|)))
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 3
(declare-const n@247@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@247@01 g@180@01))
(pop) ; 4
(declare-fun inv@248@01 ($Ref) $Ref)
(declare-fun img@249@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@247@01 $Ref) (n2@247@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@247@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n1@247@01) n1@247@01))
      (and
        (Set_in n2@247@01 g@180@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) n2@247@01) n2@247@01))
      (= n1@247@01 n2@247@01))
    (= n1@247@01 n2@247@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@247@01 $Ref)) (!
  (=>
    (Set_in n@247@01 g@180@01)
    (and (= (inv@248@01 n@247@01) n@247@01) (img@249@01 n@247@01)))
  :pattern ((Set_in n@247@01 g@180@01))
  :pattern ((inv@248@01 n@247@01))
  :pattern ((img@249@01 n@247@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@249@01 r) (Set_in (inv@248@01 r) g@180@01)) (= (inv@248@01 r) r))
  :pattern ((inv@248@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@248@01 r) g@180@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) r) r))
  :pattern ((inv@248@01 r))
  :qid |quant-u-172|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@250@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r) (= r (inv@248@01 r)))
    ($Perm.min
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01))
        $Perm.Write
        $Perm.No)
      (pTaken@250@01 r))
    $Perm.No)
  
  :qid |quant-u-174|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r) (= r (inv@248@01 r)))
    (= (- $Perm.Write (pTaken@250@01 r)) $Perm.No))
  
  :qid |quant-u-175|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@251@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@251@01  $FVF<next>)))
      (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r)))
    (=>
      (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r))
      (Set_in r ($FVF.domain_next (as sm@251@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@251@01  $FVF<next>))))
  :qid |qp.fvfDomDef135|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@251@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@251@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@251@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef134|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@251@01  $FVF<next>)) g@180@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@247@01 $Ref)) (!
  (=>
    (Set_in n@247@01 g@180@01)
    (and (= (inv@248@01 n@247@01) n@247@01) (img@249@01 n@247@01)))
  :pattern ((Set_in n@247@01 g@180@01))
  :pattern ((inv@248@01 n@247@01))
  :pattern ((img@249@01 n@247@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@249@01 r) (Set_in (inv@248@01 r) g@180@01)) (= (inv@248@01 r) r))
  :pattern ((inv@248@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@251@01  $FVF<next>)))
      (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r)))
    (=>
      (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r))
      (Set_in r ($FVF.domain_next (as sm@251@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@251@01  $FVF<next>))))
  :qid |qp.fvfDomDef135|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@248@01 r) g@180@01) (img@249@01 r))
      (and (img@188@01 r) (Set_in (inv@187@01 r) g@180@01)))
    (=
      ($FVF.lookup_next (as sm@251@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r)))
  :pattern (($FVF.lookup_next (as sm@251@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@184@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@251@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef134|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@248@01 r) g@180@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@244@01  $FVF<next>) r) r))
    :pattern ((inv@248@01 r))
    :qid |quant-u-172|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@251@01  $FVF<next>)) g@180@01)))
(set-option :timeout 0)
(push) ; 3
(assert (not (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@251@01  $FVF<next>)) g@180@01) u@181@01 v@183@01)))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@251@01  $FVF<next>)) g@180@01) u@181@01 v@183@01))
(pop) ; 2
(pop) ; 1
; ---------- append ----------
(declare-const g@252@01 Set<$Ref>)
(declare-const x@253@01 $Ref)
(declare-const y@254@01 $Ref)
(declare-const res@255@01 $Ref)
(declare-const last@256@01 $Ref)
(declare-const g@257@01 Set<$Ref>)
(declare-const x@258@01 $Ref)
(declare-const y@259@01 $Ref)
(declare-const res@260@01 $Ref)
(declare-const last@261@01 $Ref)
(push) ; 1
(declare-const $t@262@01 $Snap)
(assert (= $t@262@01 ($Snap.combine ($Snap.first $t@262@01) ($Snap.second $t@262@01))))
(assert (= ($Snap.first $t@262@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@257@01)))
(assert (=
  ($Snap.second $t@262@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@262@01))
    ($Snap.second ($Snap.second $t@262@01)))))
(declare-const n@263@01 $Ref)
(push) ; 2
; [eval] (n in g)
(assert (Set_in n@263@01 g@257@01))
(declare-const sm@264@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@265@01 ($Ref) $Ref)
(declare-fun img@266@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@263@01 $Ref) (n2@263@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@263@01 g@257@01)
      (Set_in n2@263@01 g@257@01)
      (= n1@263@01 n2@263@01))
    (= n1@263@01 n2@263@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@263@01 $Ref)) (!
  (=>
    (Set_in n@263@01 g@257@01)
    (and (= (inv@265@01 n@263@01) n@263@01) (img@266@01 n@263@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) n@263@01) n@263@01))
  :qid |quant-u-177|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)) (= (inv@265@01 r) r))
  :pattern ((inv@265@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@263@01 $Ref)) (!
  (=> (Set_in n@263@01 g@257@01) (not (= n@263@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) n@263@01) n@263@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@267@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@267@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef138|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@265@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
  :pattern ((inv@265@01 r))
  :qid |quant-u-178|)))
(assert (=
  ($Snap.second ($Snap.second $t@262@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@262@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@262@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@268@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 30 | !(n$0@268@01 in g@257@01) | live]
; [else-branch: 30 | n$0@268@01 in g@257@01 | live]
(push) ; 4
; [then-branch: 30 | !(n$0@268@01 in g@257@01)]
(assert (not (Set_in n$0@268@01 g@257@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 30 | n$0@268@01 in g@257@01]
(assert (Set_in n$0@268@01 g@257@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@267@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
    :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
    :qid |qp.fvfValDef137|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef138|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01))
(push) ; 5
(assert (not (and (img@266@01 n$0@268@01) (Set_in (inv@265@01 n$0@268@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@267@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef138|)))
(assert (=>
  (Set_in n$0@268@01 g@257@01)
  (and
    (Set_in n$0@268@01 g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01))))
(assert (or (Set_in n$0@268@01 g@257@01) (not (Set_in n$0@268@01 g@257@01))))
(push) ; 3
; [then-branch: 31 | n$0@268@01 in g@257@01 && Lookup(next, sm@267@01, n$0@268@01) != Null | live]
; [else-branch: 31 | !(n$0@268@01 in g@257@01 && Lookup(next, sm@267@01, n$0@268@01) != Null) | live]
(push) ; 4
; [then-branch: 31 | n$0@268@01 in g@257@01 && Lookup(next, sm@267@01, n$0@268@01) != Null]
(assert (and
  (Set_in n$0@268@01 g@257@01)
  (not (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@267@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
    :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
    :qid |qp.fvfValDef137|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef138|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01))
(push) ; 5
(assert (not (and (img@266@01 n$0@268@01) (Set_in (inv@265@01 n$0@268@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 31 | !(n$0@268@01 in g@257@01 && Lookup(next, sm@267@01, n$0@268@01) != Null)]
(assert (not
  (and
    (Set_in n$0@268@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@267@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef138|)))
(assert (=>
  (and
    (Set_in n$0@268@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))
  (and
    (Set_in n$0@268@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@268@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null))))
  (and
    (Set_in n$0@268@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@267@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@267@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef138|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@268@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@268@01 g@257@01)
      (and
        (Set_in n$0@268@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01)))
    (or (Set_in n$0@268@01 g@257@01) (not (Set_in n$0@268@01 g@257@01)))
    (=>
      (and
        (Set_in n$0@268@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))
      (and
        (Set_in n$0@268@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01)))
    (or
      (not
        (and
          (Set_in n$0@268@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01)
              $Ref.null))))
      (and
        (Set_in n$0@268@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@340@14@340@22-aux|)))
(assert (forall ((n$0@268@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@268@01 g@257@01)
      (and
        (Set_in n$0@268@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01)))
    (or (Set_in n$0@268@01 g@257@01) (not (Set_in n$0@268@01 g@257@01)))
    (=>
      (and
        (Set_in n$0@268@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))
      (and
        (Set_in n$0@268@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01)))
    (or
      (not
        (and
          (Set_in n$0@268@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01)
              $Ref.null))))
      (and
        (Set_in n$0@268@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))))
  :pattern ((Set_in n$0@268@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@340@14@340@22-aux|)))
(assert (forall ((n$0@268@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@268@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) g@257@01))
  :pattern ((Set_in n$0@268@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n$0@268@01) n$0@268@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@340@14@340@22|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@262@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@262@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@262@01))))
  $Snap.unit))
; [eval] (x in g)
(assert (Set_in x@258@01 g@257@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))
  $Snap.unit))
; [eval] (y in g)
(assert (Set_in y@259@01 g@257@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))
  $Snap.unit))
; [eval] x != y
(assert (not (= x@258@01 y@259@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))
  $Snap.unit))
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n))
(declare-const n@269@01 $Ref)
(push) ; 2
; [eval] (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 3
; [then-branch: 32 | n@269@01 in g@257@01 | live]
; [else-branch: 32 | !(n@269@01 in g@257@01) | live]
(push) ; 4
; [then-branch: 32 | n@269@01 in g@257@01]
(assert (Set_in n@269@01 g@257@01))
; [eval] exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 5
(declare-const n@270@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@270@01 g@257@01))
(pop) ; 6
(declare-fun inv@271@01 ($Ref) $Ref)
(declare-fun img@272@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@270@01 $Ref) (n2@270@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@270@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n1@270@01) n1@270@01))
      (and
        (Set_in n2@270@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n2@270@01) n2@270@01))
      (= n1@270@01 n2@270@01))
    (= n1@270@01 n2@270@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@270@01 $Ref)) (!
  (=>
    (Set_in n@270@01 g@257@01)
    (and (= (inv@271@01 n@270@01) n@270@01) (img@272@01 n@270@01)))
  :pattern ((Set_in n@270@01 g@257@01))
  :pattern ((inv@271@01 n@270@01))
  :pattern ((img@272@01 n@270@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@272@01 r) (Set_in (inv@271@01 r) g@257@01)) (= (inv@271@01 r) r))
  :pattern ((inv@271@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@271@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
  :pattern ((inv@271@01 r))
  :qid |quant-u-180|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@273@01 ((r $Ref) (n@269@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r) (= r (inv@271@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@273@01 r n@269@01))
    $Perm.No)
  
  :qid |quant-u-182|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r) (= r (inv@271@01 r)))
    (= (- $Perm.Write (pTaken@273@01 r n@269@01)) $Perm.No))
  
  :qid |quant-u-183|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@274@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r)))
    (=>
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>))))
  :qid |qp.fvfDomDef141|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@274@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef139|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef140|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@270@01 $Ref)) (!
  (=>
    (Set_in n@270@01 g@257@01)
    (and (= (inv@271@01 n@270@01) n@270@01) (img@272@01 n@270@01)))
  :pattern ((Set_in n@270@01 g@257@01))
  :pattern ((inv@271@01 n@270@01))
  :pattern ((img@272@01 n@270@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@272@01 r) (Set_in (inv@271@01 r) g@257@01)) (= (inv@271@01 r) r))
  :pattern ((inv@271@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r)))
    (=>
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>))))
  :qid |qp.fvfDomDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@274@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef139|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef140|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@271@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
    :pattern ((inv@271@01 r))
    :qid |quant-u-180|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 5
; [then-branch: 33 | exists_path[Bool]($$(sm@274@01, g@257@01), x@258@01, n@269@01) | live]
; [else-branch: 33 | !(exists_path[Bool]($$(sm@274@01, g@257@01), x@258@01, n@269@01)) | live]
(push) ; 6
; [then-branch: 33 | exists_path[Bool]($$(sm@274@01, g@257@01), x@258@01, n@269@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
(pop) ; 6
(push) ; 6
; [else-branch: 33 | !(exists_path[Bool]($$(sm@274@01, g@257@01), x@258@01, n@269@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01)))
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 7
(declare-const n@275@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@275@01 g@257@01))
(pop) ; 8
(declare-fun inv@276@01 ($Ref) $Ref)
(declare-fun img@277@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@278@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@275@01 $Ref) (n2@275@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@275@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) n1@275@01) n1@275@01))
      (and
        (Set_in n2@275@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) n2@275@01) n2@275@01))
      (= n1@275@01 n2@275@01))
    (= n1@275@01 n2@275@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@275@01 $Ref)) (!
  (=>
    (Set_in n@275@01 g@257@01)
    (and (= (inv@276@01 n@275@01) n@275@01) (img@277@01 n@275@01)))
  :pattern ((Set_in n@275@01 g@257@01))
  :pattern ((inv@276@01 n@275@01))
  :pattern ((img@277@01 n@275@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@277@01 r) (Set_in (inv@276@01 r) g@257@01)) (= (inv@276@01 r) r))
  :pattern ((inv@276@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@276@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
  :pattern ((inv@276@01 r))
  :qid |quant-u-185|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@279@01 ((r $Ref) (n@269@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r) (= r (inv@276@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@279@01 r n@269@01))
    $Perm.No)
  
  :qid |quant-u-187|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r) (= r (inv@276@01 r)))
    (= (- $Perm.Write (pTaken@279@01 r n@269@01)) $Perm.No))
  
  :qid |quant-u-188|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@280@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r)))
    (=>
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>))))
  :qid |qp.fvfDomDef146|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@280@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
(assert (forall ((n@275@01 $Ref)) (!
  (=>
    (Set_in n@275@01 g@257@01)
    (and (= (inv@276@01 n@275@01) n@275@01) (img@277@01 n@275@01)))
  :pattern ((Set_in n@275@01 g@257@01))
  :pattern ((inv@276@01 n@275@01))
  :pattern ((img@277@01 n@275@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@277@01 r) (Set_in (inv@276@01 r) g@257@01)) (= (inv@276@01 r) r))
  :pattern ((inv@276@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r)))
    (=>
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>))))
  :qid |qp.fvfDomDef146|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@280@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@276@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
    :pattern ((inv@276@01 r))
    :qid |quant-u-185|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
(assert (forall ((n@275@01 $Ref)) (!
  (=>
    (Set_in n@275@01 g@257@01)
    (and (= (inv@276@01 n@275@01) n@275@01) (img@277@01 n@275@01)))
  :pattern ((Set_in n@275@01 g@257@01))
  :pattern ((inv@276@01 n@275@01))
  :pattern ((img@277@01 n@275@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@277@01 r) (Set_in (inv@276@01 r) g@257@01)) (= (inv@276@01 r) r))
  :pattern ((inv@276@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r)))
    (=>
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>))))
  :qid |qp.fvfDomDef146|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@280@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@276@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
      :pattern ((inv@276@01 r))
      :qid |quant-u-185|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 32 | !(n@269@01 in g@257@01)]
(assert (not (Set_in n@269@01 g@257@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@270@01 $Ref)) (!
  (=>
    (Set_in n@270@01 g@257@01)
    (and (= (inv@271@01 n@270@01) n@270@01) (img@272@01 n@270@01)))
  :pattern ((Set_in n@270@01 g@257@01))
  :pattern ((inv@271@01 n@270@01))
  :pattern ((img@272@01 n@270@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@272@01 r) (Set_in (inv@271@01 r) g@257@01)) (= (inv@271@01 r) r))
  :pattern ((inv@271@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r)))
    (=>
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>))))
  :qid |qp.fvfDomDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@274@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef139|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
(assert (forall ((n@275@01 $Ref)) (!
  (=>
    (Set_in n@275@01 g@257@01)
    (and (= (inv@276@01 n@275@01) n@275@01) (img@277@01 n@275@01)))
  :pattern ((Set_in n@275@01 g@257@01))
  :pattern ((inv@276@01 n@275@01))
  :pattern ((img@277@01 n@275@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@277@01 r) (Set_in (inv@276@01 r) g@257@01)) (= (inv@276@01 r) r))
  :pattern ((inv@276@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r)))
    (=>
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>))))
  :qid |qp.fvfDomDef146|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@280@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert (=>
  (Set_in n@269@01 g@257@01)
  (and
    (Set_in n@269@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@271@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
      :pattern ((inv@271@01 r))
      :qid |quant-u-180|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01)
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@276@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
          :pattern ((inv@276@01 r))
          :qid |quant-u-185|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01)))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01)))))
; Joined path conditions
(assert (or (not (Set_in n@269@01 g@257@01)) (Set_in n@269@01 g@257@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@270@01 $Ref)) (!
  (=>
    (Set_in n@270@01 g@257@01)
    (and (= (inv@271@01 n@270@01) n@270@01) (img@272@01 n@270@01)))
  :pattern ((Set_in n@270@01 g@257@01))
  :pattern ((inv@271@01 n@270@01))
  :pattern ((img@272@01 n@270@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@272@01 r) (Set_in (inv@271@01 r) g@257@01)) (= (inv@271@01 r) r))
  :pattern ((inv@271@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r)))
    (=>
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@274@01  $FVF<next>))))
  :qid |qp.fvfDomDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@271@01 r) g@257@01) (img@272@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@274@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef139|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@274@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
(assert (forall ((n@275@01 $Ref)) (!
  (=>
    (Set_in n@275@01 g@257@01)
    (and (= (inv@276@01 n@275@01) n@275@01) (img@277@01 n@275@01)))
  :pattern ((Set_in n@275@01 g@257@01))
  :pattern ((inv@276@01 n@275@01))
  :pattern ((img@277@01 n@275@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@277@01 r) (Set_in (inv@276@01 r) g@257@01)) (= (inv@276@01 r) r))
  :pattern ((inv@276@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r)))
    (=>
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@280@01  $FVF<next>))))
  :qid |qp.fvfDomDef146|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@276@01 r) g@257@01) (img@277@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@280@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@280@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@269@01 $Ref)) (!
  (and
    (=>
      (Set_in n@269@01 g@257@01)
      (and
        (Set_in n@269@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@271@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
          :pattern ((inv@271@01 r))
          :qid |quant-u-180|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@276@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
              :pattern ((inv@276@01 r))
              :qid |quant-u-185|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))))
    (or (not (Set_in n@269@01 g@257@01)) (Set_in n@269@01 g@257@01)))
  :pattern ((Set_in n@269@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@343@14@343@93-aux|)))
(assert (forall ((n@269@01 $Ref)) (!
  (and
    (=>
      (Set_in n@269@01 g@257@01)
      (and
        (Set_in n@269@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@271@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
          :pattern ((inv@271@01 r))
          :qid |quant-u-180|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@276@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
              :pattern ((inv@276@01 r))
              :qid |quant-u-185|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))))
    (or (not (Set_in n@269@01 g@257@01)) (Set_in n@269@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@343@14@343@93-aux|)))
(assert (forall ((n@269@01 $Ref)) (!
  (and
    (=>
      (Set_in n@269@01 g@257@01)
      (and
        (Set_in n@269@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@271@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
          :pattern ((inv@271@01 r))
          :qid |quant-u-180|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@276@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@278@01  $FVF<next>) r) r))
              :pattern ((inv@276@01 r))
              :qid |quant-u-185|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))))
    (or (not (Set_in n@269@01 g@257@01)) (Set_in n@269@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01) y@259@01 n@269@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@343@14@343@93-aux|)))
(assert (forall ((n@269@01 $Ref)) (!
  (=>
    (Set_in n@269@01 g@257@01)
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01) y@259@01 n@269@01)))
  :pattern ((Set_in n@269@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@274@01  $FVF<next>)) g@257@01) x@258@01 n@269@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@280@01  $FVF<next>)) g@257@01) y@259@01 n@269@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@343@14@343@93|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))
  $Snap.unit))
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n))
(declare-const n@281@01 $Ref)
(push) ; 2
; [eval] (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 3
; [then-branch: 34 | n@281@01 in g@257@01 | live]
; [else-branch: 34 | !(n@281@01 in g@257@01) | live]
(push) ; 4
; [then-branch: 34 | n@281@01 in g@257@01]
(assert (Set_in n@281@01 g@257@01))
; [eval] !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] !exists_path($$(g), x, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 5
(declare-const n@282@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@282@01 g@257@01))
(pop) ; 6
(declare-fun inv@283@01 ($Ref) $Ref)
(declare-fun img@284@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@282@01 $Ref) (n2@282@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@282@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n1@282@01) n1@282@01))
      (and
        (Set_in n2@282@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n2@282@01) n2@282@01))
      (= n1@282@01 n2@282@01))
    (= n1@282@01 n2@282@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@282@01 $Ref)) (!
  (=>
    (Set_in n@282@01 g@257@01)
    (and (= (inv@283@01 n@282@01) n@282@01) (img@284@01 n@282@01)))
  :pattern ((Set_in n@282@01 g@257@01))
  :pattern ((inv@283@01 n@282@01))
  :pattern ((img@284@01 n@282@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@284@01 r) (Set_in (inv@283@01 r) g@257@01)) (= (inv@283@01 r) r))
  :pattern ((inv@283@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@283@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
  :pattern ((inv@283@01 r))
  :qid |quant-u-190|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@285@01 ((r $Ref) (n@281@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r) (= r (inv@283@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@285@01 r n@281@01))
    $Perm.No)
  
  :qid |quant-u-192|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r) (= r (inv@283@01 r)))
    (= (- $Perm.Write (pTaken@285@01 r n@281@01)) $Perm.No))
  
  :qid |quant-u-193|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@286@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r)))
    (=>
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>))))
  :qid |qp.fvfDomDef149|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@286@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef147|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef148|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@282@01 $Ref)) (!
  (=>
    (Set_in n@282@01 g@257@01)
    (and (= (inv@283@01 n@282@01) n@282@01) (img@284@01 n@282@01)))
  :pattern ((Set_in n@282@01 g@257@01))
  :pattern ((inv@283@01 n@282@01))
  :pattern ((img@284@01 n@282@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@284@01 r) (Set_in (inv@283@01 r) g@257@01)) (= (inv@283@01 r) r))
  :pattern ((inv@283@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r)))
    (=>
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>))))
  :qid |qp.fvfDomDef149|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@286@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef147|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef148|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@283@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
    :pattern ((inv@283@01 r))
    :qid |quant-u-190|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 5
; [then-branch: 35 | !(exists_path[Bool]($$(sm@286@01, g@257@01), x@258@01, n@281@01)) | live]
; [else-branch: 35 | exists_path[Bool]($$(sm@286@01, g@257@01), x@258@01, n@281@01) | live]
(push) ; 6
; [then-branch: 35 | !(exists_path[Bool]($$(sm@286@01, g@257@01), x@258@01, n@281@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 35 | exists_path[Bool]($$(sm@286@01, g@257@01), x@258@01, n@281@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01))
; [eval] !exists_path($$(g), y, n)
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 7
(declare-const n@287@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@287@01 g@257@01))
(pop) ; 8
(declare-fun inv@288@01 ($Ref) $Ref)
(declare-fun img@289@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@290@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@290@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef150|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef151|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@287@01 $Ref) (n2@287@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@287@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) n1@287@01) n1@287@01))
      (and
        (Set_in n2@287@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) n2@287@01) n2@287@01))
      (= n1@287@01 n2@287@01))
    (= n1@287@01 n2@287@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@287@01 $Ref)) (!
  (=>
    (Set_in n@287@01 g@257@01)
    (and (= (inv@288@01 n@287@01) n@287@01) (img@289@01 n@287@01)))
  :pattern ((Set_in n@287@01 g@257@01))
  :pattern ((inv@288@01 n@287@01))
  :pattern ((img@289@01 n@287@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@289@01 r) (Set_in (inv@288@01 r) g@257@01)) (= (inv@288@01 r) r))
  :pattern ((inv@288@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@288@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
  :pattern ((inv@288@01 r))
  :qid |quant-u-195|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@291@01 ((r $Ref) (n@281@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r) (= r (inv@288@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@291@01 r n@281@01))
    $Perm.No)
  
  :qid |quant-u-197|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r) (= r (inv@288@01 r)))
    (= (- $Perm.Write (pTaken@291@01 r n@281@01)) $Perm.No))
  
  :qid |quant-u-198|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@292@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r)))
    (=>
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>))))
  :qid |qp.fvfDomDef154|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@292@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef153|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@290@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef150|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef151|)))
(assert (forall ((n@287@01 $Ref)) (!
  (=>
    (Set_in n@287@01 g@257@01)
    (and (= (inv@288@01 n@287@01) n@287@01) (img@289@01 n@287@01)))
  :pattern ((Set_in n@287@01 g@257@01))
  :pattern ((inv@288@01 n@287@01))
  :pattern ((img@289@01 n@287@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@289@01 r) (Set_in (inv@288@01 r) g@257@01)) (= (inv@288@01 r) r))
  :pattern ((inv@288@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r)))
    (=>
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>))))
  :qid |qp.fvfDomDef154|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@292@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef153|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@288@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
    :pattern ((inv@288@01 r))
    :qid |quant-u-195|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@290@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef150|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef151|)))
(assert (forall ((n@287@01 $Ref)) (!
  (=>
    (Set_in n@287@01 g@257@01)
    (and (= (inv@288@01 n@287@01) n@287@01) (img@289@01 n@287@01)))
  :pattern ((Set_in n@287@01 g@257@01))
  :pattern ((inv@288@01 n@287@01))
  :pattern ((img@289@01 n@287@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@289@01 r) (Set_in (inv@288@01 r) g@257@01)) (= (inv@288@01 r) r))
  :pattern ((inv@288@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r)))
    (=>
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>))))
  :qid |qp.fvfDomDef154|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@292@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef153|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@288@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
      :pattern ((inv@288@01 r))
      :qid |quant-u-195|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01))))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 34 | !(n@281@01 in g@257@01)]
(assert (not (Set_in n@281@01 g@257@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@282@01 $Ref)) (!
  (=>
    (Set_in n@282@01 g@257@01)
    (and (= (inv@283@01 n@282@01) n@282@01) (img@284@01 n@282@01)))
  :pattern ((Set_in n@282@01 g@257@01))
  :pattern ((inv@283@01 n@282@01))
  :pattern ((img@284@01 n@282@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@284@01 r) (Set_in (inv@283@01 r) g@257@01)) (= (inv@283@01 r) r))
  :pattern ((inv@283@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r)))
    (=>
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>))))
  :qid |qp.fvfDomDef149|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@286@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef147|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef148|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@290@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef150|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef151|)))
(assert (forall ((n@287@01 $Ref)) (!
  (=>
    (Set_in n@287@01 g@257@01)
    (and (= (inv@288@01 n@287@01) n@287@01) (img@289@01 n@287@01)))
  :pattern ((Set_in n@287@01 g@257@01))
  :pattern ((inv@288@01 n@287@01))
  :pattern ((img@289@01 n@287@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@289@01 r) (Set_in (inv@288@01 r) g@257@01)) (= (inv@288@01 r) r))
  :pattern ((inv@288@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r)))
    (=>
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>))))
  :qid |qp.fvfDomDef154|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@292@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef153|)))
(assert (=>
  (Set_in n@281@01 g@257@01)
  (and
    (Set_in n@281@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@283@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
      :pattern ((inv@283@01 r))
      :qid |quant-u-190|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@288@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
          :pattern ((inv@288@01 r))
          :qid |quant-u-195|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01))))))
; Joined path conditions
(assert (or (not (Set_in n@281@01 g@257@01)) (Set_in n@281@01 g@257@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@282@01 $Ref)) (!
  (=>
    (Set_in n@282@01 g@257@01)
    (and (= (inv@283@01 n@282@01) n@282@01) (img@284@01 n@282@01)))
  :pattern ((Set_in n@282@01 g@257@01))
  :pattern ((inv@283@01 n@282@01))
  :pattern ((img@284@01 n@282@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@284@01 r) (Set_in (inv@283@01 r) g@257@01)) (= (inv@283@01 r) r))
  :pattern ((inv@283@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r)))
    (=>
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@286@01  $FVF<next>))))
  :qid |qp.fvfDomDef149|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@283@01 r) g@257@01) (img@284@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@286@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef147|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@286@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef148|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@290@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef150|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@290@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef151|)))
(assert (forall ((n@287@01 $Ref)) (!
  (=>
    (Set_in n@287@01 g@257@01)
    (and (= (inv@288@01 n@287@01) n@287@01) (img@289@01 n@287@01)))
  :pattern ((Set_in n@287@01 g@257@01))
  :pattern ((inv@288@01 n@287@01))
  :pattern ((img@289@01 n@287@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@289@01 r) (Set_in (inv@288@01 r) g@257@01)) (= (inv@288@01 r) r))
  :pattern ((inv@288@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r)))
    (=>
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@292@01  $FVF<next>))))
  :qid |qp.fvfDomDef154|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@288@01 r) g@257@01) (img@289@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@292@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@292@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef153|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@281@01 $Ref)) (!
  (and
    (=>
      (Set_in n@281@01 g@257@01)
      (and
        (Set_in n@281@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@283@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
          :pattern ((inv@283@01 r))
          :qid |quant-u-190|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@288@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
              :pattern ((inv@288@01 r))
              :qid |quant-u-195|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)))))
    (or (not (Set_in n@281@01 g@257@01)) (Set_in n@281@01 g@257@01)))
  :pattern ((Set_in n@281@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@344@14@344@93-aux|)))
(assert (forall ((n@281@01 $Ref)) (!
  (and
    (=>
      (Set_in n@281@01 g@257@01)
      (and
        (Set_in n@281@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@283@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
          :pattern ((inv@283@01 r))
          :qid |quant-u-190|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@288@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
              :pattern ((inv@288@01 r))
              :qid |quant-u-195|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)))))
    (or (not (Set_in n@281@01 g@257@01)) (Set_in n@281@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@344@14@344@93-aux|)))
(assert (forall ((n@281@01 $Ref)) (!
  (and
    (=>
      (Set_in n@281@01 g@257@01)
      (and
        (Set_in n@281@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@283@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
          :pattern ((inv@283@01 r))
          :qid |quant-u-190|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@288@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@290@01  $FVF<next>) r) r))
              :pattern ((inv@288@01 r))
              :qid |quant-u-195|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01)))))
    (or (not (Set_in n@281@01 g@257@01)) (Set_in n@281@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01) y@259@01 n@281@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@344@14@344@93-aux|)))
(assert (forall ((n@281@01 $Ref)) (!
  (=>
    (Set_in n@281@01 g@257@01)
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01) y@259@01 n@281@01))))
  :pattern ((Set_in n@281@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@286@01  $FVF<next>)) g@257@01) x@258@01 n@281@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@292@01  $FVF<next>)) g@257@01) y@259@01 n@281@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@344@14@344@93|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))))
  $Snap.unit))
; [eval] acyclic_graph($$(g))
; [eval] $$(g)
(push) ; 2
(declare-const n@293@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@293@01 g@257@01))
(pop) ; 3
(declare-fun inv@294@01 ($Ref) $Ref)
(declare-fun img@295@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@293@01 $Ref) (n2@293@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@293@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n1@293@01) n1@293@01))
      (and
        (Set_in n2@293@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) n2@293@01) n2@293@01))
      (= n1@293@01 n2@293@01))
    (= n1@293@01 n2@293@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@293@01 $Ref)) (!
  (=>
    (Set_in n@293@01 g@257@01)
    (and (= (inv@294@01 n@293@01) n@293@01) (img@295@01 n@293@01)))
  :pattern ((Set_in n@293@01 g@257@01))
  :pattern ((inv@294@01 n@293@01))
  :pattern ((img@295@01 n@293@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@295@01 r) (Set_in (inv@294@01 r) g@257@01)) (= (inv@294@01 r) r))
  :pattern ((inv@294@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@294@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
  :pattern ((inv@294@01 r))
  :qid |quant-u-200|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@296@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r) (= r (inv@294@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@296@01 r))
    $Perm.No)
  
  :qid |quant-u-202|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r) (= r (inv@294@01 r)))
    (= (- $Perm.Write (pTaken@296@01 r)) $Perm.No))
  
  :qid |quant-u-203|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@297@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r)))
    (=>
      (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef157|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef155|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef156|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) g@257@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@293@01 $Ref)) (!
  (=>
    (Set_in n@293@01 g@257@01)
    (and (= (inv@294@01 n@293@01) n@293@01) (img@295@01 n@293@01)))
  :pattern ((Set_in n@293@01 g@257@01))
  :pattern ((inv@294@01 n@293@01))
  :pattern ((img@295@01 n@293@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@295@01 r) (Set_in (inv@294@01 r) g@257@01)) (= (inv@294@01 r) r))
  :pattern ((inv@294@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r)))
    (=>
      (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef157|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@294@01 r) g@257@01) (img@295@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef155|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef156|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@294@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@267@01  $FVF<next>) r) r))
    :pattern ((inv@294@01 r))
    :qid |quant-u-200|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) g@257@01)))
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) g@257@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))))
  $Snap.unit))
; [eval] func_graph($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 2
(declare-const n@298@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@298@01 g@257@01))
(pop) ; 3
(declare-fun inv@299@01 ($Ref) $Ref)
(declare-fun img@300@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@301@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef159|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@298@01 $Ref) (n2@298@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@298@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) n1@298@01) n1@298@01))
      (and
        (Set_in n2@298@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) n2@298@01) n2@298@01))
      (= n1@298@01 n2@298@01))
    (= n1@298@01 n2@298@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 g@257@01)
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 g@257@01))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@300@01 r) (Set_in (inv@299@01 r) g@257@01)) (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@299@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
  :pattern ((inv@299@01 r))
  :qid |quant-u-205|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@302@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r) (= r (inv@299@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@302@01 r))
    $Perm.No)
  
  :qid |quant-u-207|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r) (= r (inv@299@01 r)))
    (= (- $Perm.Write (pTaken@302@01 r)) $Perm.No))
  
  :qid |quant-u-208|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@303@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r)))
    (=>
      (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef162|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef161|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) g@257@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef159|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 g@257@01)
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 g@257@01))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@300@01 r) (Set_in (inv@299@01 r) g@257@01)) (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r)))
    (=>
      (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@299@01 r) g@257@01) (img@300@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef161|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@299@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
    :pattern ((inv@299@01 r))
    :qid |quant-u-205|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) g@257@01)))
(assert (func_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) g@257@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@262@01))))))))))
  $Snap.unit))
; [eval] unshared_graph($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 2
(declare-const n@304@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@304@01 g@257@01))
(pop) ; 3
(declare-fun inv@305@01 ($Ref) $Ref)
(declare-fun img@306@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@307@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@307@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@307@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@307@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@304@01 $Ref) (n2@304@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@304@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@307@01  $FVF<next>) n1@304@01) n1@304@01))
      (and
        (Set_in n2@304@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@307@01  $FVF<next>) n2@304@01) n2@304@01))
      (= n1@304@01 n2@304@01))
    (= n1@304@01 n2@304@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@304@01 $Ref)) (!
  (=>
    (Set_in n@304@01 g@257@01)
    (and (= (inv@305@01 n@304@01) n@304@01) (img@306@01 n@304@01)))
  :pattern ((Set_in n@304@01 g@257@01))
  :pattern ((inv@305@01 n@304@01))
  :pattern ((img@306@01 n@304@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@306@01 r) (Set_in (inv@305@01 r) g@257@01)) (= (inv@305@01 r) r))
  :pattern ((inv@305@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@305@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@307@01  $FVF<next>) r) r))
  :pattern ((inv@305@01 r))
  :qid |quant-u-210|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@308@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r) (= r (inv@305@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@308@01 r))
    $Perm.No)
  
  :qid |quant-u-212|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r) (= r (inv@305@01 r)))
    (= (- $Perm.Write (pTaken@308@01 r)) $Perm.No))
  
  :qid |quant-u-213|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@309@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@309@01  $FVF<next>)))
      (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r)))
    (=>
      (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r))
      (Set_in r ($FVF.domain_next (as sm@309@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@309@01  $FVF<next>))))
  :qid |qp.fvfDomDef167|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@309@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@309@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@309@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef166|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@309@01  $FVF<next>)) g@257@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@307@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@307@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@307@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
(assert (forall ((n@304@01 $Ref)) (!
  (=>
    (Set_in n@304@01 g@257@01)
    (and (= (inv@305@01 n@304@01) n@304@01) (img@306@01 n@304@01)))
  :pattern ((Set_in n@304@01 g@257@01))
  :pattern ((inv@305@01 n@304@01))
  :pattern ((img@306@01 n@304@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@306@01 r) (Set_in (inv@305@01 r) g@257@01)) (= (inv@305@01 r) r))
  :pattern ((inv@305@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@309@01  $FVF<next>)))
      (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r)))
    (=>
      (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r))
      (Set_in r ($FVF.domain_next (as sm@309@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@309@01  $FVF<next>))))
  :qid |qp.fvfDomDef167|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@305@01 r) g@257@01) (img@306@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@309@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@309@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@309@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef166|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@305@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@307@01  $FVF<next>) r) r))
    :pattern ((inv@305@01 r))
    :qid |quant-u-210|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@309@01  $FVF<next>)) g@257@01)))
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@309@01  $FVF<next>)) g@257@01)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var old_g: Set[Edge]
(declare-const old_g@310@01 Set<Edge>)
; [exec]
; old_g := $$(g)
; [eval] $$(g)
(push) ; 3
(declare-const n@311@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@311@01 g@257@01))
(pop) ; 4
(declare-fun inv@312@01 ($Ref) $Ref)
(declare-fun img@313@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@314@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef168|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef169|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@311@01 $Ref) (n2@311@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@311@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n1@311@01) n1@311@01))
      (and
        (Set_in n2@311@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n2@311@01) n2@311@01))
      (= n1@311@01 n2@311@01))
    (= n1@311@01 n2@311@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@311@01 $Ref)) (!
  (=>
    (Set_in n@311@01 g@257@01)
    (and (= (inv@312@01 n@311@01) n@311@01) (img@313@01 n@311@01)))
  :pattern ((Set_in n@311@01 g@257@01))
  :pattern ((inv@312@01 n@311@01))
  :pattern ((img@313@01 n@311@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@313@01 r) (Set_in (inv@312@01 r) g@257@01)) (= (inv@312@01 r) r))
  :pattern ((inv@312@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@312@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) r) r))
  :pattern ((inv@312@01 r))
  :qid |quant-u-215|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@315@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r) (= r (inv@312@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@315@01 r))
    $Perm.No)
  
  :qid |quant-u-217|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r) (= r (inv@312@01 r)))
    (= (- $Perm.Write (pTaken@315@01 r)) $Perm.No))
  
  :qid |quant-u-218|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@316@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@316@01  $FVF<next>)))
      (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r)))
    (=>
      (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r))
      (Set_in r ($FVF.domain_next (as sm@316@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@316@01  $FVF<next>))))
  :qid |qp.fvfDomDef172|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@316@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@316@01  $FVF<next>)) g@257@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef168|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef169|)))
(assert (forall ((n@311@01 $Ref)) (!
  (=>
    (Set_in n@311@01 g@257@01)
    (and (= (inv@312@01 n@311@01) n@311@01) (img@313@01 n@311@01)))
  :pattern ((Set_in n@311@01 g@257@01))
  :pattern ((inv@312@01 n@311@01))
  :pattern ((img@313@01 n@311@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@313@01 r) (Set_in (inv@312@01 r) g@257@01)) (= (inv@312@01 r) r))
  :pattern ((inv@312@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@316@01  $FVF<next>)))
      (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r)))
    (=>
      (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r))
      (Set_in r ($FVF.domain_next (as sm@316@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@316@01  $FVF<next>))))
  :qid |qp.fvfDomDef172|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@312@01 r) g@257@01) (img@313@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@316@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@312@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) r) r))
    :pattern ((inv@312@01 r))
    :qid |quant-u-215|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@316@01  $FVF<next>)) g@257@01)))
(declare-const old_g@317@01 Set<Edge>)
(assert (=
  old_g@317@01
  ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@316@01  $FVF<next>)) g@257@01)))
; [exec]
; last := x
; [eval] last == null
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not (= x@258@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; [then-branch: 36 | x@258@01 == Null | dead]
; [else-branch: 36 | x@258@01 != Null | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 36 | x@258@01 != Null]
(assert (not (= x@258@01 $Ref.null)))
(pop) ; 3
; [eval] !(last == null)
; [eval] last == null
(push) ; 3
(set-option :timeout 10)
(assert (not (= x@258@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not (= x@258@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; [then-branch: 37 | x@258@01 != Null | live]
; [else-branch: 37 | x@258@01 == Null | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 37 | x@258@01 != Null]
(assert (not (= x@258@01 $Ref.null)))
(declare-const last@318@01 $Ref)
(push) ; 4
; Loop head block: Check well-definedness of invariant
(declare-const $t@319@01 $Snap)
(assert (= $t@319@01 ($Snap.combine ($Snap.first $t@319@01) ($Snap.second $t@319@01))))
(assert (= ($Snap.first $t@319@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@319@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@319@01))
    ($Snap.second ($Snap.second $t@319@01)))))
(declare-const n$1@320@01 $Ref)
(push) ; 5
; [eval] (n$1 in g)
(assert (Set_in n$1@320@01 g@257@01))
(declare-const sm@321@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@322@01 ($Ref) $Ref)
(declare-fun img@323@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((n$11@320@01 $Ref) (n$12@320@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@320@01 g@257@01)
      (Set_in n$12@320@01 g@257@01)
      (= n$11@320@01 n$12@320@01))
    (= n$11@320@01 n$12@320@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@320@01 $Ref)) (!
  (=>
    (Set_in n$1@320@01 g@257@01)
    (and (= (inv@322@01 n$1@320@01) n$1@320@01) (img@323@01 n$1@320@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) n$1@320@01) n$1@320@01))
  :qid |quant-u-220|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)) (= (inv@322@01 r) r))
  :pattern ((inv@322@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@320@01 $Ref)) (!
  (=> (Set_in n$1@320@01 g@257@01) (not (= n$1@320@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) n$1@320@01) n$1@320@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@324@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@322@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@322@01 r))
  :qid |quant-u-221|)))
(assert (=
  ($Snap.second ($Snap.second $t@319@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@319@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@319@01))) $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@325@01 $Ref)
(push) ; 5
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 6
; [then-branch: 38 | !(n$2@325@01 in g@257@01) | live]
; [else-branch: 38 | n$2@325@01 in g@257@01 | live]
(push) ; 7
; [then-branch: 38 | !(n$2@325@01 in g@257@01)]
(assert (not (Set_in n$2@325@01 g@257@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 38 | n$2@325@01 in g@257@01]
(assert (Set_in n$2@325@01 g@257@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
    :qid |qp.fvfValDef174|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef175|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))
(push) ; 8
(assert (not (and (img@323@01 n$2@325@01) (Set_in (inv@322@01 n$2@325@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (=>
  (Set_in n$2@325@01 g@257@01)
  (and
    (Set_in n$2@325@01 g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))))
(assert (or (Set_in n$2@325@01 g@257@01) (not (Set_in n$2@325@01 g@257@01))))
(push) ; 6
; [then-branch: 39 | n$2@325@01 in g@257@01 && Lookup(next, sm@324@01, n$2@325@01) != Null | live]
; [else-branch: 39 | !(n$2@325@01 in g@257@01 && Lookup(next, sm@324@01, n$2@325@01) != Null) | live]
(push) ; 7
; [then-branch: 39 | n$2@325@01 in g@257@01 && Lookup(next, sm@324@01, n$2@325@01) != Null]
(assert (and
  (Set_in n$2@325@01 g@257@01)
  (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
    :qid |qp.fvfValDef174|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef175|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))
(push) ; 8
(assert (not (and (img@323@01 n$2@325@01) (Set_in (inv@322@01 n$2@325@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
(pop) ; 7
(push) ; 7
; [else-branch: 39 | !(n$2@325@01 in g@257@01 && Lookup(next, sm@324@01, n$2@325@01) != Null)]
(assert (not
  (and
    (Set_in n$2@325@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (=>
  (and
    (Set_in n$2@325@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
  (and
    (Set_in n$2@325@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@325@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))))
  (and
    (Set_in n$2@325@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef175|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@325@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@325@01 g@257@01)
      (and
        (Set_in n$2@325@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or (Set_in n$2@325@01 g@257@01) (not (Set_in n$2@325@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or
      (not
        (and
          (Set_in n$2@325@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01)
              $Ref.null))))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(assert (forall ((n$2@325@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@325@01 g@257@01)
      (and
        (Set_in n$2@325@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or (Set_in n$2@325@01 g@257@01) (not (Set_in n$2@325@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or
      (not
        (and
          (Set_in n$2@325@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01)
              $Ref.null))))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))))
  :pattern ((Set_in n$2@325@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(assert (forall ((n$2@325@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@325@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) g@257@01))
  :pattern ((Set_in n$2@325@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@319@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@319@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@319@01))))
  $Snap.unit))
; [eval] (last in g)
(assert (Set_in last@318@01 g@257@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))
  $Snap.unit))
; [eval] (x in g)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
  $Snap.unit))
; [eval] (y in g)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
  $Snap.unit))
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n))
(declare-const n@326@01 $Ref)
(push) ; 5
; [eval] (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 6
; [then-branch: 40 | n@326@01 in g@257@01 | live]
; [else-branch: 40 | !(n@326@01 in g@257@01) | live]
(push) ; 7
; [then-branch: 40 | n@326@01 in g@257@01]
(assert (Set_in n@326@01 g@257@01))
; [eval] exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 8
(declare-const n@327@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@327@01 g@257@01))
(pop) ; 9
(declare-fun inv@328@01 ($Ref) $Ref)
(declare-fun img@329@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@327@01 $Ref) (n2@327@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@327@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n1@327@01) n1@327@01))
      (and
        (Set_in n2@327@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n2@327@01) n2@327@01))
      (= n1@327@01 n2@327@01))
    (= n1@327@01 n2@327@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@327@01 $Ref)) (!
  (=>
    (Set_in n@327@01 g@257@01)
    (and (= (inv@328@01 n@327@01) n@327@01) (img@329@01 n@327@01)))
  :pattern ((Set_in n@327@01 g@257@01))
  :pattern ((inv@328@01 n@327@01))
  :pattern ((img@329@01 n@327@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@329@01 r) (Set_in (inv@328@01 r) g@257@01)) (= (inv@328@01 r) r))
  :pattern ((inv@328@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@328@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@328@01 r))
  :qid |quant-u-223|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@330@01 ((r $Ref) (n@326@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r) (= r (inv@328@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@330@01 r n@326@01))
    $Perm.No)
  
  :qid |quant-u-225|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r) (= r (inv@328@01 r)))
    (= (- $Perm.Write (pTaken@330@01 r n@326@01)) $Perm.No))
  
  :qid |quant-u-226|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@331@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r)))
    (=>
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>))))
  :qid |qp.fvfDomDef178|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@331@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef177|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@327@01 $Ref)) (!
  (=>
    (Set_in n@327@01 g@257@01)
    (and (= (inv@328@01 n@327@01) n@327@01) (img@329@01 n@327@01)))
  :pattern ((Set_in n@327@01 g@257@01))
  :pattern ((inv@328@01 n@327@01))
  :pattern ((img@329@01 n@327@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@329@01 r) (Set_in (inv@328@01 r) g@257@01)) (= (inv@328@01 r) r))
  :pattern ((inv@328@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r)))
    (=>
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>))))
  :qid |qp.fvfDomDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@331@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef177|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@328@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
    :pattern ((inv@328@01 r))
    :qid |quant-u-223|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 41 | exists_path[Bool]($$(sm@331@01, g@257@01), x@258@01, n@326@01) | live]
; [else-branch: 41 | !(exists_path[Bool]($$(sm@331@01, g@257@01), x@258@01, n@326@01)) | live]
(push) ; 9
; [then-branch: 41 | exists_path[Bool]($$(sm@331@01, g@257@01), x@258@01, n@326@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
(pop) ; 9
(push) ; 9
; [else-branch: 41 | !(exists_path[Bool]($$(sm@331@01, g@257@01), x@258@01, n@326@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01)))
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 10
(declare-const n@332@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@332@01 g@257@01))
(pop) ; 11
(declare-fun inv@333@01 ($Ref) $Ref)
(declare-fun img@334@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@335@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@335@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@332@01 $Ref) (n2@332@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@332@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) n1@332@01) n1@332@01))
      (and
        (Set_in n2@332@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) n2@332@01) n2@332@01))
      (= n1@332@01 n2@332@01))
    (= n1@332@01 n2@332@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@332@01 $Ref)) (!
  (=>
    (Set_in n@332@01 g@257@01)
    (and (= (inv@333@01 n@332@01) n@332@01) (img@334@01 n@332@01)))
  :pattern ((Set_in n@332@01 g@257@01))
  :pattern ((inv@333@01 n@332@01))
  :pattern ((img@334@01 n@332@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@334@01 r) (Set_in (inv@333@01 r) g@257@01)) (= (inv@333@01 r) r))
  :pattern ((inv@333@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@333@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
  :pattern ((inv@333@01 r))
  :qid |quant-u-228|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@336@01 ((r $Ref) (n@326@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r) (= r (inv@333@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@336@01 r n@326@01))
    $Perm.No)
  
  :qid |quant-u-230|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r) (= r (inv@333@01 r)))
    (= (- $Perm.Write (pTaken@336@01 r n@326@01)) $Perm.No))
  
  :qid |quant-u-231|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@337@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r)))
    (=>
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>))))
  :qid |qp.fvfDomDef183|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@337@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@335@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((n@332@01 $Ref)) (!
  (=>
    (Set_in n@332@01 g@257@01)
    (and (= (inv@333@01 n@332@01) n@332@01) (img@334@01 n@332@01)))
  :pattern ((Set_in n@332@01 g@257@01))
  :pattern ((inv@333@01 n@332@01))
  :pattern ((img@334@01 n@332@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@334@01 r) (Set_in (inv@333@01 r) g@257@01)) (= (inv@333@01 r) r))
  :pattern ((inv@333@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r)))
    (=>
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>))))
  :qid |qp.fvfDomDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@337@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@333@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
    :pattern ((inv@333@01 r))
    :qid |quant-u-228|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@335@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((n@332@01 $Ref)) (!
  (=>
    (Set_in n@332@01 g@257@01)
    (and (= (inv@333@01 n@332@01) n@332@01) (img@334@01 n@332@01)))
  :pattern ((Set_in n@332@01 g@257@01))
  :pattern ((inv@333@01 n@332@01))
  :pattern ((img@334@01 n@332@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@334@01 r) (Set_in (inv@333@01 r) g@257@01)) (= (inv@333@01 r) r))
  :pattern ((inv@333@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r)))
    (=>
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>))))
  :qid |qp.fvfDomDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@337@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@333@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
      :pattern ((inv@333@01 r))
      :qid |quant-u-228|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01)))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 40 | !(n@326@01 in g@257@01)]
(assert (not (Set_in n@326@01 g@257@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((n@327@01 $Ref)) (!
  (=>
    (Set_in n@327@01 g@257@01)
    (and (= (inv@328@01 n@327@01) n@327@01) (img@329@01 n@327@01)))
  :pattern ((Set_in n@327@01 g@257@01))
  :pattern ((inv@328@01 n@327@01))
  :pattern ((img@329@01 n@327@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@329@01 r) (Set_in (inv@328@01 r) g@257@01)) (= (inv@328@01 r) r))
  :pattern ((inv@328@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r)))
    (=>
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>))))
  :qid |qp.fvfDomDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@331@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@335@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((n@332@01 $Ref)) (!
  (=>
    (Set_in n@332@01 g@257@01)
    (and (= (inv@333@01 n@332@01) n@332@01) (img@334@01 n@332@01)))
  :pattern ((Set_in n@332@01 g@257@01))
  :pattern ((inv@333@01 n@332@01))
  :pattern ((img@334@01 n@332@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@334@01 r) (Set_in (inv@333@01 r) g@257@01)) (= (inv@333@01 r) r))
  :pattern ((inv@333@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r)))
    (=>
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>))))
  :qid |qp.fvfDomDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@337@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
(assert (=>
  (Set_in n@326@01 g@257@01)
  (and
    (Set_in n@326@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@328@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
      :pattern ((inv@328@01 r))
      :qid |quant-u-223|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@333@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
          :pattern ((inv@333@01 r))
          :qid |quant-u-228|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01)))))
; Joined path conditions
(assert (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@327@01 $Ref)) (!
  (=>
    (Set_in n@327@01 g@257@01)
    (and (= (inv@328@01 n@327@01) n@327@01) (img@329@01 n@327@01)))
  :pattern ((Set_in n@327@01 g@257@01))
  :pattern ((inv@328@01 n@327@01))
  :pattern ((img@329@01 n@327@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@329@01 r) (Set_in (inv@328@01 r) g@257@01)) (= (inv@328@01 r) r))
  :pattern ((inv@328@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r)))
    (=>
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>))))
  :qid |qp.fvfDomDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@331@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@335@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((n@332@01 $Ref)) (!
  (=>
    (Set_in n@332@01 g@257@01)
    (and (= (inv@333@01 n@332@01) n@332@01) (img@334@01 n@332@01)))
  :pattern ((Set_in n@332@01 g@257@01))
  :pattern ((inv@333@01 n@332@01))
  :pattern ((img@334@01 n@332@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@334@01 r) (Set_in (inv@333@01 r) g@257@01)) (= (inv@333@01 r) r))
  :pattern ((inv@333@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r)))
    (=>
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>))))
  :qid |qp.fvfDomDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@337@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@326@01 $Ref)) (!
  (and
    (=>
      (Set_in n@326@01 g@257@01)
      (and
        (Set_in n@326@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@328@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@328@01 r))
          :qid |quant-u-223|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@333@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
              :pattern ((inv@333@01 r))
              :qid |quant-u-228|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))))
    (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
  :pattern ((Set_in n@326@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@326@01 $Ref)) (!
  (and
    (=>
      (Set_in n@326@01 g@257@01)
      (and
        (Set_in n@326@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@328@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@328@01 r))
          :qid |quant-u-223|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@333@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
              :pattern ((inv@333@01 r))
              :qid |quant-u-228|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))))
    (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@326@01 $Ref)) (!
  (and
    (=>
      (Set_in n@326@01 g@257@01)
      (and
        (Set_in n@326@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@328@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@328@01 r))
          :qid |quant-u-223|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@333@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
              :pattern ((inv@333@01 r))
              :qid |quant-u-228|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))))
    (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01) y@259@01 n@326@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@326@01 $Ref)) (!
  (=>
    (Set_in n@326@01 g@257@01)
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01) y@259@01 n@326@01)))
  :pattern ((Set_in n@326@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01) y@259@01 n@326@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
  $Snap.unit))
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n))
(declare-const n@338@01 $Ref)
(push) ; 5
; [eval] (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 6
; [then-branch: 42 | n@338@01 in g@257@01 | live]
; [else-branch: 42 | !(n@338@01 in g@257@01) | live]
(push) ; 7
; [then-branch: 42 | n@338@01 in g@257@01]
(assert (Set_in n@338@01 g@257@01))
; [eval] !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] !exists_path($$(g), x, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 8
(declare-const n@339@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@339@01 g@257@01))
(pop) ; 9
(declare-fun inv@340@01 ($Ref) $Ref)
(declare-fun img@341@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@339@01 $Ref) (n2@339@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@339@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n1@339@01) n1@339@01))
      (and
        (Set_in n2@339@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n2@339@01) n2@339@01))
      (= n1@339@01 n2@339@01))
    (= n1@339@01 n2@339@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@339@01 $Ref)) (!
  (=>
    (Set_in n@339@01 g@257@01)
    (and (= (inv@340@01 n@339@01) n@339@01) (img@341@01 n@339@01)))
  :pattern ((Set_in n@339@01 g@257@01))
  :pattern ((inv@340@01 n@339@01))
  :pattern ((img@341@01 n@339@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@341@01 r) (Set_in (inv@340@01 r) g@257@01)) (= (inv@340@01 r) r))
  :pattern ((inv@340@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@340@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@340@01 r))
  :qid |quant-u-233|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@342@01 ((r $Ref) (n@338@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r) (= r (inv@340@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@342@01 r n@338@01))
    $Perm.No)
  
  :qid |quant-u-235|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r) (= r (inv@340@01 r)))
    (= (- $Perm.Write (pTaken@342@01 r n@338@01)) $Perm.No))
  
  :qid |quant-u-236|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@343@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r)))
    (=>
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@339@01 $Ref)) (!
  (=>
    (Set_in n@339@01 g@257@01)
    (and (= (inv@340@01 n@339@01) n@339@01) (img@341@01 n@339@01)))
  :pattern ((Set_in n@339@01 g@257@01))
  :pattern ((inv@340@01 n@339@01))
  :pattern ((img@341@01 n@339@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@341@01 r) (Set_in (inv@340@01 r) g@257@01)) (= (inv@340@01 r) r))
  :pattern ((inv@340@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r)))
    (=>
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@340@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
    :pattern ((inv@340@01 r))
    :qid |quant-u-233|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 43 | !(exists_path[Bool]($$(sm@343@01, g@257@01), x@258@01, n@338@01)) | live]
; [else-branch: 43 | exists_path[Bool]($$(sm@343@01, g@257@01), x@258@01, n@338@01) | live]
(push) ; 9
; [then-branch: 43 | !(exists_path[Bool]($$(sm@343@01, g@257@01), x@258@01, n@338@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 43 | exists_path[Bool]($$(sm@343@01, g@257@01), x@258@01, n@338@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
; [eval] !exists_path($$(g), y, n)
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 10
(declare-const n@344@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@344@01 g@257@01))
(pop) ; 11
(declare-fun inv@345@01 ($Ref) $Ref)
(declare-fun img@346@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@347@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@347@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@344@01 $Ref) (n2@344@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@344@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) n1@344@01) n1@344@01))
      (and
        (Set_in n2@344@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) n2@344@01) n2@344@01))
      (= n1@344@01 n2@344@01))
    (= n1@344@01 n2@344@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@344@01 $Ref)) (!
  (=>
    (Set_in n@344@01 g@257@01)
    (and (= (inv@345@01 n@344@01) n@344@01) (img@346@01 n@344@01)))
  :pattern ((Set_in n@344@01 g@257@01))
  :pattern ((inv@345@01 n@344@01))
  :pattern ((img@346@01 n@344@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@346@01 r) (Set_in (inv@345@01 r) g@257@01)) (= (inv@345@01 r) r))
  :pattern ((inv@345@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@345@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
  :pattern ((inv@345@01 r))
  :qid |quant-u-238|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@348@01 ((r $Ref) (n@338@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r) (= r (inv@345@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@348@01 r n@338@01))
    $Perm.No)
  
  :qid |quant-u-240|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r) (= r (inv@345@01 r)))
    (= (- $Perm.Write (pTaken@348@01 r n@338@01)) $Perm.No))
  
  :qid |quant-u-241|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@349@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r)))
    (=>
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@349@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@347@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@344@01 $Ref)) (!
  (=>
    (Set_in n@344@01 g@257@01)
    (and (= (inv@345@01 n@344@01) n@344@01) (img@346@01 n@344@01)))
  :pattern ((Set_in n@344@01 g@257@01))
  :pattern ((inv@345@01 n@344@01))
  :pattern ((img@346@01 n@344@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@346@01 r) (Set_in (inv@345@01 r) g@257@01)) (= (inv@345@01 r) r))
  :pattern ((inv@345@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r)))
    (=>
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@349@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@345@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
    :pattern ((inv@345@01 r))
    :qid |quant-u-238|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@347@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@344@01 $Ref)) (!
  (=>
    (Set_in n@344@01 g@257@01)
    (and (= (inv@345@01 n@344@01) n@344@01) (img@346@01 n@344@01)))
  :pattern ((Set_in n@344@01 g@257@01))
  :pattern ((inv@345@01 n@344@01))
  :pattern ((img@346@01 n@344@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@346@01 r) (Set_in (inv@345@01 r) g@257@01)) (= (inv@345@01 r) r))
  :pattern ((inv@345@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r)))
    (=>
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@349@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@345@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
      :pattern ((inv@345@01 r))
      :qid |quant-u-238|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 42 | !(n@338@01 in g@257@01)]
(assert (not (Set_in n@338@01 g@257@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((n@339@01 $Ref)) (!
  (=>
    (Set_in n@339@01 g@257@01)
    (and (= (inv@340@01 n@339@01) n@339@01) (img@341@01 n@339@01)))
  :pattern ((Set_in n@339@01 g@257@01))
  :pattern ((inv@340@01 n@339@01))
  :pattern ((img@341@01 n@339@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@341@01 r) (Set_in (inv@340@01 r) g@257@01)) (= (inv@340@01 r) r))
  :pattern ((inv@340@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r)))
    (=>
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@347@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@344@01 $Ref)) (!
  (=>
    (Set_in n@344@01 g@257@01)
    (and (= (inv@345@01 n@344@01) n@344@01) (img@346@01 n@344@01)))
  :pattern ((Set_in n@344@01 g@257@01))
  :pattern ((inv@345@01 n@344@01))
  :pattern ((img@346@01 n@344@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@346@01 r) (Set_in (inv@345@01 r) g@257@01)) (= (inv@345@01 r) r))
  :pattern ((inv@345@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r)))
    (=>
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@349@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (=>
  (Set_in n@338@01 g@257@01)
  (and
    (Set_in n@338@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@340@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
      :pattern ((inv@340@01 r))
      :qid |quant-u-233|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@345@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
          :pattern ((inv@345@01 r))
          :qid |quant-u-238|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))))))
; Joined path conditions
(assert (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@339@01 $Ref)) (!
  (=>
    (Set_in n@339@01 g@257@01)
    (and (= (inv@340@01 n@339@01) n@339@01) (img@341@01 n@339@01)))
  :pattern ((Set_in n@339@01 g@257@01))
  :pattern ((inv@340@01 n@339@01))
  :pattern ((img@341@01 n@339@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@341@01 r) (Set_in (inv@340@01 r) g@257@01)) (= (inv@340@01 r) r))
  :pattern ((inv@340@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r)))
    (=>
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@347@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@344@01 $Ref)) (!
  (=>
    (Set_in n@344@01 g@257@01)
    (and (= (inv@345@01 n@344@01) n@344@01) (img@346@01 n@344@01)))
  :pattern ((Set_in n@344@01 g@257@01))
  :pattern ((inv@345@01 n@344@01))
  :pattern ((img@346@01 n@344@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@346@01 r) (Set_in (inv@345@01 r) g@257@01)) (= (inv@345@01 r) r))
  :pattern ((inv@345@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r)))
    (=>
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@349@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@338@01 $Ref)) (!
  (and
    (=>
      (Set_in n@338@01 g@257@01)
      (and
        (Set_in n@338@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@340@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@340@01 r))
          :qid |quant-u-233|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@345@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
              :pattern ((inv@345@01 r))
              :qid |quant-u-238|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))))
    (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
  :pattern ((Set_in n@338@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@338@01 $Ref)) (!
  (and
    (=>
      (Set_in n@338@01 g@257@01)
      (and
        (Set_in n@338@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@340@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@340@01 r))
          :qid |quant-u-233|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@345@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
              :pattern ((inv@345@01 r))
              :qid |quant-u-238|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))))
    (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@338@01 $Ref)) (!
  (and
    (=>
      (Set_in n@338@01 g@257@01)
      (and
        (Set_in n@338@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@340@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@340@01 r))
          :qid |quant-u-233|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@345@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
              :pattern ((inv@345@01 r))
              :qid |quant-u-238|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))))
    (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01) y@259@01 n@338@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@338@01 $Ref)) (!
  (=>
    (Set_in n@338@01 g@257@01)
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01) y@259@01 n@338@01))))
  :pattern ((Set_in n@338@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01) y@259@01 n@338@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
  $Snap.unit))
; [eval] acyclic_graph($$(g))
; [eval] $$(g)
(push) ; 5
(declare-const n@350@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@350@01 g@257@01))
(pop) ; 6
(declare-fun inv@351@01 ($Ref) $Ref)
(declare-fun img@352@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@350@01 $Ref) (n2@350@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@350@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n1@350@01) n1@350@01))
      (and
        (Set_in n2@350@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n2@350@01) n2@350@01))
      (= n1@350@01 n2@350@01))
    (= n1@350@01 n2@350@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@350@01 $Ref)) (!
  (=>
    (Set_in n@350@01 g@257@01)
    (and (= (inv@351@01 n@350@01) n@350@01) (img@352@01 n@350@01)))
  :pattern ((Set_in n@350@01 g@257@01))
  :pattern ((inv@351@01 n@350@01))
  :pattern ((img@352@01 n@350@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@352@01 r) (Set_in (inv@351@01 r) g@257@01)) (= (inv@351@01 r) r))
  :pattern ((inv@351@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@351@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@351@01 r))
  :qid |quant-u-243|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@353@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r) (= r (inv@351@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@353@01 r))
    $Perm.No)
  
  :qid |quant-u-245|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r) (= r (inv@351@01 r)))
    (= (- $Perm.Write (pTaken@353@01 r)) $Perm.No))
  
  :qid |quant-u-246|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@354@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>)))
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r)))
    (=>
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r))
      (Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>))))
  :qid |qp.fvfDomDef194|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@354@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@354@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@354@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@354@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@350@01 $Ref)) (!
  (=>
    (Set_in n@350@01 g@257@01)
    (and (= (inv@351@01 n@350@01) n@350@01) (img@352@01 n@350@01)))
  :pattern ((Set_in n@350@01 g@257@01))
  :pattern ((inv@351@01 n@350@01))
  :pattern ((img@352@01 n@350@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@352@01 r) (Set_in (inv@351@01 r) g@257@01)) (= (inv@351@01 r) r))
  :pattern ((inv@351@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>)))
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r)))
    (=>
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r))
      (Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>))))
  :qid |qp.fvfDomDef194|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@354@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@354@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@354@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@351@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
    :pattern ((inv@351@01 r))
    :qid |quant-u-243|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@354@01  $FVF<next>)) g@257@01)))
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@354@01  $FVF<next>)) g@257@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
  $Snap.unit))
; [eval] unshared_graph($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 5
(declare-const n@355@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@355@01 g@257@01))
(pop) ; 6
(declare-fun inv@356@01 ($Ref) $Ref)
(declare-fun img@357@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@358@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@358@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@358@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef195|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@358@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef196|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@355@01 $Ref) (n2@355@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@355@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@358@01  $FVF<next>) n1@355@01) n1@355@01))
      (and
        (Set_in n2@355@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@358@01  $FVF<next>) n2@355@01) n2@355@01))
      (= n1@355@01 n2@355@01))
    (= n1@355@01 n2@355@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@355@01 $Ref)) (!
  (=>
    (Set_in n@355@01 g@257@01)
    (and (= (inv@356@01 n@355@01) n@355@01) (img@357@01 n@355@01)))
  :pattern ((Set_in n@355@01 g@257@01))
  :pattern ((inv@356@01 n@355@01))
  :pattern ((img@357@01 n@355@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@357@01 r) (Set_in (inv@356@01 r) g@257@01)) (= (inv@356@01 r) r))
  :pattern ((inv@356@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@356@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@358@01  $FVF<next>) r) r))
  :pattern ((inv@356@01 r))
  :qid |quant-u-248|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@359@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r) (= r (inv@356@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@359@01 r))
    $Perm.No)
  
  :qid |quant-u-250|))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r) (= r (inv@356@01 r)))
    (= (- $Perm.Write (pTaken@359@01 r)) $Perm.No))
  
  :qid |quant-u-251|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@360@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>)))
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r)))
    (=>
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r))
      (Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>))))
  :qid |qp.fvfDomDef199|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef198|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@360@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@358@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@358@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef195|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@358@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef196|)))
(assert (forall ((n@355@01 $Ref)) (!
  (=>
    (Set_in n@355@01 g@257@01)
    (and (= (inv@356@01 n@355@01) n@355@01) (img@357@01 n@355@01)))
  :pattern ((Set_in n@355@01 g@257@01))
  :pattern ((inv@356@01 n@355@01))
  :pattern ((img@357@01 n@355@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@357@01 r) (Set_in (inv@356@01 r) g@257@01)) (= (inv@356@01 r) r))
  :pattern ((inv@356@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>)))
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r)))
    (=>
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r))
      (Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>))))
  :qid |qp.fvfDomDef199|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef198|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@356@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@358@01  $FVF<next>) r) r))
    :pattern ((inv@356@01 r))
    :qid |quant-u-248|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@360@01  $FVF<next>)) g@257@01)))
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@360@01  $FVF<next>)) g@257@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
  $Snap.unit))
; [eval] $$(g) == old_g
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 5
(declare-const n@361@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@361@01 g@257@01))
(pop) ; 6
(declare-fun inv@362@01 ($Ref) $Ref)
(declare-fun img@363@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@364@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@364@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@364@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef200|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@364@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef201|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@361@01 $Ref) (n2@361@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@361@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@364@01  $FVF<next>) n1@361@01) n1@361@01))
      (and
        (Set_in n2@361@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@364@01  $FVF<next>) n2@361@01) n2@361@01))
      (= n1@361@01 n2@361@01))
    (= n1@361@01 n2@361@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@361@01 $Ref)) (!
  (=>
    (Set_in n@361@01 g@257@01)
    (and (= (inv@362@01 n@361@01) n@361@01) (img@363@01 n@361@01)))
  :pattern ((Set_in n@361@01 g@257@01))
  :pattern ((inv@362@01 n@361@01))
  :pattern ((img@363@01 n@361@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@363@01 r) (Set_in (inv@362@01 r) g@257@01)) (= (inv@362@01 r) r))
  :pattern ((inv@362@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@362@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@364@01  $FVF<next>) r) r))
  :pattern ((inv@362@01 r))
  :qid |quant-u-253|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@365@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r) (= r (inv@362@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@365@01 r))
    $Perm.No)
  
  :qid |quant-u-255|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r) (= r (inv@362@01 r)))
    (= (- $Perm.Write (pTaken@365@01 r)) $Perm.No))
  
  :qid |quant-u-256|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@366@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r)))
    (=>
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r))
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>))))
  :qid |qp.fvfDomDef204|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@366@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef203|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@364@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@364@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef200|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@364@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef201|)))
(assert (forall ((n@361@01 $Ref)) (!
  (=>
    (Set_in n@361@01 g@257@01)
    (and (= (inv@362@01 n@361@01) n@361@01) (img@363@01 n@361@01)))
  :pattern ((Set_in n@361@01 g@257@01))
  :pattern ((inv@362@01 n@361@01))
  :pattern ((img@363@01 n@361@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@363@01 r) (Set_in (inv@362@01 r) g@257@01)) (= (inv@362@01 r) r))
  :pattern ((inv@362@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r)))
    (=>
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r))
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>))))
  :qid |qp.fvfDomDef204|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@366@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef203|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@362@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@364@01  $FVF<next>) r) r))
    :pattern ((inv@362@01 r))
    :qid |quant-u-253|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>)) g@257@01)))
(assert (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>)) g@257@01) old_g@317@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
  $Snap.unit))
; [eval] exists_path($$(g), x, last)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 5
(declare-const n@367@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@367@01 g@257@01))
(pop) ; 6
(declare-fun inv@368@01 ($Ref) $Ref)
(declare-fun img@369@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@370@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@370@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@370@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@370@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef206|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@367@01 $Ref) (n2@367@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@367@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@370@01  $FVF<next>) n1@367@01) n1@367@01))
      (and
        (Set_in n2@367@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@370@01  $FVF<next>) n2@367@01) n2@367@01))
      (= n1@367@01 n2@367@01))
    (= n1@367@01 n2@367@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@367@01 $Ref)) (!
  (=>
    (Set_in n@367@01 g@257@01)
    (and (= (inv@368@01 n@367@01) n@367@01) (img@369@01 n@367@01)))
  :pattern ((Set_in n@367@01 g@257@01))
  :pattern ((inv@368@01 n@367@01))
  :pattern ((img@369@01 n@367@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@369@01 r) (Set_in (inv@368@01 r) g@257@01)) (= (inv@368@01 r) r))
  :pattern ((inv@368@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@368@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@370@01  $FVF<next>) r) r))
  :pattern ((inv@368@01 r))
  :qid |quant-u-258|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@371@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r) (= r (inv@368@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@371@01 r))
    $Perm.No)
  
  :qid |quant-u-260|))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r) (= r (inv@368@01 r)))
    (= (- $Perm.Write (pTaken@371@01 r)) $Perm.No))
  
  :qid |quant-u-261|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@372@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>)))
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r)))
    (=>
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r))
      (Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>))))
  :qid |qp.fvfDomDef209|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@372@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@372@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@372@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef208|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@372@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@370@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@370@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@370@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef206|)))
(assert (forall ((n@367@01 $Ref)) (!
  (=>
    (Set_in n@367@01 g@257@01)
    (and (= (inv@368@01 n@367@01) n@367@01) (img@369@01 n@367@01)))
  :pattern ((Set_in n@367@01 g@257@01))
  :pattern ((inv@368@01 n@367@01))
  :pattern ((img@369@01 n@367@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@369@01 r) (Set_in (inv@368@01 r) g@257@01)) (= (inv@368@01 r) r))
  :pattern ((inv@368@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>)))
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r)))
    (=>
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r))
      (Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>))))
  :qid |qp.fvfDomDef209|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@372@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@372@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@372@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef208|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@368@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@370@01  $FVF<next>) r) r))
    :pattern ((inv@368@01 r))
    :qid |quant-u-258|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@372@01  $FVF<next>)) g@257@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@372@01  $FVF<next>)) g@257@01) x@258@01 last@318@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
  $Snap.unit))
; [eval] last.next != null ==> edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next) ==> exists_path($$(g), last, last.next)
; [eval] last.next != null
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) last@318@01))
(set-option :timeout 0)
(push) ; 5
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; [then-branch: 44 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null | live]
; [else-branch: 44 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 44 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null]
(assert (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null)))
; [eval] edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next) ==> exists_path($$(g), last, last.next)
; [eval] edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next)
; [eval] edge($$(g), last, last.next)
; [eval] $$(g)
(push) ; 7
(declare-const n@373@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@373@01 g@257@01))
(pop) ; 8
(declare-fun inv@374@01 ($Ref) $Ref)
(declare-fun img@375@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@376@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@376@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef211|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@373@01 $Ref) (n2@373@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@373@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@376@01  $FVF<next>) n1@373@01) n1@373@01))
      (and
        (Set_in n2@373@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@376@01  $FVF<next>) n2@373@01) n2@373@01))
      (= n1@373@01 n2@373@01))
    (= n1@373@01 n2@373@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@373@01 $Ref)) (!
  (=>
    (Set_in n@373@01 g@257@01)
    (and (= (inv@374@01 n@373@01) n@373@01) (img@375@01 n@373@01)))
  :pattern ((Set_in n@373@01 g@257@01))
  :pattern ((inv@374@01 n@373@01))
  :pattern ((img@375@01 n@373@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@375@01 r) (Set_in (inv@374@01 r) g@257@01)) (= (inv@374@01 r) r))
  :pattern ((inv@374@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@374@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@376@01  $FVF<next>) r) r))
  :pattern ((inv@374@01 r))
  :qid |quant-u-263|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@377@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r) (= r (inv@374@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@377@01 r))
    $Perm.No)
  
  :qid |quant-u-265|))))
(check-sat)
; unsat
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r) (= r (inv@374@01 r)))
    (= (- $Perm.Write (pTaken@377@01 r)) $Perm.No))
  
  :qid |quant-u-266|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@378@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r)))
    (=>
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>))))
  :qid |qp.fvfDomDef214|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@378@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef212|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef213|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@376@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef211|)))
(assert (forall ((n@373@01 $Ref)) (!
  (=>
    (Set_in n@373@01 g@257@01)
    (and (= (inv@374@01 n@373@01) n@373@01) (img@375@01 n@373@01)))
  :pattern ((Set_in n@373@01 g@257@01))
  :pattern ((inv@374@01 n@373@01))
  :pattern ((img@375@01 n@373@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@375@01 r) (Set_in (inv@374@01 r) g@257@01)) (= (inv@374@01 r) r))
  :pattern ((inv@374@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r)))
    (=>
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>))))
  :qid |qp.fvfDomDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@378@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef212|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef213|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@374@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@376@01  $FVF<next>) r) r))
    :pattern ((inv@374@01 r))
    :qid |quant-u-263|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 7
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(push) ; 7
; [then-branch: 45 | !(edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01))) | live]
; [else-branch: 45 | edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01)) | live]
(push) ; 8
; [then-branch: 45 | !(edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01)))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
(pop) ; 8
(push) ; 8
; [else-branch: 45 | edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01))]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))
; [eval] exists_path($$(g), last.next, last.next)
; [eval] $$(g)
(push) ; 9
(declare-const n@379@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@379@01 g@257@01))
(pop) ; 10
(declare-fun inv@380@01 ($Ref) $Ref)
(declare-fun img@381@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@382@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@382@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@379@01 $Ref) (n2@379@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@379@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) n1@379@01) n1@379@01))
      (and
        (Set_in n2@379@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) n2@379@01) n2@379@01))
      (= n1@379@01 n2@379@01))
    (= n1@379@01 n2@379@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@379@01 $Ref)) (!
  (=>
    (Set_in n@379@01 g@257@01)
    (and (= (inv@380@01 n@379@01) n@379@01) (img@381@01 n@379@01)))
  :pattern ((Set_in n@379@01 g@257@01))
  :pattern ((inv@380@01 n@379@01))
  :pattern ((img@381@01 n@379@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@381@01 r) (Set_in (inv@380@01 r) g@257@01)) (= (inv@380@01 r) r))
  :pattern ((inv@380@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@380@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) r) r))
  :pattern ((inv@380@01 r))
  :qid |quant-u-268|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@383@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r) (= r (inv@380@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@383@01 r))
    $Perm.No)
  
  :qid |quant-u-270|))))
(check-sat)
; unsat
(pop) ; 10
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r) (= r (inv@380@01 r)))
    (= (- $Perm.Write (pTaken@383@01 r)) $Perm.No))
  
  :qid |quant-u-271|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@384@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r)))
    (=>
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>))))
  :qid |qp.fvfDomDef219|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@384@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef218|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@382@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((n@379@01 $Ref)) (!
  (=>
    (Set_in n@379@01 g@257@01)
    (and (= (inv@380@01 n@379@01) n@379@01) (img@381@01 n@379@01)))
  :pattern ((Set_in n@379@01 g@257@01))
  :pattern ((inv@380@01 n@379@01))
  :pattern ((img@381@01 n@379@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@381@01 r) (Set_in (inv@380@01 r) g@257@01)) (= (inv@380@01 r) r))
  :pattern ((inv@380@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r)))
    (=>
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>))))
  :qid |qp.fvfDomDef219|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@384@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef218|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@380@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) r) r))
    :pattern ((inv@380@01 r))
    :qid |quant-u-268|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 9
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(push) ; 9
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@382@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((n@379@01 $Ref)) (!
  (=>
    (Set_in n@379@01 g@257@01)
    (and (= (inv@380@01 n@379@01) n@379@01) (img@381@01 n@379@01)))
  :pattern ((Set_in n@379@01 g@257@01))
  :pattern ((inv@380@01 n@379@01))
  :pattern ((img@381@01 n@379@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@381@01 r) (Set_in (inv@380@01 r) g@257@01)) (= (inv@380@01 r) r))
  :pattern ((inv@380@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r)))
    (=>
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>))))
  :qid |qp.fvfDomDef219|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@384@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef218|)))
(assert (=>
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@380@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) r) r))
      :pattern ((inv@380@01 r))
      :qid |quant-u-268|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01))))
(assert (or
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; [then-branch: 46 | edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01)) && exists_path[Bool]($$(sm@384@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@318@01), Lookup(next, First:(Second:($t@319@01)), last@318@01)) | live]
; [else-branch: 46 | !(edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01)) && exists_path[Bool]($$(sm@384@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@318@01), Lookup(next, First:(Second:($t@319@01)), last@318@01))) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 46 | edge[Bool]($$(sm@378@01, g@257@01), last@318@01, Lookup(next, First:(Second:($t@319@01)), last@318@01)) && exists_path[Bool]($$(sm@384@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@318@01), Lookup(next, First:(Second:($t@319@01)), last@318@01))]
(assert (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
; [eval] exists_path($$(g), last, last.next)
; [eval] $$(g)
(push) ; 9
(declare-const n@385@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@385@01 g@257@01))
(pop) ; 10
(declare-fun inv@386@01 ($Ref) $Ref)
(declare-fun img@387@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@388@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@388@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@385@01 $Ref) (n2@385@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@385@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) n1@385@01) n1@385@01))
      (and
        (Set_in n2@385@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) n2@385@01) n2@385@01))
      (= n1@385@01 n2@385@01))
    (= n1@385@01 n2@385@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@385@01 $Ref)) (!
  (=>
    (Set_in n@385@01 g@257@01)
    (and (= (inv@386@01 n@385@01) n@385@01) (img@387@01 n@385@01)))
  :pattern ((Set_in n@385@01 g@257@01))
  :pattern ((inv@386@01 n@385@01))
  :pattern ((img@387@01 n@385@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@387@01 r) (Set_in (inv@386@01 r) g@257@01)) (= (inv@386@01 r) r))
  :pattern ((inv@386@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@386@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) r) r))
  :pattern ((inv@386@01 r))
  :qid |quant-u-273|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@389@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r) (= r (inv@386@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@389@01 r))
    $Perm.No)
  
  :qid |quant-u-275|))))
(check-sat)
; unsat
(pop) ; 10
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r) (= r (inv@386@01 r)))
    (= (- $Perm.Write (pTaken@389@01 r)) $Perm.No))
  
  :qid |quant-u-276|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@390@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r)))
    (=>
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@388@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (forall ((n@385@01 $Ref)) (!
  (=>
    (Set_in n@385@01 g@257@01)
    (and (= (inv@386@01 n@385@01) n@385@01) (img@387@01 n@385@01)))
  :pattern ((Set_in n@385@01 g@257@01))
  :pattern ((inv@386@01 n@385@01))
  :pattern ((img@387@01 n@385@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@387@01 r) (Set_in (inv@386@01 r) g@257@01)) (= (inv@386@01 r) r))
  :pattern ((inv@386@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r)))
    (=>
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@386@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) r) r))
    :pattern ((inv@386@01 r))
    :qid |quant-u-273|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 9
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@388@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (forall ((n@385@01 $Ref)) (!
  (=>
    (Set_in n@385@01 g@257@01)
    (and (= (inv@386@01 n@385@01) n@385@01) (img@387@01 n@385@01)))
  :pattern ((Set_in n@385@01 g@257@01))
  :pattern ((inv@386@01 n@385@01))
  :pattern ((img@387@01 n@385@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@387@01 r) (Set_in (inv@386@01 r) g@257@01)) (= (inv@386@01 r) r))
  :pattern ((inv@386@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r)))
    (=>
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
(assert (=>
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@386@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) r) r))
      :pattern ((inv@386@01 r))
      :qid |quant-u-273|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01))))
(assert (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 44 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null]
(assert (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@376@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef211|)))
(assert (forall ((n@373@01 $Ref)) (!
  (=>
    (Set_in n@373@01 g@257@01)
    (and (= (inv@374@01 n@373@01) n@373@01) (img@375@01 n@373@01)))
  :pattern ((Set_in n@373@01 g@257@01))
  :pattern ((inv@374@01 n@373@01))
  :pattern ((img@375@01 n@373@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@375@01 r) (Set_in (inv@374@01 r) g@257@01)) (= (inv@374@01 r) r))
  :pattern ((inv@374@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r)))
    (=>
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>))))
  :qid |qp.fvfDomDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@378@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef212|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@382@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((n@379@01 $Ref)) (!
  (=>
    (Set_in n@379@01 g@257@01)
    (and (= (inv@380@01 n@379@01) n@379@01) (img@381@01 n@379@01)))
  :pattern ((Set_in n@379@01 g@257@01))
  :pattern ((inv@380@01 n@379@01))
  :pattern ((img@381@01 n@379@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@381@01 r) (Set_in (inv@380@01 r) g@257@01)) (= (inv@380@01 r) r))
  :pattern ((inv@380@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r)))
    (=>
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>))))
  :qid |qp.fvfDomDef219|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@384@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@388@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (forall ((n@385@01 $Ref)) (!
  (=>
    (Set_in n@385@01 g@257@01)
    (and (= (inv@386@01 n@385@01) n@385@01) (img@387@01 n@385@01)))
  :pattern ((Set_in n@385@01 g@257@01))
  :pattern ((inv@386@01 n@385@01))
  :pattern ((img@387@01 n@385@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@387@01 r) (Set_in (inv@386@01 r) g@257@01)) (= (inv@386@01 r) r))
  :pattern ((inv@386@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r)))
    (=>
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
        $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@374@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@376@01  $FVF<next>) r) r))
      :pattern ((inv@374@01 r))
      :qid |quant-u-263|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01)
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@380@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) r) r))
          :pattern ((inv@380@01 r))
          :qid |quant-u-268|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01)))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
    (=>
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@386@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) r) r))
          :pattern ((inv@386@01 r))
          :qid |quant-u-273|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01)))
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))))
; Joined path conditions
(assert (or
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null)
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))))
(assert (=>
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
        $Ref.null))
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
(pop) ; 4
(push) ; 4
; Loop head block: Establish invariant
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$1@391@01 $Ref)
(push) ; 5
; [eval] (n$1 in g)
(assert (Set_in n$1@391@01 g@257@01))
(declare-const sm@392@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@392@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef226|)))
(pop) ; 5
(declare-fun inv@393@01 ($Ref) $Ref)
(declare-fun img@394@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@392@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef226|)))
; Nested auxiliary terms: non-globals
(declare-const sm@395@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@395@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef228|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((n$11@391@01 $Ref) (n$12@391@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@391@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$11@391@01) n$11@391@01))
      (and
        (Set_in n$12@391@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$12@391@01) n$12@391@01))
      (= n$11@391@01 n$12@391@01))
    (= n$11@391@01 n$12@391@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@391@01 $Ref)) (!
  (=>
    (Set_in n$1@391@01 g@257@01)
    (and (= (inv@393@01 n$1@391@01) n$1@391@01) (img@394@01 n$1@391@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@392@01  $FVF<next>) n$1@391@01) n$1@391@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@394@01 r) (Set_in (inv@393@01 r) g@257@01)) (= (inv@393@01 r) r))
  :pattern ((inv@393@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@393@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
  :pattern ((inv@393@01 r))
  :qid |quant-u-278|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@396@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@393@01 r) g@257@01) (img@394@01 r) (= r (inv@393@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@396@01 r))
    $Perm.No)
  
  :qid |quant-u-280|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@393@01 r) g@257@01) (img@394@01 r) (= r (inv@393@01 r)))
    (= (- $Perm.Write (pTaken@396@01 r)) $Perm.No))
  
  :qid |quant-u-281|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@397@01 $Ref)
(set-option :timeout 0)
(push) ; 5
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 6
; [then-branch: 47 | !(n$2@397@01 in g@257@01) | live]
; [else-branch: 47 | n$2@397@01 in g@257@01 | live]
(push) ; 7
; [then-branch: 47 | !(n$2@397@01 in g@257@01)]
(assert (not (Set_in n$2@397@01 g@257@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 47 | n$2@397@01 in g@257@01]
(assert (Set_in n$2@397@01 g@257@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@395@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
    :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
    :qid |qp.fvfValDef227|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef228|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))
(push) ; 8
(assert (not (and (img@266@01 n$2@397@01) (Set_in (inv@265@01 n$2@397@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@395@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef228|)))
(assert (=>
  (Set_in n$2@397@01 g@257@01)
  (and
    (Set_in n$2@397@01 g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))))
(assert (or (Set_in n$2@397@01 g@257@01) (not (Set_in n$2@397@01 g@257@01))))
(push) ; 6
; [then-branch: 48 | n$2@397@01 in g@257@01 && Lookup(next, sm@395@01, n$2@397@01) != Null | live]
; [else-branch: 48 | !(n$2@397@01 in g@257@01 && Lookup(next, sm@395@01, n$2@397@01) != Null) | live]
(push) ; 7
; [then-branch: 48 | n$2@397@01 in g@257@01 && Lookup(next, sm@395@01, n$2@397@01) != Null]
(assert (and
  (Set_in n$2@397@01 g@257@01)
  (not (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@395@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
    :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
    :qid |qp.fvfValDef227|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef228|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))
(push) ; 8
(assert (not (and (img@266@01 n$2@397@01) (Set_in (inv@265@01 n$2@397@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
(pop) ; 7
(push) ; 7
; [else-branch: 48 | !(n$2@397@01 in g@257@01 && Lookup(next, sm@395@01, n$2@397@01) != Null)]
(assert (not
  (and
    (Set_in n$2@397@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@395@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef228|)))
(assert (=>
  (and
    (Set_in n$2@397@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))
  (and
    (Set_in n$2@397@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@397@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null))))
  (and
    (Set_in n$2@397@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@395@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@395@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef228|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@397@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@397@01 g@257@01)
      (and
        (Set_in n$2@397@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01)))
    (or (Set_in n$2@397@01 g@257@01) (not (Set_in n$2@397@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@397@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))
      (and
        (Set_in n$2@397@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01)))
    (or
      (not
        (and
          (Set_in n$2@397@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01)
              $Ref.null))))
      (and
        (Set_in n$2@397@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(assert (forall ((n$2@397@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@397@01 g@257@01)
      (and
        (Set_in n$2@397@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01)))
    (or (Set_in n$2@397@01 g@257@01) (not (Set_in n$2@397@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@397@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))
      (and
        (Set_in n$2@397@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01)))
    (or
      (not
        (and
          (Set_in n$2@397@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01)
              $Ref.null))))
      (and
        (Set_in n$2@397@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))))
  :pattern ((Set_in n$2@397@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(push) ; 5
(assert (not (forall ((n$2@397@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@397@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) g@257@01))
  :pattern ((Set_in n$2@397@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@397@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@397@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) g@257@01))
  :pattern ((Set_in n$2@397@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n$2@397@01) n$2@397@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31|)))
; [eval] (last in g)
; [eval] (x in g)
; [eval] (y in g)
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n))
(declare-const n@398@01 $Ref)
(push) ; 5
; [eval] (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 6
; [then-branch: 49 | n@398@01 in g@257@01 | live]
; [else-branch: 49 | !(n@398@01 in g@257@01) | live]
(push) ; 7
; [then-branch: 49 | n@398@01 in g@257@01]
(assert (Set_in n@398@01 g@257@01))
; [eval] exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 8
(declare-const n@399@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@399@01 g@257@01))
(pop) ; 9
(declare-fun inv@400@01 ($Ref) $Ref)
(declare-fun img@401@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@399@01 $Ref) (n2@399@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@399@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n1@399@01) n1@399@01))
      (and
        (Set_in n2@399@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n2@399@01) n2@399@01))
      (= n1@399@01 n2@399@01))
    (= n1@399@01 n2@399@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@399@01 $Ref)) (!
  (=>
    (Set_in n@399@01 g@257@01)
    (and (= (inv@400@01 n@399@01) n@399@01) (img@401@01 n@399@01)))
  :pattern ((Set_in n@399@01 g@257@01))
  :pattern ((inv@400@01 n@399@01))
  :pattern ((img@401@01 n@399@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@401@01 r) (Set_in (inv@400@01 r) g@257@01)) (= (inv@400@01 r) r))
  :pattern ((inv@400@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@400@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
  :pattern ((inv@400@01 r))
  :qid |quant-u-283|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@402@01 ((r $Ref) (n@398@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r) (= r (inv@400@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@402@01 r n@398@01))
    $Perm.No)
  
  :qid |quant-u-285|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r) (= r (inv@400@01 r)))
    (= (- $Perm.Write (pTaken@402@01 r n@398@01)) $Perm.No))
  
  :qid |quant-u-286|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@403@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r)))
    (=>
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>))))
  :qid |qp.fvfDomDef231|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef230|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@399@01 $Ref)) (!
  (=>
    (Set_in n@399@01 g@257@01)
    (and (= (inv@400@01 n@399@01) n@399@01) (img@401@01 n@399@01)))
  :pattern ((Set_in n@399@01 g@257@01))
  :pattern ((inv@400@01 n@399@01))
  :pattern ((img@401@01 n@399@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@401@01 r) (Set_in (inv@400@01 r) g@257@01)) (= (inv@400@01 r) r))
  :pattern ((inv@400@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r)))
    (=>
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>))))
  :qid |qp.fvfDomDef231|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef230|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@400@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
    :pattern ((inv@400@01 r))
    :qid |quant-u-283|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 50 | exists_path[Bool]($$(sm@403@01, g@257@01), x@258@01, n@398@01) | live]
; [else-branch: 50 | !(exists_path[Bool]($$(sm@403@01, g@257@01), x@258@01, n@398@01)) | live]
(push) ; 9
; [then-branch: 50 | exists_path[Bool]($$(sm@403@01, g@257@01), x@258@01, n@398@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
(pop) ; 9
(push) ; 9
; [else-branch: 50 | !(exists_path[Bool]($$(sm@403@01, g@257@01), x@258@01, n@398@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01)))
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 10
(declare-const n@404@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@404@01 g@257@01))
(pop) ; 11
(declare-fun inv@405@01 ($Ref) $Ref)
(declare-fun img@406@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@407@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@407@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef233|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@404@01 $Ref) (n2@404@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@404@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) n1@404@01) n1@404@01))
      (and
        (Set_in n2@404@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) n2@404@01) n2@404@01))
      (= n1@404@01 n2@404@01))
    (= n1@404@01 n2@404@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@404@01 $Ref)) (!
  (=>
    (Set_in n@404@01 g@257@01)
    (and (= (inv@405@01 n@404@01) n@404@01) (img@406@01 n@404@01)))
  :pattern ((Set_in n@404@01 g@257@01))
  :pattern ((inv@405@01 n@404@01))
  :pattern ((img@406@01 n@404@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@406@01 r) (Set_in (inv@405@01 r) g@257@01)) (= (inv@405@01 r) r))
  :pattern ((inv@405@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@405@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
  :pattern ((inv@405@01 r))
  :qid |quant-u-288|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@408@01 ((r $Ref) (n@398@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r) (= r (inv@405@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@408@01 r n@398@01))
    $Perm.No)
  
  :qid |quant-u-290|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r) (= r (inv@405@01 r)))
    (= (- $Perm.Write (pTaken@408@01 r n@398@01)) $Perm.No))
  
  :qid |quant-u-291|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@409@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r)))
    (=>
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>))))
  :qid |qp.fvfDomDef236|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@409@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef235|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@407@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef233|)))
(assert (forall ((n@404@01 $Ref)) (!
  (=>
    (Set_in n@404@01 g@257@01)
    (and (= (inv@405@01 n@404@01) n@404@01) (img@406@01 n@404@01)))
  :pattern ((Set_in n@404@01 g@257@01))
  :pattern ((inv@405@01 n@404@01))
  :pattern ((img@406@01 n@404@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@406@01 r) (Set_in (inv@405@01 r) g@257@01)) (= (inv@405@01 r) r))
  :pattern ((inv@405@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r)))
    (=>
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>))))
  :qid |qp.fvfDomDef236|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@409@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef235|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@405@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
    :pattern ((inv@405@01 r))
    :qid |quant-u-288|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@407@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef233|)))
(assert (forall ((n@404@01 $Ref)) (!
  (=>
    (Set_in n@404@01 g@257@01)
    (and (= (inv@405@01 n@404@01) n@404@01) (img@406@01 n@404@01)))
  :pattern ((Set_in n@404@01 g@257@01))
  :pattern ((inv@405@01 n@404@01))
  :pattern ((img@406@01 n@404@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@406@01 r) (Set_in (inv@405@01 r) g@257@01)) (= (inv@405@01 r) r))
  :pattern ((inv@405@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r)))
    (=>
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>))))
  :qid |qp.fvfDomDef236|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@409@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef235|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@405@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
      :pattern ((inv@405@01 r))
      :qid |quant-u-288|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01)))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 49 | !(n@398@01 in g@257@01)]
(assert (not (Set_in n@398@01 g@257@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((n@399@01 $Ref)) (!
  (=>
    (Set_in n@399@01 g@257@01)
    (and (= (inv@400@01 n@399@01) n@399@01) (img@401@01 n@399@01)))
  :pattern ((Set_in n@399@01 g@257@01))
  :pattern ((inv@400@01 n@399@01))
  :pattern ((img@401@01 n@399@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@401@01 r) (Set_in (inv@400@01 r) g@257@01)) (= (inv@400@01 r) r))
  :pattern ((inv@400@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r)))
    (=>
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>))))
  :qid |qp.fvfDomDef231|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef230|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@407@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef233|)))
(assert (forall ((n@404@01 $Ref)) (!
  (=>
    (Set_in n@404@01 g@257@01)
    (and (= (inv@405@01 n@404@01) n@404@01) (img@406@01 n@404@01)))
  :pattern ((Set_in n@404@01 g@257@01))
  :pattern ((inv@405@01 n@404@01))
  :pattern ((img@406@01 n@404@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@406@01 r) (Set_in (inv@405@01 r) g@257@01)) (= (inv@405@01 r) r))
  :pattern ((inv@405@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r)))
    (=>
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>))))
  :qid |qp.fvfDomDef236|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@409@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef235|)))
(assert (=>
  (Set_in n@398@01 g@257@01)
  (and
    (Set_in n@398@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@400@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
      :pattern ((inv@400@01 r))
      :qid |quant-u-283|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@405@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
          :pattern ((inv@405@01 r))
          :qid |quant-u-288|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01)))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01)))))
; Joined path conditions
(assert (or (not (Set_in n@398@01 g@257@01)) (Set_in n@398@01 g@257@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@399@01 $Ref)) (!
  (=>
    (Set_in n@399@01 g@257@01)
    (and (= (inv@400@01 n@399@01) n@399@01) (img@401@01 n@399@01)))
  :pattern ((Set_in n@399@01 g@257@01))
  :pattern ((inv@400@01 n@399@01))
  :pattern ((img@401@01 n@399@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@401@01 r) (Set_in (inv@400@01 r) g@257@01)) (= (inv@400@01 r) r))
  :pattern ((inv@400@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r)))
    (=>
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@403@01  $FVF<next>))))
  :qid |qp.fvfDomDef231|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@400@01 r) g@257@01) (img@401@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef230|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@407@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@407@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef233|)))
(assert (forall ((n@404@01 $Ref)) (!
  (=>
    (Set_in n@404@01 g@257@01)
    (and (= (inv@405@01 n@404@01) n@404@01) (img@406@01 n@404@01)))
  :pattern ((Set_in n@404@01 g@257@01))
  :pattern ((inv@405@01 n@404@01))
  :pattern ((img@406@01 n@404@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@406@01 r) (Set_in (inv@405@01 r) g@257@01)) (= (inv@405@01 r) r))
  :pattern ((inv@405@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r)))
    (=>
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@409@01  $FVF<next>))))
  :qid |qp.fvfDomDef236|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@405@01 r) g@257@01) (img@406@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@409@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@409@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef235|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@398@01 $Ref)) (!
  (and
    (=>
      (Set_in n@398@01 g@257@01)
      (and
        (Set_in n@398@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@400@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
          :pattern ((inv@400@01 r))
          :qid |quant-u-283|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@405@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
              :pattern ((inv@405@01 r))
              :qid |quant-u-288|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))))
    (or (not (Set_in n@398@01 g@257@01)) (Set_in n@398@01 g@257@01)))
  :pattern ((Set_in n@398@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@398@01 $Ref)) (!
  (and
    (=>
      (Set_in n@398@01 g@257@01)
      (and
        (Set_in n@398@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@400@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
          :pattern ((inv@400@01 r))
          :qid |quant-u-283|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@405@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
              :pattern ((inv@405@01 r))
              :qid |quant-u-288|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))))
    (or (not (Set_in n@398@01 g@257@01)) (Set_in n@398@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@398@01 $Ref)) (!
  (and
    (=>
      (Set_in n@398@01 g@257@01)
      (and
        (Set_in n@398@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@400@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
          :pattern ((inv@400@01 r))
          :qid |quant-u-283|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@405@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@407@01  $FVF<next>) r) r))
              :pattern ((inv@405@01 r))
              :qid |quant-u-288|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))))
    (or (not (Set_in n@398@01 g@257@01)) (Set_in n@398@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01) y@259@01 n@398@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@398@01 $Ref)) (!
  (=>
    (Set_in n@398@01 g@257@01)
    (and
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)
      (=>
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01))))
  :pattern ((Set_in n@398@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01) y@259@01 n@398@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102_precondition|)))
(push) ; 5
(assert (not (forall ((n@398@01 $Ref)) (!
  (=>
    (and
      (=>
        (Set_in n@398@01 g@257@01)
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01)
          (=>
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01))))
      (Set_in n@398@01 g@257@01))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01) y@259@01 n@398@01)))
  :pattern ((Set_in n@398@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01) y@259@01 n@398@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102|))))
(check-sat)
; unsat
(pop) ; 5
; 0,04s
; (get-info :all-statistics)
(assert (forall ((n@398@01 $Ref)) (!
  (=>
    (Set_in n@398@01 g@257@01)
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01) y@259@01 n@398@01)))
  :pattern ((Set_in n@398@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@403@01  $FVF<next>)) g@257@01) x@258@01 n@398@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@409@01  $FVF<next>)) g@257@01) y@259@01 n@398@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102|)))
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n))
(declare-const n@410@01 $Ref)
(push) ; 5
; [eval] (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 6
; [then-branch: 51 | n@410@01 in g@257@01 | live]
; [else-branch: 51 | !(n@410@01 in g@257@01) | live]
(push) ; 7
; [then-branch: 51 | n@410@01 in g@257@01]
(assert (Set_in n@410@01 g@257@01))
; [eval] !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] !exists_path($$(g), x, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 8
(declare-const n@411@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@411@01 g@257@01))
(pop) ; 9
(declare-fun inv@412@01 ($Ref) $Ref)
(declare-fun img@413@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@411@01 $Ref) (n2@411@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@411@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n1@411@01) n1@411@01))
      (and
        (Set_in n2@411@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n2@411@01) n2@411@01))
      (= n1@411@01 n2@411@01))
    (= n1@411@01 n2@411@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@411@01 $Ref)) (!
  (=>
    (Set_in n@411@01 g@257@01)
    (and (= (inv@412@01 n@411@01) n@411@01) (img@413@01 n@411@01)))
  :pattern ((Set_in n@411@01 g@257@01))
  :pattern ((inv@412@01 n@411@01))
  :pattern ((img@413@01 n@411@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@413@01 r) (Set_in (inv@412@01 r) g@257@01)) (= (inv@412@01 r) r))
  :pattern ((inv@412@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@412@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
  :pattern ((inv@412@01 r))
  :qid |quant-u-293|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@414@01 ((r $Ref) (n@410@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r) (= r (inv@412@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@414@01 r n@410@01))
    $Perm.No)
  
  :qid |quant-u-295|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r) (= r (inv@412@01 r)))
    (= (- $Perm.Write (pTaken@414@01 r n@410@01)) $Perm.No))
  
  :qid |quant-u-296|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@415@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r)))
    (=>
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>))))
  :qid |qp.fvfDomDef239|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef237|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef238|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@411@01 $Ref)) (!
  (=>
    (Set_in n@411@01 g@257@01)
    (and (= (inv@412@01 n@411@01) n@411@01) (img@413@01 n@411@01)))
  :pattern ((Set_in n@411@01 g@257@01))
  :pattern ((inv@412@01 n@411@01))
  :pattern ((img@413@01 n@411@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@413@01 r) (Set_in (inv@412@01 r) g@257@01)) (= (inv@412@01 r) r))
  :pattern ((inv@412@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r)))
    (=>
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>))))
  :qid |qp.fvfDomDef239|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef237|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef238|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@412@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
    :pattern ((inv@412@01 r))
    :qid |quant-u-293|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 52 | !(exists_path[Bool]($$(sm@415@01, g@257@01), x@258@01, n@410@01)) | live]
; [else-branch: 52 | exists_path[Bool]($$(sm@415@01, g@257@01), x@258@01, n@410@01) | live]
(push) ; 9
; [then-branch: 52 | !(exists_path[Bool]($$(sm@415@01, g@257@01), x@258@01, n@410@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 52 | exists_path[Bool]($$(sm@415@01, g@257@01), x@258@01, n@410@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
; [eval] !exists_path($$(g), y, n)
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 10
(declare-const n@416@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@416@01 g@257@01))
(pop) ; 11
(declare-fun inv@417@01 ($Ref) $Ref)
(declare-fun img@418@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@419@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@419@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef241|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@416@01 $Ref) (n2@416@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@416@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) n1@416@01) n1@416@01))
      (and
        (Set_in n2@416@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) n2@416@01) n2@416@01))
      (= n1@416@01 n2@416@01))
    (= n1@416@01 n2@416@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@416@01 $Ref)) (!
  (=>
    (Set_in n@416@01 g@257@01)
    (and (= (inv@417@01 n@416@01) n@416@01) (img@418@01 n@416@01)))
  :pattern ((Set_in n@416@01 g@257@01))
  :pattern ((inv@417@01 n@416@01))
  :pattern ((img@418@01 n@416@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@418@01 r) (Set_in (inv@417@01 r) g@257@01)) (= (inv@417@01 r) r))
  :pattern ((inv@417@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@417@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
  :pattern ((inv@417@01 r))
  :qid |quant-u-298|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@420@01 ((r $Ref) (n@410@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r) (= r (inv@417@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@420@01 r n@410@01))
    $Perm.No)
  
  :qid |quant-u-300|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r) (= r (inv@417@01 r)))
    (= (- $Perm.Write (pTaken@420@01 r n@410@01)) $Perm.No))
  
  :qid |quant-u-301|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@421@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r)))
    (=>
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>))))
  :qid |qp.fvfDomDef244|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@421@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef242|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef243|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@419@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef241|)))
(assert (forall ((n@416@01 $Ref)) (!
  (=>
    (Set_in n@416@01 g@257@01)
    (and (= (inv@417@01 n@416@01) n@416@01) (img@418@01 n@416@01)))
  :pattern ((Set_in n@416@01 g@257@01))
  :pattern ((inv@417@01 n@416@01))
  :pattern ((img@418@01 n@416@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@418@01 r) (Set_in (inv@417@01 r) g@257@01)) (= (inv@417@01 r) r))
  :pattern ((inv@417@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r)))
    (=>
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>))))
  :qid |qp.fvfDomDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@421@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef242|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef243|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@417@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
    :pattern ((inv@417@01 r))
    :qid |quant-u-298|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@419@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef241|)))
(assert (forall ((n@416@01 $Ref)) (!
  (=>
    (Set_in n@416@01 g@257@01)
    (and (= (inv@417@01 n@416@01) n@416@01) (img@418@01 n@416@01)))
  :pattern ((Set_in n@416@01 g@257@01))
  :pattern ((inv@417@01 n@416@01))
  :pattern ((img@418@01 n@416@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@418@01 r) (Set_in (inv@417@01 r) g@257@01)) (= (inv@417@01 r) r))
  :pattern ((inv@417@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r)))
    (=>
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>))))
  :qid |qp.fvfDomDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@421@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef242|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef243|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@417@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
      :pattern ((inv@417@01 r))
      :qid |quant-u-298|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 51 | !(n@410@01 in g@257@01)]
(assert (not (Set_in n@410@01 g@257@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((n@411@01 $Ref)) (!
  (=>
    (Set_in n@411@01 g@257@01)
    (and (= (inv@412@01 n@411@01) n@411@01) (img@413@01 n@411@01)))
  :pattern ((Set_in n@411@01 g@257@01))
  :pattern ((inv@412@01 n@411@01))
  :pattern ((img@413@01 n@411@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@413@01 r) (Set_in (inv@412@01 r) g@257@01)) (= (inv@412@01 r) r))
  :pattern ((inv@412@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r)))
    (=>
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>))))
  :qid |qp.fvfDomDef239|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef237|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef238|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@419@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef241|)))
(assert (forall ((n@416@01 $Ref)) (!
  (=>
    (Set_in n@416@01 g@257@01)
    (and (= (inv@417@01 n@416@01) n@416@01) (img@418@01 n@416@01)))
  :pattern ((Set_in n@416@01 g@257@01))
  :pattern ((inv@417@01 n@416@01))
  :pattern ((img@418@01 n@416@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@418@01 r) (Set_in (inv@417@01 r) g@257@01)) (= (inv@417@01 r) r))
  :pattern ((inv@417@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r)))
    (=>
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>))))
  :qid |qp.fvfDomDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@421@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef242|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef243|)))
(assert (=>
  (Set_in n@410@01 g@257@01)
  (and
    (Set_in n@410@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@412@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
      :pattern ((inv@412@01 r))
      :qid |quant-u-293|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@417@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
          :pattern ((inv@417@01 r))
          :qid |quant-u-298|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))))))
; Joined path conditions
(assert (or (not (Set_in n@410@01 g@257@01)) (Set_in n@410@01 g@257@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@411@01 $Ref)) (!
  (=>
    (Set_in n@411@01 g@257@01)
    (and (= (inv@412@01 n@411@01) n@411@01) (img@413@01 n@411@01)))
  :pattern ((Set_in n@411@01 g@257@01))
  :pattern ((inv@412@01 n@411@01))
  :pattern ((img@413@01 n@411@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@413@01 r) (Set_in (inv@412@01 r) g@257@01)) (= (inv@412@01 r) r))
  :pattern ((inv@412@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r)))
    (=>
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@415@01  $FVF<next>))))
  :qid |qp.fvfDomDef239|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@412@01 r) g@257@01) (img@413@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef237|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef238|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@419@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@419@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef241|)))
(assert (forall ((n@416@01 $Ref)) (!
  (=>
    (Set_in n@416@01 g@257@01)
    (and (= (inv@417@01 n@416@01) n@416@01) (img@418@01 n@416@01)))
  :pattern ((Set_in n@416@01 g@257@01))
  :pattern ((inv@417@01 n@416@01))
  :pattern ((img@418@01 n@416@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@418@01 r) (Set_in (inv@417@01 r) g@257@01)) (= (inv@417@01 r) r))
  :pattern ((inv@417@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r)))
    (=>
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@421@01  $FVF<next>))))
  :qid |qp.fvfDomDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@417@01 r) g@257@01) (img@418@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@421@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef242|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@421@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef243|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@410@01 $Ref)) (!
  (and
    (=>
      (Set_in n@410@01 g@257@01)
      (and
        (Set_in n@410@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@412@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
          :pattern ((inv@412@01 r))
          :qid |quant-u-293|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@417@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
              :pattern ((inv@417@01 r))
              :qid |quant-u-298|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)))))
    (or (not (Set_in n@410@01 g@257@01)) (Set_in n@410@01 g@257@01)))
  :pattern ((Set_in n@410@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@410@01 $Ref)) (!
  (and
    (=>
      (Set_in n@410@01 g@257@01)
      (and
        (Set_in n@410@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@412@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
          :pattern ((inv@412@01 r))
          :qid |quant-u-293|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@417@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
              :pattern ((inv@417@01 r))
              :qid |quant-u-298|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)))))
    (or (not (Set_in n@410@01 g@257@01)) (Set_in n@410@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@410@01 $Ref)) (!
  (and
    (=>
      (Set_in n@410@01 g@257@01)
      (and
        (Set_in n@410@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@412@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
          :pattern ((inv@412@01 r))
          :qid |quant-u-293|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@417@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@419@01  $FVF<next>) r) r))
              :pattern ((inv@417@01 r))
              :qid |quant-u-298|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)))))
    (or (not (Set_in n@410@01 g@257@01)) (Set_in n@410@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01) y@259@01 n@410@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@410@01 $Ref)) (!
  (=>
    (Set_in n@410@01 g@257@01)
    (and
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)
      (=>
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01))))
  :pattern ((Set_in n@410@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01) y@259@01 n@410@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102_precondition|)))
(push) ; 5
(assert (not (forall ((n@410@01 $Ref)) (!
  (=>
    (and
      (=>
        (Set_in n@410@01 g@257@01)
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01)
          (=>
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01)
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01))))
      (Set_in n@410@01 g@257@01))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01) y@259@01 n@410@01))))
  :pattern ((Set_in n@410@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01) y@259@01 n@410@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102|))))
(check-sat)
; unsat
(pop) ; 5
; 0,06s
; (get-info :all-statistics)
(assert (forall ((n@410@01 $Ref)) (!
  (=>
    (Set_in n@410@01 g@257@01)
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01) y@259@01 n@410@01))))
  :pattern ((Set_in n@410@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@415@01  $FVF<next>)) g@257@01) x@258@01 n@410@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@421@01  $FVF<next>)) g@257@01) y@259@01 n@410@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102|)))
; [eval] acyclic_graph($$(g))
; [eval] $$(g)
(push) ; 5
(declare-const n@422@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@422@01 g@257@01))
(pop) ; 6
(declare-fun inv@423@01 ($Ref) $Ref)
(declare-fun img@424@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@422@01 $Ref) (n2@422@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@422@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n1@422@01) n1@422@01))
      (and
        (Set_in n2@422@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) n2@422@01) n2@422@01))
      (= n1@422@01 n2@422@01))
    (= n1@422@01 n2@422@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@422@01 $Ref)) (!
  (=>
    (Set_in n@422@01 g@257@01)
    (and (= (inv@423@01 n@422@01) n@422@01) (img@424@01 n@422@01)))
  :pattern ((Set_in n@422@01 g@257@01))
  :pattern ((inv@423@01 n@422@01))
  :pattern ((img@424@01 n@422@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@424@01 r) (Set_in (inv@423@01 r) g@257@01)) (= (inv@423@01 r) r))
  :pattern ((inv@423@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@423@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
  :pattern ((inv@423@01 r))
  :qid |quant-u-303|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@425@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r) (= r (inv@423@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@425@01 r))
    $Perm.No)
  
  :qid |quant-u-305|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r) (= r (inv@423@01 r)))
    (= (- $Perm.Write (pTaken@425@01 r)) $Perm.No))
  
  :qid |quant-u-306|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@426@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@426@01  $FVF<next>)))
      (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r)))
    (=>
      (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r))
      (Set_in r ($FVF.domain_next (as sm@426@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@426@01  $FVF<next>))))
  :qid |qp.fvfDomDef247|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@426@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@426@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef245|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@426@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef246|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@426@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@422@01 $Ref)) (!
  (=>
    (Set_in n@422@01 g@257@01)
    (and (= (inv@423@01 n@422@01) n@422@01) (img@424@01 n@422@01)))
  :pattern ((Set_in n@422@01 g@257@01))
  :pattern ((inv@423@01 n@422@01))
  :pattern ((img@424@01 n@422@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@424@01 r) (Set_in (inv@423@01 r) g@257@01)) (= (inv@423@01 r) r))
  :pattern ((inv@423@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@426@01  $FVF<next>)))
      (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r)))
    (=>
      (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r))
      (Set_in r ($FVF.domain_next (as sm@426@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@426@01  $FVF<next>))))
  :qid |qp.fvfDomDef247|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@423@01 r) g@257@01) (img@424@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@426@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@426@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef245|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@426@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef246|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@423@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@395@01  $FVF<next>) r) r))
    :pattern ((inv@423@01 r))
    :qid |quant-u-303|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@426@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 5
(assert (not (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@426@01  $FVF<next>)) g@257@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,03s
; (get-info :all-statistics)
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@426@01  $FVF<next>)) g@257@01)))
; [eval] unshared_graph($$(g))
; [eval] $$(g)
(push) ; 5
(declare-const n@427@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@427@01 g@257@01))
(pop) ; 6
(declare-fun inv@428@01 ($Ref) $Ref)
(declare-fun img@429@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@430@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@430@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@430@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef248|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@430@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef249|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@427@01 $Ref) (n2@427@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@427@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@430@01  $FVF<next>) n1@427@01) n1@427@01))
      (and
        (Set_in n2@427@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@430@01  $FVF<next>) n2@427@01) n2@427@01))
      (= n1@427@01 n2@427@01))
    (= n1@427@01 n2@427@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@427@01 $Ref)) (!
  (=>
    (Set_in n@427@01 g@257@01)
    (and (= (inv@428@01 n@427@01) n@427@01) (img@429@01 n@427@01)))
  :pattern ((Set_in n@427@01 g@257@01))
  :pattern ((inv@428@01 n@427@01))
  :pattern ((img@429@01 n@427@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@429@01 r) (Set_in (inv@428@01 r) g@257@01)) (= (inv@428@01 r) r))
  :pattern ((inv@428@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@428@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@430@01  $FVF<next>) r) r))
  :pattern ((inv@428@01 r))
  :qid |quant-u-308|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@431@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r) (= r (inv@428@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@431@01 r))
    $Perm.No)
  
  :qid |quant-u-310|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r) (= r (inv@428@01 r)))
    (= (- $Perm.Write (pTaken@431@01 r)) $Perm.No))
  
  :qid |quant-u-311|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@432@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@432@01  $FVF<next>)))
      (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r)))
    (=>
      (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r))
      (Set_in r ($FVF.domain_next (as sm@432@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@432@01  $FVF<next>))))
  :qid |qp.fvfDomDef252|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@432@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@432@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef250|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@432@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef251|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@432@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@430@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@430@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef248|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@430@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef249|)))
(assert (forall ((n@427@01 $Ref)) (!
  (=>
    (Set_in n@427@01 g@257@01)
    (and (= (inv@428@01 n@427@01) n@427@01) (img@429@01 n@427@01)))
  :pattern ((Set_in n@427@01 g@257@01))
  :pattern ((inv@428@01 n@427@01))
  :pattern ((img@429@01 n@427@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@429@01 r) (Set_in (inv@428@01 r) g@257@01)) (= (inv@428@01 r) r))
  :pattern ((inv@428@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@432@01  $FVF<next>)))
      (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r)))
    (=>
      (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r))
      (Set_in r ($FVF.domain_next (as sm@432@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@432@01  $FVF<next>))))
  :qid |qp.fvfDomDef252|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@428@01 r) g@257@01) (img@429@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@432@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@432@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef250|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@432@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef251|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@428@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@430@01  $FVF<next>) r) r))
    :pattern ((inv@428@01 r))
    :qid |quant-u-308|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@432@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 5
(assert (not (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@432@01  $FVF<next>)) g@257@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,06s
; (get-info :all-statistics)
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@432@01  $FVF<next>)) g@257@01)))
; [eval] $$(g) == old_g
; [eval] $$(g)
(push) ; 5
(declare-const n@433@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@433@01 g@257@01))
(pop) ; 6
(declare-fun inv@434@01 ($Ref) $Ref)
(declare-fun img@435@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@436@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@436@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef254|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@433@01 $Ref) (n2@433@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@433@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@436@01  $FVF<next>) n1@433@01) n1@433@01))
      (and
        (Set_in n2@433@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@436@01  $FVF<next>) n2@433@01) n2@433@01))
      (= n1@433@01 n2@433@01))
    (= n1@433@01 n2@433@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@433@01 $Ref)) (!
  (=>
    (Set_in n@433@01 g@257@01)
    (and (= (inv@434@01 n@433@01) n@433@01) (img@435@01 n@433@01)))
  :pattern ((Set_in n@433@01 g@257@01))
  :pattern ((inv@434@01 n@433@01))
  :pattern ((img@435@01 n@433@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@435@01 r) (Set_in (inv@434@01 r) g@257@01)) (= (inv@434@01 r) r))
  :pattern ((inv@434@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@434@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@436@01  $FVF<next>) r) r))
  :pattern ((inv@434@01 r))
  :qid |quant-u-313|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@437@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r) (= r (inv@434@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@437@01 r))
    $Perm.No)
  
  :qid |quant-u-315|))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r) (= r (inv@434@01 r)))
    (= (- $Perm.Write (pTaken@437@01 r)) $Perm.No))
  
  :qid |quant-u-316|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@438@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@438@01  $FVF<next>)))
      (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r)))
    (=>
      (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r))
      (Set_in r ($FVF.domain_next (as sm@438@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@438@01  $FVF<next>))))
  :qid |qp.fvfDomDef257|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef256|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@438@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@436@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef254|)))
(assert (forall ((n@433@01 $Ref)) (!
  (=>
    (Set_in n@433@01 g@257@01)
    (and (= (inv@434@01 n@433@01) n@433@01) (img@435@01 n@433@01)))
  :pattern ((Set_in n@433@01 g@257@01))
  :pattern ((inv@434@01 n@433@01))
  :pattern ((img@435@01 n@433@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@435@01 r) (Set_in (inv@434@01 r) g@257@01)) (= (inv@434@01 r) r))
  :pattern ((inv@434@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@438@01  $FVF<next>)))
      (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r)))
    (=>
      (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r))
      (Set_in r ($FVF.domain_next (as sm@438@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@438@01  $FVF<next>))))
  :qid |qp.fvfDomDef257|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@434@01 r) g@257@01) (img@435@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef256|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@434@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@436@01  $FVF<next>) r) r))
    :pattern ((inv@434@01 r))
    :qid |quant-u-313|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@438@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 5
(assert (not (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@438@01  $FVF<next>)) g@257@01) old_g@317@01)))
(check-sat)
; unsat
(pop) ; 5
; 0,05s
; (get-info :all-statistics)
(assert (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@438@01  $FVF<next>)) g@257@01) old_g@317@01))
; [eval] exists_path($$(g), x, last)
; [eval] $$(g)
(push) ; 5
(declare-const n@439@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@439@01 g@257@01))
(pop) ; 6
(declare-fun inv@440@01 ($Ref) $Ref)
(declare-fun img@441@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@442@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@442@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@442@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef258|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@442@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef259|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@439@01 $Ref) (n2@439@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@439@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@442@01  $FVF<next>) n1@439@01) n1@439@01))
      (and
        (Set_in n2@439@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@442@01  $FVF<next>) n2@439@01) n2@439@01))
      (= n1@439@01 n2@439@01))
    (= n1@439@01 n2@439@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@439@01 $Ref)) (!
  (=>
    (Set_in n@439@01 g@257@01)
    (and (= (inv@440@01 n@439@01) n@439@01) (img@441@01 n@439@01)))
  :pattern ((Set_in n@439@01 g@257@01))
  :pattern ((inv@440@01 n@439@01))
  :pattern ((img@441@01 n@439@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@441@01 r) (Set_in (inv@440@01 r) g@257@01)) (= (inv@440@01 r) r))
  :pattern ((inv@440@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@440@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@442@01  $FVF<next>) r) r))
  :pattern ((inv@440@01 r))
  :qid |quant-u-318|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@443@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r) (= r (inv@440@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@443@01 r))
    $Perm.No)
  
  :qid |quant-u-320|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r) (= r (inv@440@01 r)))
    (= (- $Perm.Write (pTaken@443@01 r)) $Perm.No))
  
  :qid |quant-u-321|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@444@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@444@01  $FVF<next>)))
      (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r)))
    (=>
      (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r))
      (Set_in r ($FVF.domain_next (as sm@444@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@444@01  $FVF<next>))))
  :qid |qp.fvfDomDef262|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@444@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@444@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef260|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@444@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef261|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@444@01  $FVF<next>)) g@257@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@442@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@442@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef258|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@442@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef259|)))
(assert (forall ((n@439@01 $Ref)) (!
  (=>
    (Set_in n@439@01 g@257@01)
    (and (= (inv@440@01 n@439@01) n@439@01) (img@441@01 n@439@01)))
  :pattern ((Set_in n@439@01 g@257@01))
  :pattern ((inv@440@01 n@439@01))
  :pattern ((img@441@01 n@439@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@441@01 r) (Set_in (inv@440@01 r) g@257@01)) (= (inv@440@01 r) r))
  :pattern ((inv@440@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@444@01  $FVF<next>)))
      (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r)))
    (=>
      (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r))
      (Set_in r ($FVF.domain_next (as sm@444@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@444@01  $FVF<next>))))
  :qid |qp.fvfDomDef262|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@440@01 r) g@257@01) (img@441@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@444@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@444@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef260|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@444@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef261|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@440@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@442@01  $FVF<next>) r) r))
    :pattern ((inv@440@01 r))
    :qid |quant-u-318|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@444@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 5
(assert (not (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@444@01  $FVF<next>)) g@257@01) x@258@01 x@258@01)))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@444@01  $FVF<next>)) g@257@01) x@258@01 x@258@01))
; [eval] last.next != null ==> edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next) ==> exists_path($$(g), last, last.next)
; [eval] last.next != null
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) x@258@01))
(push) ; 5
(assert (not (and (img@266@01 x@258@01) (Set_in (inv@265@01 x@258@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
    $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; [then-branch: 53 | Lookup(next, First:(Second:($t@262@01)), x@258@01) != Null | live]
; [else-branch: 53 | Lookup(next, First:(Second:($t@262@01)), x@258@01) == Null | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 53 | Lookup(next, First:(Second:($t@262@01)), x@258@01) != Null]
(assert (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
    $Ref.null)))
; [eval] edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next) ==> exists_path($$(g), last, last.next)
; [eval] edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next)
; [eval] edge($$(g), last, last.next)
; [eval] $$(g)
(push) ; 7
(declare-const n@445@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@445@01 g@257@01))
(pop) ; 8
(declare-fun inv@446@01 ($Ref) $Ref)
(declare-fun img@447@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@448@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@448@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@448@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@448@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef264|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@445@01 $Ref) (n2@445@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@445@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@448@01  $FVF<next>) n1@445@01) n1@445@01))
      (and
        (Set_in n2@445@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@448@01  $FVF<next>) n2@445@01) n2@445@01))
      (= n1@445@01 n2@445@01))
    (= n1@445@01 n2@445@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@445@01 $Ref)) (!
  (=>
    (Set_in n@445@01 g@257@01)
    (and (= (inv@446@01 n@445@01) n@445@01) (img@447@01 n@445@01)))
  :pattern ((Set_in n@445@01 g@257@01))
  :pattern ((inv@446@01 n@445@01))
  :pattern ((img@447@01 n@445@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@447@01 r) (Set_in (inv@446@01 r) g@257@01)) (= (inv@446@01 r) r))
  :pattern ((inv@446@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@446@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@448@01  $FVF<next>) r) r))
  :pattern ((inv@446@01 r))
  :qid |quant-u-323|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@449@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r) (= r (inv@446@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@449@01 r))
    $Perm.No)
  
  :qid |quant-u-325|))))
(check-sat)
; unsat
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r) (= r (inv@446@01 r)))
    (= (- $Perm.Write (pTaken@449@01 r)) $Perm.No))
  
  :qid |quant-u-326|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@450@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>)))
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r)))
    (=>
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r))
      (Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>))))
  :qid |qp.fvfDomDef267|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@450@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@450@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@450@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef266|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@448@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@448@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@448@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef264|)))
(assert (forall ((n@445@01 $Ref)) (!
  (=>
    (Set_in n@445@01 g@257@01)
    (and (= (inv@446@01 n@445@01) n@445@01) (img@447@01 n@445@01)))
  :pattern ((Set_in n@445@01 g@257@01))
  :pattern ((inv@446@01 n@445@01))
  :pattern ((img@447@01 n@445@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@447@01 r) (Set_in (inv@446@01 r) g@257@01)) (= (inv@446@01 r) r))
  :pattern ((inv@446@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>)))
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r)))
    (=>
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r))
      (Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>))))
  :qid |qp.fvfDomDef267|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@450@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@450@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@450@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef266|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@446@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@448@01  $FVF<next>) r) r))
    :pattern ((inv@446@01 r))
    :qid |quant-u-323|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 7
(assert (not (and (img@266@01 x@258@01) (Set_in (inv@265@01 x@258@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(push) ; 7
; [then-branch: 54 | !(edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01))) | live]
; [else-branch: 54 | edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01)) | live]
(push) ; 8
; [then-branch: 54 | !(edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01)))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
(pop) ; 8
(push) ; 8
; [else-branch: 54 | edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01))]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))
; [eval] exists_path($$(g), last.next, last.next)
; [eval] $$(g)
(push) ; 9
(declare-const n@451@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@451@01 g@257@01))
(pop) ; 10
(declare-fun inv@452@01 ($Ref) $Ref)
(declare-fun img@453@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@454@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@454@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef268|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef269|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@451@01 $Ref) (n2@451@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@451@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@454@01  $FVF<next>) n1@451@01) n1@451@01))
      (and
        (Set_in n2@451@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@454@01  $FVF<next>) n2@451@01) n2@451@01))
      (= n1@451@01 n2@451@01))
    (= n1@451@01 n2@451@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@451@01 $Ref)) (!
  (=>
    (Set_in n@451@01 g@257@01)
    (and (= (inv@452@01 n@451@01) n@451@01) (img@453@01 n@451@01)))
  :pattern ((Set_in n@451@01 g@257@01))
  :pattern ((inv@452@01 n@451@01))
  :pattern ((img@453@01 n@451@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@453@01 r) (Set_in (inv@452@01 r) g@257@01)) (= (inv@452@01 r) r))
  :pattern ((inv@452@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@452@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@454@01  $FVF<next>) r) r))
  :pattern ((inv@452@01 r))
  :qid |quant-u-328|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@455@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r) (= r (inv@452@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@455@01 r))
    $Perm.No)
  
  :qid |quant-u-330|))))
(check-sat)
; unsat
(pop) ; 10
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r) (= r (inv@452@01 r)))
    (= (- $Perm.Write (pTaken@455@01 r)) $Perm.No))
  
  :qid |quant-u-331|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@456@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r)))
    (=>
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>))))
  :qid |qp.fvfDomDef272|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@456@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef271|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@454@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef268|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef269|)))
(assert (forall ((n@451@01 $Ref)) (!
  (=>
    (Set_in n@451@01 g@257@01)
    (and (= (inv@452@01 n@451@01) n@451@01) (img@453@01 n@451@01)))
  :pattern ((Set_in n@451@01 g@257@01))
  :pattern ((inv@452@01 n@451@01))
  :pattern ((img@453@01 n@451@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@453@01 r) (Set_in (inv@452@01 r) g@257@01)) (= (inv@452@01 r) r))
  :pattern ((inv@452@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r)))
    (=>
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>))))
  :qid |qp.fvfDomDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@456@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef271|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@452@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@454@01  $FVF<next>) r) r))
    :pattern ((inv@452@01 r))
    :qid |quant-u-328|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 9
(assert (not (and (img@266@01 x@258@01) (Set_in (inv@265@01 x@258@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(push) ; 9
(assert (not (and (img@266@01 x@258@01) (Set_in (inv@265@01 x@258@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@454@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef268|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef269|)))
(assert (forall ((n@451@01 $Ref)) (!
  (=>
    (Set_in n@451@01 g@257@01)
    (and (= (inv@452@01 n@451@01) n@451@01) (img@453@01 n@451@01)))
  :pattern ((Set_in n@451@01 g@257@01))
  :pattern ((inv@452@01 n@451@01))
  :pattern ((img@453@01 n@451@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@453@01 r) (Set_in (inv@452@01 r) g@257@01)) (= (inv@452@01 r) r))
  :pattern ((inv@452@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r)))
    (=>
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>))))
  :qid |qp.fvfDomDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@456@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef271|)))
(assert (=>
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@452@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@454@01  $FVF<next>) r) r))
      :pattern ((inv@452@01 r))
      :qid |quant-u-328|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01))))
(assert (or
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; [then-branch: 55 | edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01)) && exists_path[Bool]($$(sm@456@01, g@257@01), Lookup(next, First:(Second:($t@262@01)), x@258@01), Lookup(next, First:(Second:($t@262@01)), x@258@01)) | live]
; [else-branch: 55 | !(edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01)) && exists_path[Bool]($$(sm@456@01, g@257@01), Lookup(next, First:(Second:($t@262@01)), x@258@01), Lookup(next, First:(Second:($t@262@01)), x@258@01))) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 55 | edge[Bool]($$(sm@450@01, g@257@01), x@258@01, Lookup(next, First:(Second:($t@262@01)), x@258@01)) && exists_path[Bool]($$(sm@456@01, g@257@01), Lookup(next, First:(Second:($t@262@01)), x@258@01), Lookup(next, First:(Second:($t@262@01)), x@258@01))]
(assert (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
; [eval] exists_path($$(g), last, last.next)
; [eval] $$(g)
(push) ; 9
(declare-const n@457@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@457@01 g@257@01))
(pop) ; 10
(declare-fun inv@458@01 ($Ref) $Ref)
(declare-fun img@459@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@460@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@460@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@457@01 $Ref) (n2@457@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@457@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@460@01  $FVF<next>) n1@457@01) n1@457@01))
      (and
        (Set_in n2@457@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@460@01  $FVF<next>) n2@457@01) n2@457@01))
      (= n1@457@01 n2@457@01))
    (= n1@457@01 n2@457@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@457@01 $Ref)) (!
  (=>
    (Set_in n@457@01 g@257@01)
    (and (= (inv@458@01 n@457@01) n@457@01) (img@459@01 n@457@01)))
  :pattern ((Set_in n@457@01 g@257@01))
  :pattern ((inv@458@01 n@457@01))
  :pattern ((img@459@01 n@457@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@459@01 r) (Set_in (inv@458@01 r) g@257@01)) (= (inv@458@01 r) r))
  :pattern ((inv@458@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@458@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@460@01  $FVF<next>) r) r))
  :pattern ((inv@458@01 r))
  :qid |quant-u-333|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@461@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r) (= r (inv@458@01 r)))
    ($Perm.min
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@461@01 r))
    $Perm.No)
  
  :qid |quant-u-335|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r) (= r (inv@458@01 r)))
    (= (- $Perm.Write (pTaken@461@01 r)) $Perm.No))
  
  :qid |quant-u-336|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@462@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r)))
    (=>
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>))))
  :qid |qp.fvfDomDef277|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@462@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef275|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef276|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@462@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@460@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (forall ((n@457@01 $Ref)) (!
  (=>
    (Set_in n@457@01 g@257@01)
    (and (= (inv@458@01 n@457@01) n@457@01) (img@459@01 n@457@01)))
  :pattern ((Set_in n@457@01 g@257@01))
  :pattern ((inv@458@01 n@457@01))
  :pattern ((img@459@01 n@457@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@459@01 r) (Set_in (inv@458@01 r) g@257@01)) (= (inv@458@01 r) r))
  :pattern ((inv@458@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r)))
    (=>
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>))))
  :qid |qp.fvfDomDef277|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@462@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef275|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef276|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@458@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@460@01  $FVF<next>) r) r))
    :pattern ((inv@458@01 r))
    :qid |quant-u-333|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@462@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 9
(assert (not (and (img@266@01 x@258@01) (Set_in (inv@265@01 x@258@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@460@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (forall ((n@457@01 $Ref)) (!
  (=>
    (Set_in n@457@01 g@257@01)
    (and (= (inv@458@01 n@457@01) n@457@01) (img@459@01 n@457@01)))
  :pattern ((Set_in n@457@01 g@257@01))
  :pattern ((inv@458@01 n@457@01))
  :pattern ((img@459@01 n@457@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@459@01 r) (Set_in (inv@458@01 r) g@257@01)) (= (inv@458@01 r) r))
  :pattern ((inv@458@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r)))
    (=>
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>))))
  :qid |qp.fvfDomDef277|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@462@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef275|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef276|)))
(assert (=>
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@458@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@460@01  $FVF<next>) r) r))
      :pattern ((inv@458@01 r))
      :qid |quant-u-333|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@462@01  $FVF<next>)) g@257@01))))
(assert (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 53 | Lookup(next, First:(Second:($t@262@01)), x@258@01) == Null]
(assert (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
  $Ref.null))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@448@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@448@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@448@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef264|)))
(assert (forall ((n@445@01 $Ref)) (!
  (=>
    (Set_in n@445@01 g@257@01)
    (and (= (inv@446@01 n@445@01) n@445@01) (img@447@01 n@445@01)))
  :pattern ((Set_in n@445@01 g@257@01))
  :pattern ((inv@446@01 n@445@01))
  :pattern ((img@447@01 n@445@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@447@01 r) (Set_in (inv@446@01 r) g@257@01)) (= (inv@446@01 r) r))
  :pattern ((inv@446@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>)))
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r)))
    (=>
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r))
      (Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@450@01  $FVF<next>))))
  :qid |qp.fvfDomDef267|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@446@01 r) g@257@01) (img@447@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@450@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@450@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@450@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef266|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@454@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef268|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@454@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef269|)))
(assert (forall ((n@451@01 $Ref)) (!
  (=>
    (Set_in n@451@01 g@257@01)
    (and (= (inv@452@01 n@451@01) n@451@01) (img@453@01 n@451@01)))
  :pattern ((Set_in n@451@01 g@257@01))
  :pattern ((inv@452@01 n@451@01))
  :pattern ((img@453@01 n@451@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@453@01 r) (Set_in (inv@452@01 r) g@257@01)) (= (inv@452@01 r) r))
  :pattern ((inv@452@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r)))
    (=>
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@456@01  $FVF<next>))))
  :qid |qp.fvfDomDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@452@01 r) g@257@01) (img@453@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@456@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef270|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@456@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef271|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@460@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@460@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (forall ((n@457@01 $Ref)) (!
  (=>
    (Set_in n@457@01 g@257@01)
    (and (= (inv@458@01 n@457@01) n@457@01) (img@459@01 n@457@01)))
  :pattern ((Set_in n@457@01 g@257@01))
  :pattern ((inv@458@01 n@457@01))
  :pattern ((img@459@01 n@457@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@459@01 r) (Set_in (inv@458@01 r) g@257@01)) (= (inv@458@01 r) r))
  :pattern ((inv@458@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r)))
    (=>
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@462@01  $FVF<next>))))
  :qid |qp.fvfDomDef277|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@458@01 r) g@257@01) (img@459@01 r))
      (and (img@266@01 r) (Set_in (inv@265@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@462@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r)))
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r))
  :qid |qp.fvfValDef275|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@462@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef276|)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
      $Ref.null))
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
        $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@446@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@448@01  $FVF<next>) r) r))
      :pattern ((inv@446@01 r))
      :qid |quant-u-323|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01)
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@452@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@454@01  $FVF<next>) r) r))
          :pattern ((inv@452@01 r))
          :qid |quant-u-328|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01)))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
    (=>
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@458@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@460@01  $FVF<next>) r) r))
          :pattern ((inv@458@01 r))
          :qid |quant-u-333|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@462@01  $FVF<next>)) g@257@01)))
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))))
; Joined path conditions
(assert (or
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
    $Ref.null)
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
      $Ref.null))))
(push) ; 5
(assert (not (=>
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
        $Ref.null))
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@462@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)))))
(check-sat)
; unsat
(pop) ; 5
; 0,11s
; (get-info :all-statistics)
(assert (=>
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01)
        $Ref.null))
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@450@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@456@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@462@01  $FVF<next>)) g@257@01) x@258@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@262@01))) x@258@01))))
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 5
(assert (forall ((r $Ref)) (!
  (=> (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)) (= (inv@322@01 r) r))
  :pattern ((inv@322@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((n@327@01 $Ref)) (!
  (=>
    (Set_in n@327@01 g@257@01)
    (and (= (inv@328@01 n@327@01) n@327@01) (img@329@01 n@327@01)))
  :pattern ((Set_in n@327@01 g@257@01))
  :pattern ((inv@328@01 n@327@01))
  :pattern ((img@329@01 n@327@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@329@01 r) (Set_in (inv@328@01 r) g@257@01)) (= (inv@328@01 r) r))
  :pattern ((inv@328@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r)))
    (=>
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@331@01  $FVF<next>))))
  :qid |qp.fvfDomDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@328@01 r) g@257@01) (img@329@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@331@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@331@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@335@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@335@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((n@332@01 $Ref)) (!
  (=>
    (Set_in n@332@01 g@257@01)
    (and (= (inv@333@01 n@332@01) n@332@01) (img@334@01 n@332@01)))
  :pattern ((Set_in n@332@01 g@257@01))
  :pattern ((inv@333@01 n@332@01))
  :pattern ((img@334@01 n@332@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@334@01 r) (Set_in (inv@333@01 r) g@257@01)) (= (inv@333@01 r) r))
  :pattern ((inv@333@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r)))
    (=>
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@337@01  $FVF<next>))))
  :qid |qp.fvfDomDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@333@01 r) g@257@01) (img@334@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@337@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@337@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
(assert (forall ((n@339@01 $Ref)) (!
  (=>
    (Set_in n@339@01 g@257@01)
    (and (= (inv@340@01 n@339@01) n@339@01) (img@341@01 n@339@01)))
  :pattern ((Set_in n@339@01 g@257@01))
  :pattern ((inv@340@01 n@339@01))
  :pattern ((img@341@01 n@339@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@341@01 r) (Set_in (inv@340@01 r) g@257@01)) (= (inv@340@01 r) r))
  :pattern ((inv@340@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r)))
    (=>
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@340@01 r) g@257@01) (img@341@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@347@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@347@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@344@01 $Ref)) (!
  (=>
    (Set_in n@344@01 g@257@01)
    (and (= (inv@345@01 n@344@01) n@344@01) (img@346@01 n@344@01)))
  :pattern ((Set_in n@344@01 g@257@01))
  :pattern ((inv@345@01 n@344@01))
  :pattern ((img@346@01 n@344@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@346@01 r) (Set_in (inv@345@01 r) g@257@01)) (= (inv@345@01 r) r))
  :pattern ((inv@345@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r)))
    (=>
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@349@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@345@01 r) g@257@01) (img@346@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@349@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@349@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (forall ((n@350@01 $Ref)) (!
  (=>
    (Set_in n@350@01 g@257@01)
    (and (= (inv@351@01 n@350@01) n@350@01) (img@352@01 n@350@01)))
  :pattern ((Set_in n@350@01 g@257@01))
  :pattern ((inv@351@01 n@350@01))
  :pattern ((img@352@01 n@350@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@352@01 r) (Set_in (inv@351@01 r) g@257@01)) (= (inv@351@01 r) r))
  :pattern ((inv@351@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>)))
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r)))
    (=>
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r))
      (Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@354@01  $FVF<next>))))
  :qid |qp.fvfDomDef194|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@351@01 r) g@257@01) (img@352@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@354@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@354@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@354@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@358@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@358@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef195|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@358@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef196|)))
(assert (forall ((n@355@01 $Ref)) (!
  (=>
    (Set_in n@355@01 g@257@01)
    (and (= (inv@356@01 n@355@01) n@355@01) (img@357@01 n@355@01)))
  :pattern ((Set_in n@355@01 g@257@01))
  :pattern ((inv@356@01 n@355@01))
  :pattern ((img@357@01 n@355@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@357@01 r) (Set_in (inv@356@01 r) g@257@01)) (= (inv@356@01 r) r))
  :pattern ((inv@356@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>)))
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r)))
    (=>
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r))
      (Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@360@01  $FVF<next>))))
  :qid |qp.fvfDomDef199|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@356@01 r) g@257@01) (img@357@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef198|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@364@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@364@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef200|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@364@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef201|)))
(assert (forall ((n@361@01 $Ref)) (!
  (=>
    (Set_in n@361@01 g@257@01)
    (and (= (inv@362@01 n@361@01) n@361@01) (img@363@01 n@361@01)))
  :pattern ((Set_in n@361@01 g@257@01))
  :pattern ((inv@362@01 n@361@01))
  :pattern ((img@363@01 n@361@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@363@01 r) (Set_in (inv@362@01 r) g@257@01)) (= (inv@362@01 r) r))
  :pattern ((inv@362@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r)))
    (=>
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r))
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>))))
  :qid |qp.fvfDomDef204|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@362@01 r) g@257@01) (img@363@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@366@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef203|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@370@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@370@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@370@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef206|)))
(assert (forall ((n@367@01 $Ref)) (!
  (=>
    (Set_in n@367@01 g@257@01)
    (and (= (inv@368@01 n@367@01) n@367@01) (img@369@01 n@367@01)))
  :pattern ((Set_in n@367@01 g@257@01))
  :pattern ((inv@368@01 n@367@01))
  :pattern ((img@369@01 n@367@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@369@01 r) (Set_in (inv@368@01 r) g@257@01)) (= (inv@368@01 r) r))
  :pattern ((inv@368@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>)))
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r)))
    (=>
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r))
      (Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@372@01  $FVF<next>))))
  :qid |qp.fvfDomDef209|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@368@01 r) g@257@01) (img@369@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@372@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@372@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@372@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef208|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@376@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@376@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef211|)))
(assert (forall ((n@373@01 $Ref)) (!
  (=>
    (Set_in n@373@01 g@257@01)
    (and (= (inv@374@01 n@373@01) n@373@01) (img@375@01 n@373@01)))
  :pattern ((Set_in n@373@01 g@257@01))
  :pattern ((inv@374@01 n@373@01))
  :pattern ((img@375@01 n@373@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@375@01 r) (Set_in (inv@374@01 r) g@257@01)) (= (inv@374@01 r) r))
  :pattern ((inv@374@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r)))
    (=>
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@378@01  $FVF<next>))))
  :qid |qp.fvfDomDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@374@01 r) g@257@01) (img@375@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@378@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef212|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@378@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@382@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@382@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((n@379@01 $Ref)) (!
  (=>
    (Set_in n@379@01 g@257@01)
    (and (= (inv@380@01 n@379@01) n@379@01) (img@381@01 n@379@01)))
  :pattern ((Set_in n@379@01 g@257@01))
  :pattern ((inv@380@01 n@379@01))
  :pattern ((img@381@01 n@379@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@381@01 r) (Set_in (inv@380@01 r) g@257@01)) (= (inv@380@01 r) r))
  :pattern ((inv@380@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r)))
    (=>
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@384@01  $FVF<next>))))
  :qid |qp.fvfDomDef219|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@380@01 r) g@257@01) (img@381@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@384@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@384@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@388@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@388@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (forall ((n@385@01 $Ref)) (!
  (=>
    (Set_in n@385@01 g@257@01)
    (and (= (inv@386@01 n@385@01) n@385@01) (img@387@01 n@385@01)))
  :pattern ((Set_in n@385@01 g@257@01))
  :pattern ((inv@386@01 n@385@01))
  :pattern ((img@387@01 n@385@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@387@01 r) (Set_in (inv@386@01 r) g@257@01)) (= (inv@386@01 r) r))
  :pattern ((inv@386@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r)))
    (=>
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@390@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@386@01 r) g@257@01) (img@387@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
(assert (forall ((n$1@320@01 $Ref)) (!
  (=>
    (Set_in n$1@320@01 g@257@01)
    (and (= (inv@322@01 n$1@320@01) n$1@320@01) (img@323@01 n$1@320@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) n$1@320@01) n$1@320@01))
  :qid |quant-u-220|)))
(assert (forall ((n$1@320@01 $Ref)) (!
  (=> (Set_in n$1@320@01 g@257@01) (not (= n$1@320@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) n$1@320@01) n$1@320@01))
  :qid |next-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@322@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@322@01 r))
  :qid |quant-u-221|)))
(assert (=
  ($Snap.second ($Snap.second $t@319@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@319@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@319@01))) $Snap.unit))
(assert (forall ((n$2@325@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@325@01 g@257@01)
      (and
        (Set_in n$2@325@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or (Set_in n$2@325@01 g@257@01) (not (Set_in n$2@325@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or
      (not
        (and
          (Set_in n$2@325@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01)
              $Ref.null))))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(assert (forall ((n$2@325@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@325@01 g@257@01)
      (and
        (Set_in n$2@325@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or (Set_in n$2@325@01 g@257@01) (not (Set_in n$2@325@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01)))
    (or
      (not
        (and
          (Set_in n$2@325@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01)
              $Ref.null))))
      (and
        (Set_in n$2@325@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))))
  :pattern ((Set_in n$2@325@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(assert (forall ((n$2@325@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@325@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) g@257@01))
  :pattern ((Set_in n$2@325@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$2@325@01) n$2@325@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@319@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@319@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@319@01))))
  $Snap.unit))
(assert (Set_in last@318@01 g@257@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
  $Snap.unit))
(assert (forall ((n@326@01 $Ref)) (!
  (and
    (=>
      (Set_in n@326@01 g@257@01)
      (and
        (Set_in n@326@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@328@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@328@01 r))
          :qid |quant-u-223|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@333@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
              :pattern ((inv@333@01 r))
              :qid |quant-u-228|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))))
    (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
  :pattern ((Set_in n@326@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@326@01 $Ref)) (!
  (and
    (=>
      (Set_in n@326@01 g@257@01)
      (and
        (Set_in n@326@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@328@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@328@01 r))
          :qid |quant-u-223|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@333@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
              :pattern ((inv@333@01 r))
              :qid |quant-u-228|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))))
    (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@326@01 $Ref)) (!
  (and
    (=>
      (Set_in n@326@01 g@257@01)
      (and
        (Set_in n@326@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@328@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@328@01 r))
          :qid |quant-u-223|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@333@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@335@01  $FVF<next>) r) r))
              :pattern ((inv@333@01 r))
              :qid |quant-u-228|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))))
    (or (not (Set_in n@326@01 g@257@01)) (Set_in n@326@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01) y@259@01 n@326@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@326@01 $Ref)) (!
  (=>
    (Set_in n@326@01 g@257@01)
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01) y@259@01 n@326@01)))
  :pattern ((Set_in n@326@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@331@01  $FVF<next>)) g@257@01) x@258@01 n@326@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@337@01  $FVF<next>)) g@257@01) y@259@01 n@326@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
  $Snap.unit))
(assert (forall ((n@338@01 $Ref)) (!
  (and
    (=>
      (Set_in n@338@01 g@257@01)
      (and
        (Set_in n@338@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@340@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@340@01 r))
          :qid |quant-u-233|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@345@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
              :pattern ((inv@345@01 r))
              :qid |quant-u-238|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))))
    (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
  :pattern ((Set_in n@338@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@338@01 $Ref)) (!
  (and
    (=>
      (Set_in n@338@01 g@257@01)
      (and
        (Set_in n@338@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@340@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@340@01 r))
          :qid |quant-u-233|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@345@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
              :pattern ((inv@345@01 r))
              :qid |quant-u-238|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))))
    (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@338@01 $Ref)) (!
  (and
    (=>
      (Set_in n@338@01 g@257@01)
      (and
        (Set_in n@338@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@340@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@340@01 r))
          :qid |quant-u-233|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@345@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@347@01  $FVF<next>) r) r))
              :pattern ((inv@345@01 r))
              :qid |quant-u-238|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01)))))
    (or (not (Set_in n@338@01 g@257@01)) (Set_in n@338@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01) y@259@01 n@338@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@338@01 $Ref)) (!
  (=>
    (Set_in n@338@01 g@257@01)
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01) y@259@01 n@338@01))))
  :pattern ((Set_in n@338@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g@257@01) x@258@01 n@338@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@349@01  $FVF<next>)) g@257@01) y@259@01 n@338@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
  $Snap.unit))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@351@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@351@01 r))
  :qid |quant-u-243|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@354@01  $FVF<next>)) g@257@01))
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@354@01  $FVF<next>)) g@257@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
  $Snap.unit))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@356@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@358@01  $FVF<next>) r) r))
  :pattern ((inv@356@01 r))
  :qid |quant-u-248|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@360@01  $FVF<next>)) g@257@01))
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@360@01  $FVF<next>)) g@257@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
  $Snap.unit))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@362@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@364@01  $FVF<next>) r) r))
  :pattern ((inv@362@01 r))
  :qid |quant-u-253|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>)) g@257@01))
(assert (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>)) g@257@01) old_g@317@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
  $Snap.unit))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@368@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@370@01  $FVF<next>) r) r))
  :pattern ((inv@368@01 r))
  :qid |quant-u-258|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@372@01  $FVF<next>)) g@257@01))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@372@01  $FVF<next>)) g@257@01) x@258@01 last@318@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@319@01))))))))))))
  $Snap.unit))
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) last@318@01))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
        $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@374@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@376@01  $FVF<next>) r) r))
      :pattern ((inv@374@01 r))
      :qid |quant-u-263|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01)
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@380@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@382@01  $FVF<next>) r) r))
          :pattern ((inv@380@01 r))
          :qid |quant-u-268|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01)))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
    (=>
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@386@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@388@01  $FVF<next>) r) r))
          :pattern ((inv@386@01 r))
          :qid |quant-u-273|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01)))
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))))
(assert (or
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null)
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))))
(assert (=>
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
        $Ref.null))
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@378@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@384@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@390@01  $FVF<next>)) g@257@01) last@318@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01))))
(assert (= $t@319@01 ($Snap.combine ($Snap.first $t@319@01) ($Snap.second $t@319@01))))
(assert (= ($Snap.first $t@319@01) $Snap.unit))
(assert (=
  ($Snap.second $t@319@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@319@01))
    ($Snap.second ($Snap.second $t@319@01)))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Check well-definedness of edge conditions
(set-option :timeout 0)
(push) ; 6
; [eval] last.next != null
(push) ; 7
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [eval] !(last.next != null)
; [eval] last.next != null
(push) ; 7
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
; Loop head block: Follow loop-internal edges
; [eval] last.next != null
(push) ; 6
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; [then-branch: 56 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null | live]
; [else-branch: 56 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 56 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null]
(assert (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null)))
; [exec]
; inhale last.next != null ==>
;   apply_IND_2($$(g), Set(last), inst_uReach_rev($$(g), last.next))
(declare-const $t@463@01 $Snap)
(assert (= $t@463@01 $Snap.unit))
; [eval] last.next != null ==> apply_IND_2($$(g), Set(last), inst_uReach_rev($$(g), last.next))
; [eval] last.next != null
(push) ; 7
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; [then-branch: 57 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null | live]
; [else-branch: 57 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 57 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null]
; [eval] apply_IND_2($$(g), Set(last), inst_uReach_rev($$(g), last.next))
; [eval] $$(g)
(push) ; 9
(declare-const n@464@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@464@01 g@257@01))
(pop) ; 10
(declare-fun inv@465@01 ($Ref) $Ref)
(declare-fun img@466@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@467@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@467@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@467@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef278|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@467@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef279|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@464@01 $Ref) (n2@464@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@464@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@467@01  $FVF<next>) n1@464@01) n1@464@01))
      (and
        (Set_in n2@464@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@467@01  $FVF<next>) n2@464@01) n2@464@01))
      (= n1@464@01 n2@464@01))
    (= n1@464@01 n2@464@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@464@01 $Ref)) (!
  (=>
    (Set_in n@464@01 g@257@01)
    (and (= (inv@465@01 n@464@01) n@464@01) (img@466@01 n@464@01)))
  :pattern ((Set_in n@464@01 g@257@01))
  :pattern ((inv@465@01 n@464@01))
  :pattern ((img@466@01 n@464@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@466@01 r) (Set_in (inv@465@01 r) g@257@01)) (= (inv@465@01 r) r))
  :pattern ((inv@465@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@465@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@467@01  $FVF<next>) r) r))
  :pattern ((inv@465@01 r))
  :qid |quant-u-338|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@468@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r) (= r (inv@465@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@468@01 r))
    $Perm.No)
  
  :qid |quant-u-340|))))
(check-sat)
; unsat
(pop) ; 10
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r) (= r (inv@465@01 r)))
    (= (- $Perm.Write (pTaken@468@01 r)) $Perm.No))
  
  :qid |quant-u-341|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@469@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>)))
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r)))
    (=>
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r))
      (Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>))))
  :qid |qp.fvfDomDef282|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@469@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@469@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef280|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@469@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef281|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@469@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@467@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@467@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef278|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@467@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef279|)))
(assert (forall ((n@464@01 $Ref)) (!
  (=>
    (Set_in n@464@01 g@257@01)
    (and (= (inv@465@01 n@464@01) n@464@01) (img@466@01 n@464@01)))
  :pattern ((Set_in n@464@01 g@257@01))
  :pattern ((inv@465@01 n@464@01))
  :pattern ((img@466@01 n@464@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@466@01 r) (Set_in (inv@465@01 r) g@257@01)) (= (inv@465@01 r) r))
  :pattern ((inv@465@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>)))
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r)))
    (=>
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r))
      (Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>))))
  :qid |qp.fvfDomDef282|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@469@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@469@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef280|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@469@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef281|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@465@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@467@01  $FVF<next>) r) r))
    :pattern ((inv@465@01 r))
    :qid |quant-u-338|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@469@01  $FVF<next>)) g@257@01)))
; [eval] Set(last)
; [eval] inst_uReach_rev($$(g), last.next)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 9
(declare-const n@470@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@470@01 g@257@01))
(pop) ; 10
(declare-fun inv@471@01 ($Ref) $Ref)
(declare-fun img@472@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@473@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@473@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@473@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef283|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@473@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef284|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@470@01 $Ref) (n2@470@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@470@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@473@01  $FVF<next>) n1@470@01) n1@470@01))
      (and
        (Set_in n2@470@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@473@01  $FVF<next>) n2@470@01) n2@470@01))
      (= n1@470@01 n2@470@01))
    (= n1@470@01 n2@470@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@470@01 $Ref)) (!
  (=>
    (Set_in n@470@01 g@257@01)
    (and (= (inv@471@01 n@470@01) n@470@01) (img@472@01 n@470@01)))
  :pattern ((Set_in n@470@01 g@257@01))
  :pattern ((inv@471@01 n@470@01))
  :pattern ((img@472@01 n@470@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@472@01 r) (Set_in (inv@471@01 r) g@257@01)) (= (inv@471@01 r) r))
  :pattern ((inv@471@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@471@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@473@01  $FVF<next>) r) r))
  :pattern ((inv@471@01 r))
  :qid |quant-u-343|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@474@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r) (= r (inv@471@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@474@01 r))
    $Perm.No)
  
  :qid |quant-u-345|))))
(check-sat)
; unsat
(pop) ; 10
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r) (= r (inv@471@01 r)))
    (= (- $Perm.Write (pTaken@474@01 r)) $Perm.No))
  
  :qid |quant-u-346|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@475@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>)))
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r)))
    (=>
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r))
      (Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>))))
  :qid |qp.fvfDomDef287|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@475@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@475@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef285|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@475@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef286|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@475@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@473@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@473@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef283|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@473@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef284|)))
(assert (forall ((n@470@01 $Ref)) (!
  (=>
    (Set_in n@470@01 g@257@01)
    (and (= (inv@471@01 n@470@01) n@470@01) (img@472@01 n@470@01)))
  :pattern ((Set_in n@470@01 g@257@01))
  :pattern ((inv@471@01 n@470@01))
  :pattern ((img@472@01 n@470@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@472@01 r) (Set_in (inv@471@01 r) g@257@01)) (= (inv@471@01 r) r))
  :pattern ((inv@471@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>)))
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r)))
    (=>
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r))
      (Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>))))
  :qid |qp.fvfDomDef287|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@475@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@475@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef285|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@475@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef286|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@471@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@473@01  $FVF<next>) r) r))
    :pattern ((inv@471@01 r))
    :qid |quant-u-343|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@475@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 9
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@467@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@467@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef278|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@467@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef279|)))
(assert (forall ((n@464@01 $Ref)) (!
  (=>
    (Set_in n@464@01 g@257@01)
    (and (= (inv@465@01 n@464@01) n@464@01) (img@466@01 n@464@01)))
  :pattern ((Set_in n@464@01 g@257@01))
  :pattern ((inv@465@01 n@464@01))
  :pattern ((img@466@01 n@464@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@466@01 r) (Set_in (inv@465@01 r) g@257@01)) (= (inv@465@01 r) r))
  :pattern ((inv@465@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>)))
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r)))
    (=>
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r))
      (Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@469@01  $FVF<next>))))
  :qid |qp.fvfDomDef282|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@465@01 r) g@257@01) (img@466@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@469@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@469@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef280|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@469@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef281|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@473@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@473@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef283|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@473@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef284|)))
(assert (forall ((n@470@01 $Ref)) (!
  (=>
    (Set_in n@470@01 g@257@01)
    (and (= (inv@471@01 n@470@01) n@470@01) (img@472@01 n@470@01)))
  :pattern ((Set_in n@470@01 g@257@01))
  :pattern ((inv@471@01 n@470@01))
  :pattern ((img@472@01 n@470@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@472@01 r) (Set_in (inv@471@01 r) g@257@01)) (= (inv@471@01 r) r))
  :pattern ((inv@471@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>)))
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r)))
    (=>
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r))
      (Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@475@01  $FVF<next>))))
  :qid |qp.fvfDomDef287|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@471@01 r) g@257@01) (img@472@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@475@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@475@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef285|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@475@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef286|)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))
  (and
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@465@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@467@01  $FVF<next>) r) r))
      :pattern ((inv@465@01 r))
      :qid |quant-u-338|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@469@01  $FVF<next>)) g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@471@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@473@01  $FVF<next>) r) r))
      :pattern ((inv@471@01 r))
      :qid |quant-u-343|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@475@01  $FVF<next>)) g@257@01))))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))
  (apply_IND_2<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@469@01  $FVF<next>)) g@257@01) (Set_singleton last@318@01) (inst_uReach_rev<Set<Ref>> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@475@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale last.next != null ==>
;   apply_IND($$(g), Set(x), inst_uReach_2($$(g), x))
(declare-const $t@476@01 $Snap)
(assert (= $t@476@01 $Snap.unit))
; [eval] last.next != null ==> apply_IND($$(g), Set(x), inst_uReach_2($$(g), x))
; [eval] last.next != null
(set-option :timeout 0)
(push) ; 7
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; [then-branch: 58 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null | live]
; [else-branch: 58 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 58 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null]
; [eval] apply_IND($$(g), Set(x), inst_uReach_2($$(g), x))
; [eval] $$(g)
(push) ; 9
(declare-const n@477@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@477@01 g@257@01))
(pop) ; 10
(declare-fun inv@478@01 ($Ref) $Ref)
(declare-fun img@479@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@480@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@480@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@480@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef288|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@480@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef289|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@477@01 $Ref) (n2@477@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@477@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@480@01  $FVF<next>) n1@477@01) n1@477@01))
      (and
        (Set_in n2@477@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@480@01  $FVF<next>) n2@477@01) n2@477@01))
      (= n1@477@01 n2@477@01))
    (= n1@477@01 n2@477@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@477@01 $Ref)) (!
  (=>
    (Set_in n@477@01 g@257@01)
    (and (= (inv@478@01 n@477@01) n@477@01) (img@479@01 n@477@01)))
  :pattern ((Set_in n@477@01 g@257@01))
  :pattern ((inv@478@01 n@477@01))
  :pattern ((img@479@01 n@477@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@479@01 r) (Set_in (inv@478@01 r) g@257@01)) (= (inv@478@01 r) r))
  :pattern ((inv@478@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@478@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@480@01  $FVF<next>) r) r))
  :pattern ((inv@478@01 r))
  :qid |quant-u-348|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@481@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r) (= r (inv@478@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@481@01 r))
    $Perm.No)
  
  :qid |quant-u-350|))))
(check-sat)
; unsat
(pop) ; 10
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r) (= r (inv@478@01 r)))
    (= (- $Perm.Write (pTaken@481@01 r)) $Perm.No))
  
  :qid |quant-u-351|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@482@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>)))
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r)))
    (=>
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r))
      (Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>))))
  :qid |qp.fvfDomDef292|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@482@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@482@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef290|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@482@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef291|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@482@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@480@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@480@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef288|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@480@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef289|)))
(assert (forall ((n@477@01 $Ref)) (!
  (=>
    (Set_in n@477@01 g@257@01)
    (and (= (inv@478@01 n@477@01) n@477@01) (img@479@01 n@477@01)))
  :pattern ((Set_in n@477@01 g@257@01))
  :pattern ((inv@478@01 n@477@01))
  :pattern ((img@479@01 n@477@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@479@01 r) (Set_in (inv@478@01 r) g@257@01)) (= (inv@478@01 r) r))
  :pattern ((inv@478@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>)))
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r)))
    (=>
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r))
      (Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>))))
  :qid |qp.fvfDomDef292|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@482@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@482@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef290|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@482@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef291|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@478@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@480@01  $FVF<next>) r) r))
    :pattern ((inv@478@01 r))
    :qid |quant-u-348|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@482@01  $FVF<next>)) g@257@01)))
; [eval] Set(x)
; [eval] inst_uReach_2($$(g), x)
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 9
(declare-const n@483@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@483@01 g@257@01))
(pop) ; 10
(declare-fun inv@484@01 ($Ref) $Ref)
(declare-fun img@485@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@486@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@486@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@486@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef293|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@486@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef294|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@483@01 $Ref) (n2@483@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@483@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@486@01  $FVF<next>) n1@483@01) n1@483@01))
      (and
        (Set_in n2@483@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@486@01  $FVF<next>) n2@483@01) n2@483@01))
      (= n1@483@01 n2@483@01))
    (= n1@483@01 n2@483@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@483@01 $Ref)) (!
  (=>
    (Set_in n@483@01 g@257@01)
    (and (= (inv@484@01 n@483@01) n@483@01) (img@485@01 n@483@01)))
  :pattern ((Set_in n@483@01 g@257@01))
  :pattern ((inv@484@01 n@483@01))
  :pattern ((img@485@01 n@483@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@485@01 r) (Set_in (inv@484@01 r) g@257@01)) (= (inv@484@01 r) r))
  :pattern ((inv@484@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@484@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@486@01  $FVF<next>) r) r))
  :pattern ((inv@484@01 r))
  :qid |quant-u-353|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@487@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r) (= r (inv@484@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@487@01 r))
    $Perm.No)
  
  :qid |quant-u-355|))))
(check-sat)
; unsat
(pop) ; 10
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r) (= r (inv@484@01 r)))
    (= (- $Perm.Write (pTaken@487@01 r)) $Perm.No))
  
  :qid |quant-u-356|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@488@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>)))
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r)))
    (=>
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r))
      (Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>))))
  :qid |qp.fvfDomDef297|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@488@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@488@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef295|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@488@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef296|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@488@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@486@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@486@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef293|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@486@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef294|)))
(assert (forall ((n@483@01 $Ref)) (!
  (=>
    (Set_in n@483@01 g@257@01)
    (and (= (inv@484@01 n@483@01) n@483@01) (img@485@01 n@483@01)))
  :pattern ((Set_in n@483@01 g@257@01))
  :pattern ((inv@484@01 n@483@01))
  :pattern ((img@485@01 n@483@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@485@01 r) (Set_in (inv@484@01 r) g@257@01)) (= (inv@484@01 r) r))
  :pattern ((inv@484@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>)))
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r)))
    (=>
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r))
      (Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>))))
  :qid |qp.fvfDomDef297|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@488@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@488@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef295|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@488@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef296|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@484@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@486@01  $FVF<next>) r) r))
    :pattern ((inv@484@01 r))
    :qid |quant-u-353|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@488@01  $FVF<next>)) g@257@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@480@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@480@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef288|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@480@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef289|)))
(assert (forall ((n@477@01 $Ref)) (!
  (=>
    (Set_in n@477@01 g@257@01)
    (and (= (inv@478@01 n@477@01) n@477@01) (img@479@01 n@477@01)))
  :pattern ((Set_in n@477@01 g@257@01))
  :pattern ((inv@478@01 n@477@01))
  :pattern ((img@479@01 n@477@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@479@01 r) (Set_in (inv@478@01 r) g@257@01)) (= (inv@478@01 r) r))
  :pattern ((inv@478@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>)))
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r)))
    (=>
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r))
      (Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@482@01  $FVF<next>))))
  :qid |qp.fvfDomDef292|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@478@01 r) g@257@01) (img@479@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@482@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@482@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef290|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@482@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef291|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@486@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@486@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef293|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@486@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef294|)))
(assert (forall ((n@483@01 $Ref)) (!
  (=>
    (Set_in n@483@01 g@257@01)
    (and (= (inv@484@01 n@483@01) n@483@01) (img@485@01 n@483@01)))
  :pattern ((Set_in n@483@01 g@257@01))
  :pattern ((inv@484@01 n@483@01))
  :pattern ((img@485@01 n@483@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@485@01 r) (Set_in (inv@484@01 r) g@257@01)) (= (inv@484@01 r) r))
  :pattern ((inv@484@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>)))
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r)))
    (=>
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r))
      (Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@488@01  $FVF<next>))))
  :qid |qp.fvfDomDef297|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@484@01 r) g@257@01) (img@485@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@488@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@488@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef295|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@488@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef296|)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))
  (and
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@478@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@480@01  $FVF<next>) r) r))
      :pattern ((inv@478@01 r))
      :qid |quant-u-348|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@482@01  $FVF<next>)) g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@484@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@486@01  $FVF<next>) r) r))
      :pattern ((inv@484@01 r))
      :qid |quant-u-353|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@488@01  $FVF<next>)) g@257@01))))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
      $Ref.null))
  (apply_IND<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@482@01  $FVF<next>)) g@257@01) (Set_singleton x@258@01) (inst_uReach_2<Set<Ref>> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@488@01  $FVF<next>)) g@257@01) x@258@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; last := last.next
(set-option :timeout 0)
(push) ; 7
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(declare-const last@489@01 $Ref)
(assert (=
  last@489@01
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)))
; Loop head block: Re-establish invariant
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$1@490@01 $Ref)
(push) ; 7
; [eval] (n$1 in g)
(assert (Set_in n$1@490@01 g@257@01))
(declare-const sm@491@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@491@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@491@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef298|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@491@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef299|)))
(pop) ; 7
(declare-fun inv@492@01 ($Ref) $Ref)
(declare-fun img@493@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@491@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@491@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef298|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@491@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef299|)))
; Nested auxiliary terms: non-globals
(declare-const sm@494@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@494@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef300|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef301|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n$11@490@01 $Ref) (n$12@490@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@490@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$11@490@01) n$11@490@01))
      (and
        (Set_in n$12@490@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$12@490@01) n$12@490@01))
      (= n$11@490@01 n$12@490@01))
    (= n$11@490@01 n$12@490@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@490@01 $Ref)) (!
  (=>
    (Set_in n$1@490@01 g@257@01)
    (and (= (inv@492@01 n$1@490@01) n$1@490@01) (img@493@01 n$1@490@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@491@01  $FVF<next>) n$1@490@01) n$1@490@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@493@01 r) (Set_in (inv@492@01 r) g@257@01)) (= (inv@492@01 r) r))
  :pattern ((inv@492@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@492@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
  :pattern ((inv@492@01 r))
  :qid |quant-u-358|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@495@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@492@01 r) g@257@01) (img@493@01 r) (= r (inv@492@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@495@01 r))
    $Perm.No)
  
  :qid |quant-u-360|))))
(check-sat)
; unsat
(pop) ; 7
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@492@01 r) g@257@01) (img@493@01 r) (= r (inv@492@01 r)))
    (= (- $Perm.Write (pTaken@495@01 r)) $Perm.No))
  
  :qid |quant-u-361|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@496@01 $Ref)
(set-option :timeout 0)
(push) ; 7
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 8
; [then-branch: 59 | !(n$2@496@01 in g@257@01) | live]
; [else-branch: 59 | n$2@496@01 in g@257@01 | live]
(push) ; 9
; [then-branch: 59 | !(n$2@496@01 in g@257@01)]
(assert (not (Set_in n$2@496@01 g@257@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 59 | n$2@496@01 in g@257@01]
(assert (Set_in n$2@496@01 g@257@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@494@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
    :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
    :qid |qp.fvfValDef300|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef301|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))
(push) ; 10
(assert (not (and (img@323@01 n$2@496@01) (Set_in (inv@322@01 n$2@496@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@494@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef300|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef301|)))
(assert (=>
  (Set_in n$2@496@01 g@257@01)
  (and
    (Set_in n$2@496@01 g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))))
(assert (or (Set_in n$2@496@01 g@257@01) (not (Set_in n$2@496@01 g@257@01))))
(push) ; 8
; [then-branch: 60 | n$2@496@01 in g@257@01 && Lookup(next, sm@494@01, n$2@496@01) != Null | live]
; [else-branch: 60 | !(n$2@496@01 in g@257@01 && Lookup(next, sm@494@01, n$2@496@01) != Null) | live]
(push) ; 9
; [then-branch: 60 | n$2@496@01 in g@257@01 && Lookup(next, sm@494@01, n$2@496@01) != Null]
(assert (and
  (Set_in n$2@496@01 g@257@01)
  (not (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@494@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
    :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
    :qid |qp.fvfValDef300|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef301|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))
(push) ; 10
(assert (not (and (img@323@01 n$2@496@01) (Set_in (inv@322@01 n$2@496@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(push) ; 9
; [else-branch: 60 | !(n$2@496@01 in g@257@01 && Lookup(next, sm@494@01, n$2@496@01) != Null)]
(assert (not
  (and
    (Set_in n$2@496@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@494@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef300|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef301|)))
(assert (=>
  (and
    (Set_in n$2@496@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))
  (and
    (Set_in n$2@496@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@496@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null))))
  (and
    (Set_in n$2@496@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@494@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef300|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@494@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef301|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@496@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@496@01 g@257@01)
      (and
        (Set_in n$2@496@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01)))
    (or (Set_in n$2@496@01 g@257@01) (not (Set_in n$2@496@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@496@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))
      (and
        (Set_in n$2@496@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01)))
    (or
      (not
        (and
          (Set_in n$2@496@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01)
              $Ref.null))))
      (and
        (Set_in n$2@496@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(assert (forall ((n$2@496@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@496@01 g@257@01)
      (and
        (Set_in n$2@496@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01)))
    (or (Set_in n$2@496@01 g@257@01) (not (Set_in n$2@496@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@496@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))
      (and
        (Set_in n$2@496@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01)))
    (or
      (not
        (and
          (Set_in n$2@496@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01)
              $Ref.null))))
      (and
        (Set_in n$2@496@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))))
  :pattern ((Set_in n$2@496@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31-aux|)))
(push) ; 7
(assert (not (forall ((n$2@496@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@496@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) g@257@01))
  :pattern ((Set_in n$2@496@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@496@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@496@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) g@257@01))
  :pattern ((Set_in n$2@496@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n$2@496@01) n$2@496@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@367@23@367@31|)))
; [eval] (last in g)
(push) ; 7
(assert (not (Set_in last@489@01 g@257@01)))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(assert (Set_in last@489@01 g@257@01))
; [eval] (x in g)
; [eval] (y in g)
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n))
(declare-const n@497@01 $Ref)
(push) ; 7
; [eval] (n in g) ==> exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 8
; [then-branch: 61 | n@497@01 in g@257@01 | live]
; [else-branch: 61 | !(n@497@01 in g@257@01) | live]
(push) ; 9
; [then-branch: 61 | n@497@01 in g@257@01]
(assert (Set_in n@497@01 g@257@01))
; [eval] exists_path($$(g), x, n) || exists_path($$(g), y, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 10
(declare-const n@498@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@498@01 g@257@01))
(pop) ; 11
(declare-fun inv@499@01 ($Ref) $Ref)
(declare-fun img@500@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@498@01 $Ref) (n2@498@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@498@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n1@498@01) n1@498@01))
      (and
        (Set_in n2@498@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n2@498@01) n2@498@01))
      (= n1@498@01 n2@498@01))
    (= n1@498@01 n2@498@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@498@01 $Ref)) (!
  (=>
    (Set_in n@498@01 g@257@01)
    (and (= (inv@499@01 n@498@01) n@498@01) (img@500@01 n@498@01)))
  :pattern ((Set_in n@498@01 g@257@01))
  :pattern ((inv@499@01 n@498@01))
  :pattern ((img@500@01 n@498@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@500@01 r) (Set_in (inv@499@01 r) g@257@01)) (= (inv@499@01 r) r))
  :pattern ((inv@499@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@499@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
  :pattern ((inv@499@01 r))
  :qid |quant-u-363|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@501@01 ((r $Ref) (n@497@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r) (= r (inv@499@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@501@01 r n@497@01))
    $Perm.No)
  
  :qid |quant-u-365|))))
(check-sat)
; unsat
(pop) ; 11
; 0,04s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r) (= r (inv@499@01 r)))
    (= (- $Perm.Write (pTaken@501@01 r n@497@01)) $Perm.No))
  
  :qid |quant-u-366|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@502@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r)))
    (=>
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>))))
  :qid |qp.fvfDomDef304|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@502@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef302|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef303|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((n@498@01 $Ref)) (!
  (=>
    (Set_in n@498@01 g@257@01)
    (and (= (inv@499@01 n@498@01) n@498@01) (img@500@01 n@498@01)))
  :pattern ((Set_in n@498@01 g@257@01))
  :pattern ((inv@499@01 n@498@01))
  :pattern ((img@500@01 n@498@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@500@01 r) (Set_in (inv@499@01 r) g@257@01)) (= (inv@499@01 r) r))
  :pattern ((inv@499@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r)))
    (=>
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>))))
  :qid |qp.fvfDomDef304|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@502@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef302|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef303|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@499@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
    :pattern ((inv@499@01 r))
    :qid |quant-u-363|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 62 | exists_path[Bool]($$(sm@502@01, g@257@01), x@258@01, n@497@01) | live]
; [else-branch: 62 | !(exists_path[Bool]($$(sm@502@01, g@257@01), x@258@01, n@497@01)) | live]
(push) ; 11
; [then-branch: 62 | exists_path[Bool]($$(sm@502@01, g@257@01), x@258@01, n@497@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
(pop) ; 11
(push) ; 11
; [else-branch: 62 | !(exists_path[Bool]($$(sm@502@01, g@257@01), x@258@01, n@497@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01)))
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 12
(declare-const n@503@01 $Ref)
(push) ; 13
; [eval] (n in refs)
(assert (Set_in n@503@01 g@257@01))
(pop) ; 13
(declare-fun inv@504@01 ($Ref) $Ref)
(declare-fun img@505@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@506@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@506@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef305|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef306|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((n1@503@01 $Ref) (n2@503@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@503@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) n1@503@01) n1@503@01))
      (and
        (Set_in n2@503@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) n2@503@01) n2@503@01))
      (= n1@503@01 n2@503@01))
    (= n1@503@01 n2@503@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@503@01 $Ref)) (!
  (=>
    (Set_in n@503@01 g@257@01)
    (and (= (inv@504@01 n@503@01) n@503@01) (img@505@01 n@503@01)))
  :pattern ((Set_in n@503@01 g@257@01))
  :pattern ((inv@504@01 n@503@01))
  :pattern ((img@505@01 n@503@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@505@01 r) (Set_in (inv@504@01 r) g@257@01)) (= (inv@504@01 r) r))
  :pattern ((inv@504@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@504@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
  :pattern ((inv@504@01 r))
  :qid |quant-u-368|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@507@01 ((r $Ref) (n@497@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r) (= r (inv@504@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@507@01 r n@497@01))
    $Perm.No)
  
  :qid |quant-u-370|))))
(check-sat)
; unsat
(pop) ; 13
; 0,04s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r) (= r (inv@504@01 r)))
    (= (- $Perm.Write (pTaken@507@01 r n@497@01)) $Perm.No))
  
  :qid |quant-u-371|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@508@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r)))
    (=>
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>))))
  :qid |qp.fvfDomDef309|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@508@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef307|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef308|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01))
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@506@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef305|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef306|)))
(assert (forall ((n@503@01 $Ref)) (!
  (=>
    (Set_in n@503@01 g@257@01)
    (and (= (inv@504@01 n@503@01) n@503@01) (img@505@01 n@503@01)))
  :pattern ((Set_in n@503@01 g@257@01))
  :pattern ((inv@504@01 n@503@01))
  :pattern ((img@505@01 n@503@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@505@01 r) (Set_in (inv@504@01 r) g@257@01)) (= (inv@504@01 r) r))
  :pattern ((inv@504@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r)))
    (=>
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>))))
  :qid |qp.fvfDomDef309|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@508@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef307|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef308|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@504@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
    :pattern ((inv@504@01 r))
    :qid |quant-u-368|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@506@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef305|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef306|)))
(assert (forall ((n@503@01 $Ref)) (!
  (=>
    (Set_in n@503@01 g@257@01)
    (and (= (inv@504@01 n@503@01) n@503@01) (img@505@01 n@503@01)))
  :pattern ((Set_in n@503@01 g@257@01))
  :pattern ((inv@504@01 n@503@01))
  :pattern ((img@505@01 n@503@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@505@01 r) (Set_in (inv@504@01 r) g@257@01)) (= (inv@504@01 r) r))
  :pattern ((inv@504@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r)))
    (=>
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>))))
  :qid |qp.fvfDomDef309|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@508@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef307|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef308|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@504@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
      :pattern ((inv@504@01 r))
      :qid |quant-u-368|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01)))
(pop) ; 9
(set-option :timeout 0)
(push) ; 9
; [else-branch: 61 | !(n@497@01 in g@257@01)]
(assert (not (Set_in n@497@01 g@257@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((n@498@01 $Ref)) (!
  (=>
    (Set_in n@498@01 g@257@01)
    (and (= (inv@499@01 n@498@01) n@498@01) (img@500@01 n@498@01)))
  :pattern ((Set_in n@498@01 g@257@01))
  :pattern ((inv@499@01 n@498@01))
  :pattern ((img@500@01 n@498@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@500@01 r) (Set_in (inv@499@01 r) g@257@01)) (= (inv@499@01 r) r))
  :pattern ((inv@499@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r)))
    (=>
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>))))
  :qid |qp.fvfDomDef304|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@502@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef302|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef303|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@506@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef305|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef306|)))
(assert (forall ((n@503@01 $Ref)) (!
  (=>
    (Set_in n@503@01 g@257@01)
    (and (= (inv@504@01 n@503@01) n@503@01) (img@505@01 n@503@01)))
  :pattern ((Set_in n@503@01 g@257@01))
  :pattern ((inv@504@01 n@503@01))
  :pattern ((img@505@01 n@503@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@505@01 r) (Set_in (inv@504@01 r) g@257@01)) (= (inv@504@01 r) r))
  :pattern ((inv@504@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r)))
    (=>
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>))))
  :qid |qp.fvfDomDef309|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@508@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef307|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef308|)))
(assert (=>
  (Set_in n@497@01 g@257@01)
  (and
    (Set_in n@497@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@499@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
      :pattern ((inv@499@01 r))
      :qid |quant-u-363|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@504@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
          :pattern ((inv@504@01 r))
          :qid |quant-u-368|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01)))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01)))))
; Joined path conditions
(assert (or (not (Set_in n@497@01 g@257@01)) (Set_in n@497@01 g@257@01)))
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@498@01 $Ref)) (!
  (=>
    (Set_in n@498@01 g@257@01)
    (and (= (inv@499@01 n@498@01) n@498@01) (img@500@01 n@498@01)))
  :pattern ((Set_in n@498@01 g@257@01))
  :pattern ((inv@499@01 n@498@01))
  :pattern ((img@500@01 n@498@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@500@01 r) (Set_in (inv@499@01 r) g@257@01)) (= (inv@499@01 r) r))
  :pattern ((inv@499@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r)))
    (=>
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@502@01  $FVF<next>))))
  :qid |qp.fvfDomDef304|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@499@01 r) g@257@01) (img@500@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@502@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef302|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@502@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef303|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@506@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef305|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@506@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef306|)))
(assert (forall ((n@503@01 $Ref)) (!
  (=>
    (Set_in n@503@01 g@257@01)
    (and (= (inv@504@01 n@503@01) n@503@01) (img@505@01 n@503@01)))
  :pattern ((Set_in n@503@01 g@257@01))
  :pattern ((inv@504@01 n@503@01))
  :pattern ((img@505@01 n@503@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@505@01 r) (Set_in (inv@504@01 r) g@257@01)) (= (inv@504@01 r) r))
  :pattern ((inv@504@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r)))
    (=>
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@508@01  $FVF<next>))))
  :qid |qp.fvfDomDef309|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@504@01 r) g@257@01) (img@505@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@508@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef307|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@508@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef308|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@497@01 $Ref)) (!
  (and
    (=>
      (Set_in n@497@01 g@257@01)
      (and
        (Set_in n@497@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@499@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
          :pattern ((inv@499@01 r))
          :qid |quant-u-363|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@504@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
              :pattern ((inv@504@01 r))
              :qid |quant-u-368|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))))
    (or (not (Set_in n@497@01 g@257@01)) (Set_in n@497@01 g@257@01)))
  :pattern ((Set_in n@497@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@497@01 $Ref)) (!
  (and
    (=>
      (Set_in n@497@01 g@257@01)
      (and
        (Set_in n@497@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@499@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
          :pattern ((inv@499@01 r))
          :qid |quant-u-363|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@504@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
              :pattern ((inv@504@01 r))
              :qid |quant-u-368|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))))
    (or (not (Set_in n@497@01 g@257@01)) (Set_in n@497@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@497@01 $Ref)) (!
  (and
    (=>
      (Set_in n@497@01 g@257@01)
      (and
        (Set_in n@497@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@499@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
          :pattern ((inv@499@01 r))
          :qid |quant-u-363|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@504@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@506@01  $FVF<next>) r) r))
              :pattern ((inv@504@01 r))
              :qid |quant-u-368|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01)))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))))
    (or (not (Set_in n@497@01 g@257@01)) (Set_in n@497@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01) y@259@01 n@497@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102-aux|)))
(assert (forall ((n@497@01 $Ref)) (!
  (=>
    (Set_in n@497@01 g@257@01)
    (and
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)
      (=>
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01))))
  :pattern ((Set_in n@497@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01) y@259@01 n@497@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102_precondition|)))
(push) ; 7
(assert (not (forall ((n@497@01 $Ref)) (!
  (=>
    (and
      (=>
        (Set_in n@497@01 g@257@01)
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01)
          (=>
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01))))
      (Set_in n@497@01 g@257@01))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01) y@259@01 n@497@01)))
  :pattern ((Set_in n@497@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01) y@259@01 n@497@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102|))))
(check-sat)
; unsat
(pop) ; 7
; 2,52s
; (get-info :all-statistics)
(assert (forall ((n@497@01 $Ref)) (!
  (=>
    (Set_in n@497@01 g@257@01)
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01) y@259@01 n@497@01)))
  :pattern ((Set_in n@497@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@502@01  $FVF<next>)) g@257@01) x@258@01 n@497@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@508@01  $FVF<next>)) g@257@01) y@259@01 n@497@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@371@23@371@102|)))
; [eval] (forall n: Ref :: { (n in g) } { exists_path($$(g), x, n) } { exists_path($$(g), y, n) } (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n))
(declare-const n@509@01 $Ref)
(push) ; 7
; [eval] (n in g) ==> !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] (n in g)
(push) ; 8
; [then-branch: 63 | n@509@01 in g@257@01 | live]
; [else-branch: 63 | !(n@509@01 in g@257@01) | live]
(push) ; 9
; [then-branch: 63 | n@509@01 in g@257@01]
(assert (Set_in n@509@01 g@257@01))
; [eval] !exists_path($$(g), x, n) || !exists_path($$(g), y, n)
; [eval] !exists_path($$(g), x, n)
; [eval] exists_path($$(g), x, n)
; [eval] $$(g)
(push) ; 10
(declare-const n@510@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@510@01 g@257@01))
(pop) ; 11
(declare-fun inv@511@01 ($Ref) $Ref)
(declare-fun img@512@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@510@01 $Ref) (n2@510@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@510@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n1@510@01) n1@510@01))
      (and
        (Set_in n2@510@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n2@510@01) n2@510@01))
      (= n1@510@01 n2@510@01))
    (= n1@510@01 n2@510@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@510@01 $Ref)) (!
  (=>
    (Set_in n@510@01 g@257@01)
    (and (= (inv@511@01 n@510@01) n@510@01) (img@512@01 n@510@01)))
  :pattern ((Set_in n@510@01 g@257@01))
  :pattern ((inv@511@01 n@510@01))
  :pattern ((img@512@01 n@510@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@512@01 r) (Set_in (inv@511@01 r) g@257@01)) (= (inv@511@01 r) r))
  :pattern ((inv@511@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@511@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
  :pattern ((inv@511@01 r))
  :qid |quant-u-373|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@513@01 ((r $Ref) (n@509@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r) (= r (inv@511@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@513@01 r n@509@01))
    $Perm.No)
  
  :qid |quant-u-375|))))
(check-sat)
; unsat
(pop) ; 11
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r) (= r (inv@511@01 r)))
    (= (- $Perm.Write (pTaken@513@01 r n@509@01)) $Perm.No))
  
  :qid |quant-u-376|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@514@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r)))
    (=>
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>))))
  :qid |qp.fvfDomDef312|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@514@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef310|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef311|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((n@510@01 $Ref)) (!
  (=>
    (Set_in n@510@01 g@257@01)
    (and (= (inv@511@01 n@510@01) n@510@01) (img@512@01 n@510@01)))
  :pattern ((Set_in n@510@01 g@257@01))
  :pattern ((inv@511@01 n@510@01))
  :pattern ((img@512@01 n@510@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@512@01 r) (Set_in (inv@511@01 r) g@257@01)) (= (inv@511@01 r) r))
  :pattern ((inv@511@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r)))
    (=>
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>))))
  :qid |qp.fvfDomDef312|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@514@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef310|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef311|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@511@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
    :pattern ((inv@511@01 r))
    :qid |quant-u-373|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 64 | !(exists_path[Bool]($$(sm@514@01, g@257@01), x@258@01, n@509@01)) | live]
; [else-branch: 64 | exists_path[Bool]($$(sm@514@01, g@257@01), x@258@01, n@509@01) | live]
(push) ; 11
; [then-branch: 64 | !(exists_path[Bool]($$(sm@514@01, g@257@01), x@258@01, n@509@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)))
(pop) ; 11
(push) ; 11
; [else-branch: 64 | exists_path[Bool]($$(sm@514@01, g@257@01), x@258@01, n@509@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
; [eval] !exists_path($$(g), y, n)
; [eval] exists_path($$(g), y, n)
; [eval] $$(g)
(push) ; 12
(declare-const n@515@01 $Ref)
(push) ; 13
; [eval] (n in refs)
(assert (Set_in n@515@01 g@257@01))
(pop) ; 13
(declare-fun inv@516@01 ($Ref) $Ref)
(declare-fun img@517@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@518@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@518@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef314|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((n1@515@01 $Ref) (n2@515@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@515@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) n1@515@01) n1@515@01))
      (and
        (Set_in n2@515@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) n2@515@01) n2@515@01))
      (= n1@515@01 n2@515@01))
    (= n1@515@01 n2@515@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@515@01 $Ref)) (!
  (=>
    (Set_in n@515@01 g@257@01)
    (and (= (inv@516@01 n@515@01) n@515@01) (img@517@01 n@515@01)))
  :pattern ((Set_in n@515@01 g@257@01))
  :pattern ((inv@516@01 n@515@01))
  :pattern ((img@517@01 n@515@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@517@01 r) (Set_in (inv@516@01 r) g@257@01)) (= (inv@516@01 r) r))
  :pattern ((inv@516@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@516@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
  :pattern ((inv@516@01 r))
  :qid |quant-u-378|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@519@01 ((r $Ref) (n@509@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r) (= r (inv@516@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@519@01 r n@509@01))
    $Perm.No)
  
  :qid |quant-u-380|))))
(check-sat)
; unsat
(pop) ; 13
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r) (= r (inv@516@01 r)))
    (= (- $Perm.Write (pTaken@519@01 r n@509@01)) $Perm.No))
  
  :qid |quant-u-381|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@520@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r)))
    (=>
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>))))
  :qid |qp.fvfDomDef317|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@520@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef315|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef316|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01))
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@518@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef314|)))
(assert (forall ((n@515@01 $Ref)) (!
  (=>
    (Set_in n@515@01 g@257@01)
    (and (= (inv@516@01 n@515@01) n@515@01) (img@517@01 n@515@01)))
  :pattern ((Set_in n@515@01 g@257@01))
  :pattern ((inv@516@01 n@515@01))
  :pattern ((img@517@01 n@515@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@517@01 r) (Set_in (inv@516@01 r) g@257@01)) (= (inv@516@01 r) r))
  :pattern ((inv@516@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r)))
    (=>
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>))))
  :qid |qp.fvfDomDef317|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@520@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef315|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef316|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@516@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
    :pattern ((inv@516@01 r))
    :qid |quant-u-378|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@518@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef314|)))
(assert (forall ((n@515@01 $Ref)) (!
  (=>
    (Set_in n@515@01 g@257@01)
    (and (= (inv@516@01 n@515@01) n@515@01) (img@517@01 n@515@01)))
  :pattern ((Set_in n@515@01 g@257@01))
  :pattern ((inv@516@01 n@515@01))
  :pattern ((img@517@01 n@515@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@517@01 r) (Set_in (inv@516@01 r) g@257@01)) (= (inv@516@01 r) r))
  :pattern ((inv@516@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r)))
    (=>
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>))))
  :qid |qp.fvfDomDef317|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@520@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef315|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef316|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@516@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
      :pattern ((inv@516@01 r))
      :qid |quant-u-378|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))))
(pop) ; 9
(set-option :timeout 0)
(push) ; 9
; [else-branch: 63 | !(n@509@01 in g@257@01)]
(assert (not (Set_in n@509@01 g@257@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((n@510@01 $Ref)) (!
  (=>
    (Set_in n@510@01 g@257@01)
    (and (= (inv@511@01 n@510@01) n@510@01) (img@512@01 n@510@01)))
  :pattern ((Set_in n@510@01 g@257@01))
  :pattern ((inv@511@01 n@510@01))
  :pattern ((img@512@01 n@510@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@512@01 r) (Set_in (inv@511@01 r) g@257@01)) (= (inv@511@01 r) r))
  :pattern ((inv@511@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r)))
    (=>
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>))))
  :qid |qp.fvfDomDef312|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@514@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef310|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef311|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@518@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef314|)))
(assert (forall ((n@515@01 $Ref)) (!
  (=>
    (Set_in n@515@01 g@257@01)
    (and (= (inv@516@01 n@515@01) n@515@01) (img@517@01 n@515@01)))
  :pattern ((Set_in n@515@01 g@257@01))
  :pattern ((inv@516@01 n@515@01))
  :pattern ((img@517@01 n@515@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@517@01 r) (Set_in (inv@516@01 r) g@257@01)) (= (inv@516@01 r) r))
  :pattern ((inv@516@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r)))
    (=>
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>))))
  :qid |qp.fvfDomDef317|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@520@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef315|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef316|)))
(assert (=>
  (Set_in n@509@01 g@257@01)
  (and
    (Set_in n@509@01 g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@511@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
      :pattern ((inv@511@01 r))
      :qid |quant-u-373|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@516@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
          :pattern ((inv@516@01 r))
          :qid |quant-u-378|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))))))
; Joined path conditions
(assert (or (not (Set_in n@509@01 g@257@01)) (Set_in n@509@01 g@257@01)))
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@510@01 $Ref)) (!
  (=>
    (Set_in n@510@01 g@257@01)
    (and (= (inv@511@01 n@510@01) n@510@01) (img@512@01 n@510@01)))
  :pattern ((Set_in n@510@01 g@257@01))
  :pattern ((inv@511@01 n@510@01))
  :pattern ((img@512@01 n@510@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@512@01 r) (Set_in (inv@511@01 r) g@257@01)) (= (inv@511@01 r) r))
  :pattern ((inv@511@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r)))
    (=>
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@514@01  $FVF<next>))))
  :qid |qp.fvfDomDef312|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@511@01 r) g@257@01) (img@512@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@514@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef310|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@514@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef311|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@518@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef313|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@518@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef314|)))
(assert (forall ((n@515@01 $Ref)) (!
  (=>
    (Set_in n@515@01 g@257@01)
    (and (= (inv@516@01 n@515@01) n@515@01) (img@517@01 n@515@01)))
  :pattern ((Set_in n@515@01 g@257@01))
  :pattern ((inv@516@01 n@515@01))
  :pattern ((img@517@01 n@515@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@517@01 r) (Set_in (inv@516@01 r) g@257@01)) (= (inv@516@01 r) r))
  :pattern ((inv@516@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r)))
    (=>
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@520@01  $FVF<next>))))
  :qid |qp.fvfDomDef317|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@516@01 r) g@257@01) (img@517@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@520@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef315|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@520@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef316|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@509@01 $Ref)) (!
  (and
    (=>
      (Set_in n@509@01 g@257@01)
      (and
        (Set_in n@509@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@511@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
          :pattern ((inv@511@01 r))
          :qid |quant-u-373|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@516@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
              :pattern ((inv@516@01 r))
              :qid |quant-u-378|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)))))
    (or (not (Set_in n@509@01 g@257@01)) (Set_in n@509@01 g@257@01)))
  :pattern ((Set_in n@509@01 g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@509@01 $Ref)) (!
  (and
    (=>
      (Set_in n@509@01 g@257@01)
      (and
        (Set_in n@509@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@511@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
          :pattern ((inv@511@01 r))
          :qid |quant-u-373|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@516@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
              :pattern ((inv@516@01 r))
              :qid |quant-u-378|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)))))
    (or (not (Set_in n@509@01 g@257@01)) (Set_in n@509@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@509@01 $Ref)) (!
  (and
    (=>
      (Set_in n@509@01 g@257@01)
      (and
        (Set_in n@509@01 g@257@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@511@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
          :pattern ((inv@511@01 r))
          :qid |quant-u-373|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@516@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@518@01  $FVF<next>) r) r))
              :pattern ((inv@516@01 r))
              :qid |quant-u-378|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)))))
    (or (not (Set_in n@509@01 g@257@01)) (Set_in n@509@01 g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01) y@259@01 n@509@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102-aux|)))
(assert (forall ((n@509@01 $Ref)) (!
  (=>
    (Set_in n@509@01 g@257@01)
    (and
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)
      (=>
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01))))
  :pattern ((Set_in n@509@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01) y@259@01 n@509@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102_precondition|)))
(push) ; 7
(assert (not (forall ((n@509@01 $Ref)) (!
  (=>
    (and
      (=>
        (Set_in n@509@01 g@257@01)
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01)
          (=>
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01)
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01))))
      (Set_in n@509@01 g@257@01))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01) y@259@01 n@509@01))))
  :pattern ((Set_in n@509@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01) y@259@01 n@509@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102|))))
(check-sat)
; unsat
(pop) ; 7
; 2,87s
; (get-info :all-statistics)
(assert (forall ((n@509@01 $Ref)) (!
  (=>
    (Set_in n@509@01 g@257@01)
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01) y@259@01 n@509@01))))
  :pattern ((Set_in n@509@01 g@257@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@514@01  $FVF<next>)) g@257@01) x@258@01 n@509@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@520@01  $FVF<next>)) g@257@01) y@259@01 n@509@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@372@23@372@102|)))
; [eval] acyclic_graph($$(g))
; [eval] $$(g)
(push) ; 7
(declare-const n@521@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@521@01 g@257@01))
(pop) ; 8
(declare-fun inv@522@01 ($Ref) $Ref)
(declare-fun img@523@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@521@01 $Ref) (n2@521@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@521@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n1@521@01) n1@521@01))
      (and
        (Set_in n2@521@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) n2@521@01) n2@521@01))
      (= n1@521@01 n2@521@01))
    (= n1@521@01 n2@521@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@521@01 $Ref)) (!
  (=>
    (Set_in n@521@01 g@257@01)
    (and (= (inv@522@01 n@521@01) n@521@01) (img@523@01 n@521@01)))
  :pattern ((Set_in n@521@01 g@257@01))
  :pattern ((inv@522@01 n@521@01))
  :pattern ((img@523@01 n@521@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@523@01 r) (Set_in (inv@522@01 r) g@257@01)) (= (inv@522@01 r) r))
  :pattern ((inv@522@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@522@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
  :pattern ((inv@522@01 r))
  :qid |quant-u-383|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@524@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r) (= r (inv@522@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@524@01 r))
    $Perm.No)
  
  :qid |quant-u-385|))))
(check-sat)
; unsat
(pop) ; 8
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r) (= r (inv@522@01 r)))
    (= (- $Perm.Write (pTaken@524@01 r)) $Perm.No))
  
  :qid |quant-u-386|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@525@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@525@01  $FVF<next>)))
      (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r)))
    (=>
      (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r))
      (Set_in r ($FVF.domain_next (as sm@525@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@525@01  $FVF<next>))))
  :qid |qp.fvfDomDef320|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@525@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@525@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef318|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@525@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef319|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@525@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((n@521@01 $Ref)) (!
  (=>
    (Set_in n@521@01 g@257@01)
    (and (= (inv@522@01 n@521@01) n@521@01) (img@523@01 n@521@01)))
  :pattern ((Set_in n@521@01 g@257@01))
  :pattern ((inv@522@01 n@521@01))
  :pattern ((img@523@01 n@521@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@523@01 r) (Set_in (inv@522@01 r) g@257@01)) (= (inv@522@01 r) r))
  :pattern ((inv@522@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@525@01  $FVF<next>)))
      (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r)))
    (=>
      (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r))
      (Set_in r ($FVF.domain_next (as sm@525@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@525@01  $FVF<next>))))
  :qid |qp.fvfDomDef320|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@522@01 r) g@257@01) (img@523@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@525@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@525@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef318|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@525@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef319|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@522@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@494@01  $FVF<next>) r) r))
    :pattern ((inv@522@01 r))
    :qid |quant-u-383|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@525@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 7
(assert (not (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@525@01  $FVF<next>)) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 2,26s
; (get-info :all-statistics)
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@525@01  $FVF<next>)) g@257@01)))
; [eval] unshared_graph($$(g))
; [eval] $$(g)
(push) ; 7
(declare-const n@526@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@526@01 g@257@01))
(pop) ; 8
(declare-fun inv@527@01 ($Ref) $Ref)
(declare-fun img@528@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@529@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@529@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@529@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef321|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@529@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef322|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@526@01 $Ref) (n2@526@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@526@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@529@01  $FVF<next>) n1@526@01) n1@526@01))
      (and
        (Set_in n2@526@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@529@01  $FVF<next>) n2@526@01) n2@526@01))
      (= n1@526@01 n2@526@01))
    (= n1@526@01 n2@526@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@526@01 $Ref)) (!
  (=>
    (Set_in n@526@01 g@257@01)
    (and (= (inv@527@01 n@526@01) n@526@01) (img@528@01 n@526@01)))
  :pattern ((Set_in n@526@01 g@257@01))
  :pattern ((inv@527@01 n@526@01))
  :pattern ((img@528@01 n@526@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@528@01 r) (Set_in (inv@527@01 r) g@257@01)) (= (inv@527@01 r) r))
  :pattern ((inv@527@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@527@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@529@01  $FVF<next>) r) r))
  :pattern ((inv@527@01 r))
  :qid |quant-u-388|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@530@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r) (= r (inv@527@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@530@01 r))
    $Perm.No)
  
  :qid |quant-u-390|))))
(check-sat)
; unsat
(pop) ; 8
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r) (= r (inv@527@01 r)))
    (= (- $Perm.Write (pTaken@530@01 r)) $Perm.No))
  
  :qid |quant-u-391|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@531@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@531@01  $FVF<next>)))
      (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r)))
    (=>
      (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r))
      (Set_in r ($FVF.domain_next (as sm@531@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@531@01  $FVF<next>))))
  :qid |qp.fvfDomDef325|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@531@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@531@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef323|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@531@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef324|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@531@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@529@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@529@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef321|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@529@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef322|)))
(assert (forall ((n@526@01 $Ref)) (!
  (=>
    (Set_in n@526@01 g@257@01)
    (and (= (inv@527@01 n@526@01) n@526@01) (img@528@01 n@526@01)))
  :pattern ((Set_in n@526@01 g@257@01))
  :pattern ((inv@527@01 n@526@01))
  :pattern ((img@528@01 n@526@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@528@01 r) (Set_in (inv@527@01 r) g@257@01)) (= (inv@527@01 r) r))
  :pattern ((inv@527@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@531@01  $FVF<next>)))
      (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r)))
    (=>
      (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r))
      (Set_in r ($FVF.domain_next (as sm@531@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@531@01  $FVF<next>))))
  :qid |qp.fvfDomDef325|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@527@01 r) g@257@01) (img@528@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@531@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@531@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef323|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@531@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef324|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@527@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@529@01  $FVF<next>) r) r))
    :pattern ((inv@527@01 r))
    :qid |quant-u-388|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@531@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 7
(assert (not (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@531@01  $FVF<next>)) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 2,95s
; (get-info :all-statistics)
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@531@01  $FVF<next>)) g@257@01)))
; [eval] $$(g) == old_g
; [eval] $$(g)
(push) ; 7
(declare-const n@532@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@532@01 g@257@01))
(pop) ; 8
(declare-fun inv@533@01 ($Ref) $Ref)
(declare-fun img@534@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@535@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@535@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@535@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef326|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@535@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef327|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@532@01 $Ref) (n2@532@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@532@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@535@01  $FVF<next>) n1@532@01) n1@532@01))
      (and
        (Set_in n2@532@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@535@01  $FVF<next>) n2@532@01) n2@532@01))
      (= n1@532@01 n2@532@01))
    (= n1@532@01 n2@532@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@532@01 $Ref)) (!
  (=>
    (Set_in n@532@01 g@257@01)
    (and (= (inv@533@01 n@532@01) n@532@01) (img@534@01 n@532@01)))
  :pattern ((Set_in n@532@01 g@257@01))
  :pattern ((inv@533@01 n@532@01))
  :pattern ((img@534@01 n@532@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@534@01 r) (Set_in (inv@533@01 r) g@257@01)) (= (inv@533@01 r) r))
  :pattern ((inv@533@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@533@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@535@01  $FVF<next>) r) r))
  :pattern ((inv@533@01 r))
  :qid |quant-u-393|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@536@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r) (= r (inv@533@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@536@01 r))
    $Perm.No)
  
  :qid |quant-u-395|))))
(check-sat)
; unsat
(pop) ; 8
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r) (= r (inv@533@01 r)))
    (= (- $Perm.Write (pTaken@536@01 r)) $Perm.No))
  
  :qid |quant-u-396|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@537@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@537@01  $FVF<next>)))
      (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r)))
    (=>
      (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r))
      (Set_in r ($FVF.domain_next (as sm@537@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@537@01  $FVF<next>))))
  :qid |qp.fvfDomDef330|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@537@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@537@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef328|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@537@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef329|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@537@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@535@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@535@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef326|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@535@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef327|)))
(assert (forall ((n@532@01 $Ref)) (!
  (=>
    (Set_in n@532@01 g@257@01)
    (and (= (inv@533@01 n@532@01) n@532@01) (img@534@01 n@532@01)))
  :pattern ((Set_in n@532@01 g@257@01))
  :pattern ((inv@533@01 n@532@01))
  :pattern ((img@534@01 n@532@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@534@01 r) (Set_in (inv@533@01 r) g@257@01)) (= (inv@533@01 r) r))
  :pattern ((inv@533@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@537@01  $FVF<next>)))
      (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r)))
    (=>
      (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r))
      (Set_in r ($FVF.domain_next (as sm@537@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@537@01  $FVF<next>))))
  :qid |qp.fvfDomDef330|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@533@01 r) g@257@01) (img@534@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@537@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@537@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef328|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@537@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef329|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@533@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@535@01  $FVF<next>) r) r))
    :pattern ((inv@533@01 r))
    :qid |quant-u-393|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@537@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 7
(assert (not (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@537@01  $FVF<next>)) g@257@01) old_g@317@01)))
(check-sat)
; unsat
(pop) ; 7
; 2,44s
; (get-info :all-statistics)
(assert (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@537@01  $FVF<next>)) g@257@01) old_g@317@01))
; [eval] exists_path($$(g), x, last)
; [eval] $$(g)
(push) ; 7
(declare-const n@538@01 $Ref)
(push) ; 8
; [eval] (n in refs)
(assert (Set_in n@538@01 g@257@01))
(pop) ; 8
(declare-fun inv@539@01 ($Ref) $Ref)
(declare-fun img@540@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@541@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@541@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@541@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef331|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@541@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef332|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((n1@538@01 $Ref) (n2@538@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@538@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@541@01  $FVF<next>) n1@538@01) n1@538@01))
      (and
        (Set_in n2@538@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@541@01  $FVF<next>) n2@538@01) n2@538@01))
      (= n1@538@01 n2@538@01))
    (= n1@538@01 n2@538@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@538@01 $Ref)) (!
  (=>
    (Set_in n@538@01 g@257@01)
    (and (= (inv@539@01 n@538@01) n@538@01) (img@540@01 n@538@01)))
  :pattern ((Set_in n@538@01 g@257@01))
  :pattern ((inv@539@01 n@538@01))
  :pattern ((img@540@01 n@538@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@540@01 r) (Set_in (inv@539@01 r) g@257@01)) (= (inv@539@01 r) r))
  :pattern ((inv@539@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@539@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@541@01  $FVF<next>) r) r))
  :pattern ((inv@539@01 r))
  :qid |quant-u-398|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@542@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r) (= r (inv@539@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@542@01 r))
    $Perm.No)
  
  :qid |quant-u-400|))))
(check-sat)
; unsat
(pop) ; 8
; 0,06s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r) (= r (inv@539@01 r)))
    (= (- $Perm.Write (pTaken@542@01 r)) $Perm.No))
  
  :qid |quant-u-401|))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@543@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@543@01  $FVF<next>)))
      (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r)))
    (=>
      (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r))
      (Set_in r ($FVF.domain_next (as sm@543@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@543@01  $FVF<next>))))
  :qid |qp.fvfDomDef335|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@543@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@543@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef333|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@543@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef334|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@543@01  $FVF<next>)) g@257@01))
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@541@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@541@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef331|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@541@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef332|)))
(assert (forall ((n@538@01 $Ref)) (!
  (=>
    (Set_in n@538@01 g@257@01)
    (and (= (inv@539@01 n@538@01) n@538@01) (img@540@01 n@538@01)))
  :pattern ((Set_in n@538@01 g@257@01))
  :pattern ((inv@539@01 n@538@01))
  :pattern ((img@540@01 n@538@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@540@01 r) (Set_in (inv@539@01 r) g@257@01)) (= (inv@539@01 r) r))
  :pattern ((inv@539@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@543@01  $FVF<next>)))
      (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r)))
    (=>
      (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r))
      (Set_in r ($FVF.domain_next (as sm@543@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@543@01  $FVF<next>))))
  :qid |qp.fvfDomDef335|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@539@01 r) g@257@01) (img@540@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@543@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@543@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef333|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@543@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef334|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@539@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@541@01  $FVF<next>) r) r))
    :pattern ((inv@539@01 r))
    :qid |quant-u-398|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@543@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 7
(assert (not (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@543@01  $FVF<next>)) g@257@01) x@258@01 last@489@01)))
(check-sat)
; unsat
(pop) ; 7
; 2,79s
; (get-info :all-statistics)
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@543@01  $FVF<next>)) g@257@01) x@258@01 last@489@01))
; [eval] last.next != null ==> edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next) ==> exists_path($$(g), last, last.next)
; [eval] last.next != null
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) last@489@01))
(push) ; 7
(assert (not (and (img@323@01 last@489@01) (Set_in (inv@322@01 last@489@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,08s
; (get-info :all-statistics)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
    $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; [then-branch: 65 | Lookup(next, First:(Second:($t@319@01)), last@489@01) != Null | live]
; [else-branch: 65 | Lookup(next, First:(Second:($t@319@01)), last@489@01) == Null | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 65 | Lookup(next, First:(Second:($t@319@01)), last@489@01) != Null]
(assert (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
    $Ref.null)))
; [eval] edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next) ==> exists_path($$(g), last, last.next)
; [eval] edge($$(g), last, last.next) && exists_path($$(g), last.next, last.next)
; [eval] edge($$(g), last, last.next)
; [eval] $$(g)
(push) ; 9
(declare-const n@544@01 $Ref)
(push) ; 10
; [eval] (n in refs)
(assert (Set_in n@544@01 g@257@01))
(pop) ; 10
(declare-fun inv@545@01 ($Ref) $Ref)
(declare-fun img@546@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@547@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@547@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@547@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef336|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@547@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef337|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((n1@544@01 $Ref) (n2@544@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@544@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@547@01  $FVF<next>) n1@544@01) n1@544@01))
      (and
        (Set_in n2@544@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@547@01  $FVF<next>) n2@544@01) n2@544@01))
      (= n1@544@01 n2@544@01))
    (= n1@544@01 n2@544@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@544@01 $Ref)) (!
  (=>
    (Set_in n@544@01 g@257@01)
    (and (= (inv@545@01 n@544@01) n@544@01) (img@546@01 n@544@01)))
  :pattern ((Set_in n@544@01 g@257@01))
  :pattern ((inv@545@01 n@544@01))
  :pattern ((img@546@01 n@544@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@546@01 r) (Set_in (inv@545@01 r) g@257@01)) (= (inv@545@01 r) r))
  :pattern ((inv@545@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@545@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@547@01  $FVF<next>) r) r))
  :pattern ((inv@545@01 r))
  :qid |quant-u-403|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@548@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r) (= r (inv@545@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@548@01 r))
    $Perm.No)
  
  :qid |quant-u-405|))))
(check-sat)
; unsat
(pop) ; 10
; 0,07s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r) (= r (inv@545@01 r)))
    (= (- $Perm.Write (pTaken@548@01 r)) $Perm.No))
  
  :qid |quant-u-406|))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@549@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>)))
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r)))
    (=>
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r))
      (Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>))))
  :qid |qp.fvfDomDef340|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@549@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@549@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef338|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@549@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef339|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01))
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@547@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@547@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef336|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@547@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef337|)))
(assert (forall ((n@544@01 $Ref)) (!
  (=>
    (Set_in n@544@01 g@257@01)
    (and (= (inv@545@01 n@544@01) n@544@01) (img@546@01 n@544@01)))
  :pattern ((Set_in n@544@01 g@257@01))
  :pattern ((inv@545@01 n@544@01))
  :pattern ((img@546@01 n@544@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@546@01 r) (Set_in (inv@545@01 r) g@257@01)) (= (inv@545@01 r) r))
  :pattern ((inv@545@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>)))
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r)))
    (=>
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r))
      (Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>))))
  :qid |qp.fvfDomDef340|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@549@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@549@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef338|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@549@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef339|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@545@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@547@01  $FVF<next>) r) r))
    :pattern ((inv@545@01 r))
    :qid |quant-u-403|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 9
(assert (not (and (img@323@01 last@489@01) (Set_in (inv@322@01 last@489@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(push) ; 9
; [then-branch: 66 | !(edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01))) | live]
; [else-branch: 66 | edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01)) | live]
(push) ; 10
; [then-branch: 66 | !(edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01)))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
(pop) ; 10
(push) ; 10
; [else-branch: 66 | edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01))]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))
; [eval] exists_path($$(g), last.next, last.next)
; [eval] $$(g)
(push) ; 11
(declare-const n@550@01 $Ref)
(push) ; 12
; [eval] (n in refs)
(assert (Set_in n@550@01 g@257@01))
(pop) ; 12
(declare-fun inv@551@01 ($Ref) $Ref)
(declare-fun img@552@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@553@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@553@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef341|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef342|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((n1@550@01 $Ref) (n2@550@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@550@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@553@01  $FVF<next>) n1@550@01) n1@550@01))
      (and
        (Set_in n2@550@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@553@01  $FVF<next>) n2@550@01) n2@550@01))
      (= n1@550@01 n2@550@01))
    (= n1@550@01 n2@550@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@550@01 $Ref)) (!
  (=>
    (Set_in n@550@01 g@257@01)
    (and (= (inv@551@01 n@550@01) n@550@01) (img@552@01 n@550@01)))
  :pattern ((Set_in n@550@01 g@257@01))
  :pattern ((inv@551@01 n@550@01))
  :pattern ((img@552@01 n@550@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@552@01 r) (Set_in (inv@551@01 r) g@257@01)) (= (inv@551@01 r) r))
  :pattern ((inv@551@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@551@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@553@01  $FVF<next>) r) r))
  :pattern ((inv@551@01 r))
  :qid |quant-u-408|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@554@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r) (= r (inv@551@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@554@01 r))
    $Perm.No)
  
  :qid |quant-u-410|))))
(check-sat)
; unsat
(pop) ; 12
; 0,07s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r) (= r (inv@551@01 r)))
    (= (- $Perm.Write (pTaken@554@01 r)) $Perm.No))
  
  :qid |quant-u-411|))))
(check-sat)
; unsat
(pop) ; 12
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@555@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r)))
    (=>
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>))))
  :qid |qp.fvfDomDef345|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@555@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef343|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef344|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01))
(pop) ; 11
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@553@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef341|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef342|)))
(assert (forall ((n@550@01 $Ref)) (!
  (=>
    (Set_in n@550@01 g@257@01)
    (and (= (inv@551@01 n@550@01) n@550@01) (img@552@01 n@550@01)))
  :pattern ((Set_in n@550@01 g@257@01))
  :pattern ((inv@551@01 n@550@01))
  :pattern ((img@552@01 n@550@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@552@01 r) (Set_in (inv@551@01 r) g@257@01)) (= (inv@551@01 r) r))
  :pattern ((inv@551@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r)))
    (=>
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>))))
  :qid |qp.fvfDomDef345|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@555@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef343|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef344|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@551@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@553@01  $FVF<next>) r) r))
    :pattern ((inv@551@01 r))
    :qid |quant-u-408|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 11
(assert (not (and (img@323@01 last@489@01) (Set_in (inv@322@01 last@489@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
(push) ; 11
(assert (not (and (img@323@01 last@489@01) (Set_in (inv@322@01 last@489@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@553@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef341|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef342|)))
(assert (forall ((n@550@01 $Ref)) (!
  (=>
    (Set_in n@550@01 g@257@01)
    (and (= (inv@551@01 n@550@01) n@550@01) (img@552@01 n@550@01)))
  :pattern ((Set_in n@550@01 g@257@01))
  :pattern ((inv@551@01 n@550@01))
  :pattern ((img@552@01 n@550@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@552@01 r) (Set_in (inv@551@01 r) g@257@01)) (= (inv@551@01 r) r))
  :pattern ((inv@551@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r)))
    (=>
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>))))
  :qid |qp.fvfDomDef345|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@555@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef343|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef344|)))
(assert (=>
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@551@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@553@01  $FVF<next>) r) r))
      :pattern ((inv@551@01 r))
      :qid |quant-u-408|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01))))
(assert (or
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))))
(check-sat)
; unknown
(pop) ; 10
; 0,02s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))))
(check-sat)
; unknown
(pop) ; 10
; 0,01s
; (get-info :all-statistics)
; [then-branch: 67 | edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01)) && exists_path[Bool]($$(sm@555@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@489@01), Lookup(next, First:(Second:($t@319@01)), last@489@01)) | live]
; [else-branch: 67 | !(edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01)) && exists_path[Bool]($$(sm@555@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@489@01), Lookup(next, First:(Second:($t@319@01)), last@489@01))) | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 67 | edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01)) && exists_path[Bool]($$(sm@555@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@489@01), Lookup(next, First:(Second:($t@319@01)), last@489@01))]
(assert (and
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
; [eval] exists_path($$(g), last, last.next)
; [eval] $$(g)
(push) ; 11
(declare-const n@556@01 $Ref)
(push) ; 12
; [eval] (n in refs)
(assert (Set_in n@556@01 g@257@01))
(pop) ; 12
(declare-fun inv@557@01 ($Ref) $Ref)
(declare-fun img@558@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@559@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@559@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef346|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef347|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((n1@556@01 $Ref) (n2@556@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@556@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@559@01  $FVF<next>) n1@556@01) n1@556@01))
      (and
        (Set_in n2@556@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@559@01  $FVF<next>) n2@556@01) n2@556@01))
      (= n1@556@01 n2@556@01))
    (= n1@556@01 n2@556@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@556@01 $Ref)) (!
  (=>
    (Set_in n@556@01 g@257@01)
    (and (= (inv@557@01 n@556@01) n@556@01) (img@558@01 n@556@01)))
  :pattern ((Set_in n@556@01 g@257@01))
  :pattern ((inv@557@01 n@556@01))
  :pattern ((img@558@01 n@556@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@558@01 r) (Set_in (inv@557@01 r) g@257@01)) (= (inv@557@01 r) r))
  :pattern ((inv@557@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@557@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@559@01  $FVF<next>) r) r))
  :pattern ((inv@557@01 r))
  :qid |quant-u-413|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@560@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r) (= r (inv@557@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@560@01 r))
    $Perm.No)
  
  :qid |quant-u-415|))))
(check-sat)
; unsat
(pop) ; 12
; 0,09s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r) (= r (inv@557@01 r)))
    (= (- $Perm.Write (pTaken@560@01 r)) $Perm.No))
  
  :qid |quant-u-416|))))
(check-sat)
; unsat
(pop) ; 12
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@561@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r)))
    (=>
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>))))
  :qid |qp.fvfDomDef350|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@561@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef348|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef349|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@561@01  $FVF<next>)) g@257@01))
(pop) ; 11
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@559@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef346|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef347|)))
(assert (forall ((n@556@01 $Ref)) (!
  (=>
    (Set_in n@556@01 g@257@01)
    (and (= (inv@557@01 n@556@01) n@556@01) (img@558@01 n@556@01)))
  :pattern ((Set_in n@556@01 g@257@01))
  :pattern ((inv@557@01 n@556@01))
  :pattern ((img@558@01 n@556@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@558@01 r) (Set_in (inv@557@01 r) g@257@01)) (= (inv@557@01 r) r))
  :pattern ((inv@557@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r)))
    (=>
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>))))
  :qid |qp.fvfDomDef350|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@561@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef348|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef349|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@557@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@559@01  $FVF<next>) r) r))
    :pattern ((inv@557@01 r))
    :qid |quant-u-413|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@561@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 11
(assert (not (and (img@323@01 last@489@01) (Set_in (inv@322@01 last@489@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
(pop) ; 10
(push) ; 10
; [else-branch: 67 | !(edge[Bool]($$(sm@549@01, g@257@01), last@489@01, Lookup(next, First:(Second:($t@319@01)), last@489@01)) && exists_path[Bool]($$(sm@555@01, g@257@01), Lookup(next, First:(Second:($t@319@01)), last@489@01), Lookup(next, First:(Second:($t@319@01)), last@489@01)))]
(assert (not
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@559@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef346|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef347|)))
(assert (forall ((n@556@01 $Ref)) (!
  (=>
    (Set_in n@556@01 g@257@01)
    (and (= (inv@557@01 n@556@01) n@556@01) (img@558@01 n@556@01)))
  :pattern ((Set_in n@556@01 g@257@01))
  :pattern ((inv@557@01 n@556@01))
  :pattern ((img@558@01 n@556@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@558@01 r) (Set_in (inv@557@01 r) g@257@01)) (= (inv@557@01 r) r))
  :pattern ((inv@557@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r)))
    (=>
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>))))
  :qid |qp.fvfDomDef350|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@561@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef348|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef349|)))
(assert (=>
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@557@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@559@01  $FVF<next>) r) r))
      :pattern ((inv@557@01 r))
      :qid |quant-u-413|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@561@01  $FVF<next>)) g@257@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))))
(pop) ; 8
(push) ; 8
; [else-branch: 65 | Lookup(next, First:(Second:($t@319@01)), last@489@01) == Null]
(assert (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
  $Ref.null))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@547@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@547@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef336|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@547@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef337|)))
(assert (forall ((n@544@01 $Ref)) (!
  (=>
    (Set_in n@544@01 g@257@01)
    (and (= (inv@545@01 n@544@01) n@544@01) (img@546@01 n@544@01)))
  :pattern ((Set_in n@544@01 g@257@01))
  :pattern ((inv@545@01 n@544@01))
  :pattern ((img@546@01 n@544@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@546@01 r) (Set_in (inv@545@01 r) g@257@01)) (= (inv@545@01 r) r))
  :pattern ((inv@545@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>)))
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r)))
    (=>
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r))
      (Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@549@01  $FVF<next>))))
  :qid |qp.fvfDomDef340|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@545@01 r) g@257@01) (img@546@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@549@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@549@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef338|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@549@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef339|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@553@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef341|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@553@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef342|)))
(assert (forall ((n@550@01 $Ref)) (!
  (=>
    (Set_in n@550@01 g@257@01)
    (and (= (inv@551@01 n@550@01) n@550@01) (img@552@01 n@550@01)))
  :pattern ((Set_in n@550@01 g@257@01))
  :pattern ((inv@551@01 n@550@01))
  :pattern ((img@552@01 n@550@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@552@01 r) (Set_in (inv@551@01 r) g@257@01)) (= (inv@551@01 r) r))
  :pattern ((inv@551@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r)))
    (=>
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@555@01  $FVF<next>))))
  :qid |qp.fvfDomDef345|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@551@01 r) g@257@01) (img@552@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@555@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef343|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@555@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef344|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@559@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef346|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@559@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef347|)))
(assert (forall ((n@556@01 $Ref)) (!
  (=>
    (Set_in n@556@01 g@257@01)
    (and (= (inv@557@01 n@556@01) n@556@01) (img@558@01 n@556@01)))
  :pattern ((Set_in n@556@01 g@257@01))
  :pattern ((inv@557@01 n@556@01))
  :pattern ((img@558@01 n@556@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@558@01 r) (Set_in (inv@557@01 r) g@257@01)) (= (inv@557@01 r) r))
  :pattern ((inv@557@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r)))
    (=>
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@561@01  $FVF<next>))))
  :qid |qp.fvfDomDef350|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@557@01 r) g@257@01) (img@558@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@561@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef348|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@561@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef349|)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
      $Ref.null))
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
        $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@545@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@547@01  $FVF<next>) r) r))
      :pattern ((inv@545@01 r))
      :qid |quant-u-403|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01)
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@551@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@553@01  $FVF<next>) r) r))
          :pattern ((inv@551@01 r))
          :qid |quant-u-408|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01)))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
    (=>
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@557@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@559@01  $FVF<next>) r) r))
          :pattern ((inv@557@01 r))
          :qid |quant-u-413|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@561@01  $FVF<next>)) g@257@01)))
    (or
      (not
        (and
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))))))
; Joined path conditions
(assert (or
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
    $Ref.null)
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
      $Ref.null))))
(push) ; 7
(assert (not (=>
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
        $Ref.null))
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@561@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)))))
(check-sat)
; unsat
(pop) ; 7
; 3,82s
; (get-info :all-statistics)
(assert (=>
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01)
        $Ref.null))
    (and
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@549@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@555@01  $FVF<next>)) g@257@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@561@01  $FVF<next>)) g@257@01) last@489@01 ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@489@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 56 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null]
(assert (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null))
(pop) ; 6
; [eval] !(last.next != null)
; [eval] last.next != null
(push) ; 6
(assert (not (and (img@323@01 last@318@01) (Set_in (inv@322@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
    $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0,11s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; [then-branch: 68 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null | live]
; [else-branch: 68 | Lookup(next, First:(Second:($t@319@01)), last@318@01) != Null | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 68 | Lookup(next, First:(Second:($t@319@01)), last@318@01) == Null]
(assert (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) last@318@01)
  $Ref.null))
; [exec]
; link(g, last, y)
; [eval] (x in g)
; [eval] y != null ==> (y in g)
; [eval] y != null
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (= y@259@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= y@259@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0,00s
; (get-info :all-statistics)
; [then-branch: 69 | y@259@01 != Null | live]
; [else-branch: 69 | y@259@01 == Null | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 69 | y@259@01 != Null]
(assert (not (= y@259@01 $Ref.null)))
; [eval] (y in g)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (not (= y@259@01 $Ref.null)))
(push) ; 7
(assert (not (=> (not (= y@259@01 $Ref.null)) (Set_in y@259@01 g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(assert (=> (not (= y@259@01 $Ref.null)) (Set_in y@259@01 g@257@01)))
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n@562@01 $Ref)
(push) ; 7
; [eval] (n in g)
(assert (Set_in n@562@01 g@257@01))
(declare-const sm@563@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@563@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@563@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef351|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@563@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef352|)))
(pop) ; 7
(declare-fun inv@564@01 ($Ref) $Ref)
(declare-fun img@565@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@563@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@563@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef351|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@563@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef352|)))
; Nested auxiliary terms: non-globals
(declare-const sm@566@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@566@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef353|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef354|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@562@01 $Ref) (n2@562@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@562@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n1@562@01) n1@562@01))
      (and
        (Set_in n2@562@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n2@562@01) n2@562@01))
      (= n1@562@01 n2@562@01))
    (= n1@562@01 n2@562@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@562@01 $Ref)) (!
  (=>
    (Set_in n@562@01 g@257@01)
    (and (= (inv@564@01 n@562@01) n@562@01) (img@565@01 n@562@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@563@01  $FVF<next>) n@562@01) n@562@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@565@01 r) (Set_in (inv@564@01 r) g@257@01)) (= (inv@564@01 r) r))
  :pattern ((inv@564@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@564@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) r) r))
  :pattern ((inv@564@01 r))
  :qid |quant-u-418|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@567@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@564@01 r) g@257@01) (img@565@01 r) (= r (inv@564@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@567@01 r))
    $Perm.No)
  
  :qid |quant-u-420|))))
(check-sat)
; unsat
(pop) ; 7
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@564@01 r) g@257@01) (img@565@01 r) (= r (inv@564@01 r)))
    (= (- $Perm.Write (pTaken@567@01 r)) $Perm.No))
  
  :qid |quant-u-421|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@568@01 $Ref)
(set-option :timeout 0)
(push) ; 7
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 8
; [then-branch: 70 | !(n$0@568@01 in g@257@01) | live]
; [else-branch: 70 | n$0@568@01 in g@257@01 | live]
(push) ; 9
; [then-branch: 70 | !(n$0@568@01 in g@257@01)]
(assert (not (Set_in n$0@568@01 g@257@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 70 | n$0@568@01 in g@257@01]
(assert (Set_in n$0@568@01 g@257@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@566@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
    :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
    :qid |qp.fvfValDef353|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef354|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))
(push) ; 10
(assert (not (and (img@323@01 n$0@568@01) (Set_in (inv@322@01 n$0@568@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@566@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef353|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef354|)))
(assert (=>
  (Set_in n$0@568@01 g@257@01)
  (and
    (Set_in n$0@568@01 g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))))
(assert (or (Set_in n$0@568@01 g@257@01) (not (Set_in n$0@568@01 g@257@01))))
(push) ; 8
; [then-branch: 71 | n$0@568@01 in g@257@01 && Lookup(next, sm@566@01, n$0@568@01) != Null | live]
; [else-branch: 71 | !(n$0@568@01 in g@257@01 && Lookup(next, sm@566@01, n$0@568@01) != Null) | live]
(push) ; 9
; [then-branch: 71 | n$0@568@01 in g@257@01 && Lookup(next, sm@566@01, n$0@568@01) != Null]
(assert (and
  (Set_in n$0@568@01 g@257@01)
  (not (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@566@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
    :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
    :qid |qp.fvfValDef353|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef354|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))
(push) ; 10
(assert (not (and (img@323@01 n$0@568@01) (Set_in (inv@322@01 n$0@568@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(push) ; 9
; [else-branch: 71 | !(n$0@568@01 in g@257@01 && Lookup(next, sm@566@01, n$0@568@01) != Null)]
(assert (not
  (and
    (Set_in n$0@568@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@566@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef353|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef354|)))
(assert (=>
  (and
    (Set_in n$0@568@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))
  (and
    (Set_in n$0@568@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@568@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null))))
  (and
    (Set_in n$0@568@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@566@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef353|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@566@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef354|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@568@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@568@01 g@257@01)
      (and
        (Set_in n$0@568@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01)))
    (or (Set_in n$0@568@01 g@257@01) (not (Set_in n$0@568@01 g@257@01)))
    (=>
      (and
        (Set_in n$0@568@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))
      (and
        (Set_in n$0@568@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01)))
    (or
      (not
        (and
          (Set_in n$0@568@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01)
              $Ref.null))))
      (and
        (Set_in n$0@568@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22-aux|)))
(assert (forall ((n$0@568@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@568@01 g@257@01)
      (and
        (Set_in n$0@568@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01)))
    (or (Set_in n$0@568@01 g@257@01) (not (Set_in n$0@568@01 g@257@01)))
    (=>
      (and
        (Set_in n$0@568@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))
      (and
        (Set_in n$0@568@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01)))
    (or
      (not
        (and
          (Set_in n$0@568@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01)
              $Ref.null))))
      (and
        (Set_in n$0@568@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))))
  :pattern ((Set_in n$0@568@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22-aux|)))
(push) ; 7
(assert (not (forall ((n$0@568@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@568@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) g@257@01))
  :pattern ((Set_in n$0@568@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@568@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@568@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) g@257@01))
  :pattern ((Set_in n$0@568@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n$0@568@01) n$0@568@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@287@14@287@22|)))
(declare-const $t@569@01 $Snap)
(assert (= $t@569@01 ($Snap.combine ($Snap.first $t@569@01) ($Snap.second $t@569@01))))
(assert (= ($Snap.first $t@569@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@569@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@569@01))
    ($Snap.second ($Snap.second $t@569@01)))))
(declare-const n$1@570@01 $Ref)
(push) ; 7
; [eval] (n$1 in g)
(assert (Set_in n$1@570@01 g@257@01))
(declare-const sm@571@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 7
(declare-fun inv@572@01 ($Ref) $Ref)
(declare-fun img@573@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n$11@570@01 $Ref) (n$12@570@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@570@01 g@257@01)
      (Set_in n$12@570@01 g@257@01)
      (= n$11@570@01 n$12@570@01))
    (= n$11@570@01 n$12@570@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@570@01 $Ref)) (!
  (=>
    (Set_in n$1@570@01 g@257@01)
    (and (= (inv@572@01 n$1@570@01) n$1@570@01) (img@573@01 n$1@570@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) n$1@570@01) n$1@570@01))
  :qid |quant-u-423|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)) (= (inv@572@01 r) r))
  :pattern ((inv@572@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@570@01 $Ref)) (!
  (=> (Set_in n$1@570@01 g@257@01) (not (= n$1@570@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) n$1@570@01) n$1@570@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@574@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef356|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef357|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@572@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) r) r))
  :pattern ((inv@572@01 r))
  :qid |quant-u-424|)))
(assert (=
  ($Snap.second ($Snap.second $t@569@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@569@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@569@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@569@01))) $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@575@01 $Ref)
(push) ; 7
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 8
; [then-branch: 72 | !(n$2@575@01 in g@257@01) | live]
; [else-branch: 72 | n$2@575@01 in g@257@01 | live]
(push) ; 9
; [then-branch: 72 | !(n$2@575@01 in g@257@01)]
(assert (not (Set_in n$2@575@01 g@257@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 72 | n$2@575@01 in g@257@01]
(assert (Set_in n$2@575@01 g@257@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
    :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
    :qid |qp.fvfValDef356|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef357|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01))
(push) ; 10
(assert (not (and (img@573@01 n$2@575@01) (Set_in (inv@572@01 n$2@575@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef356|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef357|)))
(assert (=>
  (Set_in n$2@575@01 g@257@01)
  (and
    (Set_in n$2@575@01 g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01))))
(assert (or (Set_in n$2@575@01 g@257@01) (not (Set_in n$2@575@01 g@257@01))))
(push) ; 8
; [then-branch: 73 | n$2@575@01 in g@257@01 && Lookup(next, sm@574@01, n$2@575@01) != Null | live]
; [else-branch: 73 | !(n$2@575@01 in g@257@01 && Lookup(next, sm@574@01, n$2@575@01) != Null) | live]
(push) ; 9
; [then-branch: 73 | n$2@575@01 in g@257@01 && Lookup(next, sm@574@01, n$2@575@01) != Null]
(assert (and
  (Set_in n$2@575@01 g@257@01)
  (not (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
    :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
    :qid |qp.fvfValDef356|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef357|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01))
(push) ; 10
(assert (not (and (img@573@01 n$2@575@01) (Set_in (inv@572@01 n$2@575@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(push) ; 9
; [else-branch: 73 | !(n$2@575@01 in g@257@01 && Lookup(next, sm@574@01, n$2@575@01) != Null)]
(assert (not
  (and
    (Set_in n$2@575@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef356|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef357|)))
(assert (=>
  (and
    (Set_in n$2@575@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))
  (and
    (Set_in n$2@575@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@575@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null))))
  (and
    (Set_in n$2@575@01 g@257@01)
    (not (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef356|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef357|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@575@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@575@01 g@257@01)
      (and
        (Set_in n$2@575@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01)))
    (or (Set_in n$2@575@01 g@257@01) (not (Set_in n$2@575@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@575@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))
      (and
        (Set_in n$2@575@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01)))
    (or
      (not
        (and
          (Set_in n$2@575@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01)
              $Ref.null))))
      (and
        (Set_in n$2@575@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) g@257@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@288@13@288@21-aux|)))
(assert (forall ((n$2@575@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@575@01 g@257@01)
      (and
        (Set_in n$2@575@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01)))
    (or (Set_in n$2@575@01 g@257@01) (not (Set_in n$2@575@01 g@257@01)))
    (=>
      (and
        (Set_in n$2@575@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))
      (and
        (Set_in n$2@575@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01)))
    (or
      (not
        (and
          (Set_in n$2@575@01 g@257@01)
          (not
            (=
              ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01)
              $Ref.null))))
      (and
        (Set_in n$2@575@01 g@257@01)
        (not
          (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))))
  :pattern ((Set_in n$2@575@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@288@13@288@21-aux|)))
(assert (forall ((n$2@575@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@575@01 g@257@01)
      (not
        (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) g@257@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) g@257@01))
  :pattern ((Set_in n$2@575@01 g@257@01) ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n$2@575@01) n$2@575@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@288@13@288@21|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@569@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@569@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@569@01))))
  $Snap.unit))
; [eval] x.next == y
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
      (=
        ($FVF.lookup_next (as sm@574@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
    :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
    :qid |qp.fvfValDef356|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@574@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef357|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) last@318@01) last@318@01))
(push) ; 7
(assert (not (and (img@573@01 last@318@01) (Set_in (inv@572@01 last@318@01) g@257@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(assert (= ($FVF.lookup_next (as sm@574@01  $FVF<next>) last@318@01) y@259@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01)))))
  $Snap.unit))
; [eval] y == null ==> $$(g) == old($$(g))
; [eval] y == null
(push) ; 7
; [then-branch: 74 | y@259@01 == Null | dead]
; [else-branch: 74 | y@259@01 != Null | live]
(push) ; 8
; [else-branch: 74 | y@259@01 != Null]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01))))))
  $Snap.unit))
; [eval] y != null ==> (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y))
; [eval] y != null
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (= y@259@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; [then-branch: 75 | y@259@01 != Null | live]
; [else-branch: 75 | y@259@01 == Null | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 75 | y@259@01 != Null]
; [eval] (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y))
(declare-const v1@576@01 $Ref)
(declare-const v2@577@01 $Ref)
(push) ; 9
; [eval] edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y)
; [eval] edge($$(g), v1, v2)
; [eval] $$(g)
(push) ; 10
(declare-const n@578@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@578@01 g@257@01))
(pop) ; 11
(declare-fun inv@579@01 ($Ref) $Ref)
(declare-fun img@580@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@578@01 $Ref) (n2@578@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@578@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n1@578@01) n1@578@01))
      (and
        (Set_in n2@578@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) n2@578@01) n2@578@01))
      (= n1@578@01 n2@578@01))
    (= n1@578@01 n2@578@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@578@01 $Ref)) (!
  (=>
    (Set_in n@578@01 g@257@01)
    (and (= (inv@579@01 n@578@01) n@578@01) (img@580@01 n@578@01)))
  :pattern ((Set_in n@578@01 g@257@01))
  :pattern ((inv@579@01 n@578@01))
  :pattern ((img@580@01 n@578@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@580@01 r) (Set_in (inv@579@01 r) g@257@01)) (= (inv@579@01 r) r))
  :pattern ((inv@579@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@579@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) r) r))
  :pattern ((inv@579@01 r))
  :qid |quant-u-426|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@581@01 ((r $Ref) (v1@576@01 $Ref) (v2@577@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r) (= r (inv@579@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@581@01 r v1@576@01 v2@577@01))
    $Perm.No)
  
  :qid |quant-u-428|))))
(check-sat)
; unsat
(pop) ; 11
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r) (= r (inv@579@01 r)))
    (= (- $Perm.Write (pTaken@581@01 r v1@576@01 v2@577@01)) $Perm.No))
  
  :qid |quant-u-429|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@582@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r)))
    (=>
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>))))
  :qid |qp.fvfDomDef360|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@582@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef358|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef359|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@582@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((n@578@01 $Ref)) (!
  (=>
    (Set_in n@578@01 g@257@01)
    (and (= (inv@579@01 n@578@01) n@578@01) (img@580@01 n@578@01)))
  :pattern ((Set_in n@578@01 g@257@01))
  :pattern ((inv@579@01 n@578@01))
  :pattern ((img@580@01 n@578@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@580@01 r) (Set_in (inv@579@01 r) g@257@01)) (= (inv@579@01 r) r))
  :pattern ((inv@579@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r)))
    (=>
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>))))
  :qid |qp.fvfDomDef360|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@582@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef358|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef359|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@579@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) r) r))
    :pattern ((inv@579@01 r))
    :qid |quant-u-426|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@582@01  $FVF<next>)) g@257@01)))
; [eval] edge(old($$(g)), v1, v2) || v1 == x && v2 == y
; [eval] edge(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 10
(declare-const n@583@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@583@01 g@257@01))
(pop) ; 11
(declare-fun inv@584@01 ($Ref) $Ref)
(declare-fun img@585@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@583@01 $Ref) (n2@583@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@583@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n1@583@01) n1@583@01))
      (and
        (Set_in n2@583@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) n2@583@01) n2@583@01))
      (= n1@583@01 n2@583@01))
    (= n1@583@01 n2@583@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@583@01 $Ref)) (!
  (=>
    (Set_in n@583@01 g@257@01)
    (and (= (inv@584@01 n@583@01) n@583@01) (img@585@01 n@583@01)))
  :pattern ((Set_in n@583@01 g@257@01))
  :pattern ((inv@584@01 n@583@01))
  :pattern ((img@585@01 n@583@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@585@01 r) (Set_in (inv@584@01 r) g@257@01)) (= (inv@584@01 r) r))
  :pattern ((inv@584@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@584@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) r) r))
  :pattern ((inv@584@01 r))
  :qid |quant-u-431|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@586@01 ((r $Ref) (v1@576@01 $Ref) (v2@577@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r) (= r (inv@584@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@586@01 r v1@576@01 v2@577@01))
    $Perm.No)
  
  :qid |quant-u-433|))))
(check-sat)
; unsat
(pop) ; 11
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r) (= r (inv@584@01 r)))
    (= (- $Perm.Write (pTaken@586@01 r v1@576@01 v2@577@01)) $Perm.No))
  
  :qid |quant-u-434|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@587@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r)))
    (=>
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>))))
  :qid |qp.fvfDomDef363|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@587@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef361|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef362|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((n@583@01 $Ref)) (!
  (=>
    (Set_in n@583@01 g@257@01)
    (and (= (inv@584@01 n@583@01) n@583@01) (img@585@01 n@583@01)))
  :pattern ((Set_in n@583@01 g@257@01))
  :pattern ((inv@584@01 n@583@01))
  :pattern ((img@585@01 n@583@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@585@01 r) (Set_in (inv@584@01 r) g@257@01)) (= (inv@584@01 r) r))
  :pattern ((inv@584@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r)))
    (=>
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>))))
  :qid |qp.fvfDomDef363|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@587@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef361|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef362|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@584@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) r) r))
    :pattern ((inv@584@01 r))
    :qid |quant-u-431|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 76 | edge[Bool]($$(sm@587@01, g@257@01), v1@576@01, v2@577@01) | live]
; [else-branch: 76 | !(edge[Bool]($$(sm@587@01, g@257@01), v1@576@01, v2@577@01)) | live]
(push) ; 11
; [then-branch: 76 | edge[Bool]($$(sm@587@01, g@257@01), v1@576@01, v2@577@01)]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
(pop) ; 11
(push) ; 11
; [else-branch: 76 | !(edge[Bool]($$(sm@587@01, g@257@01), v1@576@01, v2@577@01))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01)))
; [eval] v1 == x && v2 == y
; [eval] v1 == x
(push) ; 12
; [then-branch: 77 | v1@576@01 != last@318@01 | live]
; [else-branch: 77 | v1@576@01 == last@318@01 | live]
(push) ; 13
; [then-branch: 77 | v1@576@01 != last@318@01]
(assert (not (= v1@576@01 last@318@01)))
(pop) ; 13
(push) ; 13
; [else-branch: 77 | v1@576@01 == last@318@01]
(assert (= v1@576@01 last@318@01))
; [eval] v2 == y
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (or (= v1@576@01 last@318@01) (not (= v1@576@01 last@318@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (=>
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
  (and
    (not
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
    (or (= v1@576@01 last@318@01) (not (= v1@576@01 last@318@01))))))
(assert (or
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01)))
(pop) ; 9
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@578@01 $Ref)) (!
  (=>
    (Set_in n@578@01 g@257@01)
    (and (= (inv@579@01 n@578@01) n@578@01) (img@580@01 n@578@01)))
  :pattern ((Set_in n@578@01 g@257@01))
  :pattern ((inv@579@01 n@578@01))
  :pattern ((img@580@01 n@578@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@580@01 r) (Set_in (inv@579@01 r) g@257@01)) (= (inv@579@01 r) r))
  :pattern ((inv@579@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r)))
    (=>
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>))))
  :qid |qp.fvfDomDef360|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@582@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef358|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef359|)))
(assert (forall ((n@583@01 $Ref)) (!
  (=>
    (Set_in n@583@01 g@257@01)
    (and (= (inv@584@01 n@583@01) n@583@01) (img@585@01 n@583@01)))
  :pattern ((Set_in n@583@01 g@257@01))
  :pattern ((inv@584@01 n@583@01))
  :pattern ((img@585@01 n@583@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@585@01 r) (Set_in (inv@584@01 r) g@257@01)) (= (inv@584@01 r) r))
  :pattern ((inv@584@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r)))
    (=>
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>))))
  :qid |qp.fvfDomDef363|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@587@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef361|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef362|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@579@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) r) r))
  :pattern ((inv@579@01 r))
  :qid |quant-u-426|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@582@01  $FVF<next>)) g@257@01))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@584@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) r) r))
  :pattern ((inv@584@01 r))
  :qid |quant-u-431|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@576@01 $Ref) (v2@577@01 $Ref)) (!
  (and
    (=>
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
      (and
        (not
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
        (or (= v1@576@01 last@318@01) (not (= v1@576@01 last@318@01)))))
    (or
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01)))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@291@27@293@78-aux|)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((n@578@01 $Ref)) (!
  (=>
    (Set_in n@578@01 g@257@01)
    (and (= (inv@579@01 n@578@01) n@578@01) (img@580@01 n@578@01)))
  :pattern ((Set_in n@578@01 g@257@01))
  :pattern ((inv@579@01 n@578@01))
  :pattern ((img@580@01 n@578@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@580@01 r) (Set_in (inv@579@01 r) g@257@01)) (= (inv@579@01 r) r))
  :pattern ((inv@579@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r)))
    (=>
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@582@01  $FVF<next>))))
  :qid |qp.fvfDomDef360|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@579@01 r) g@257@01) (img@580@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@582@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef358|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@582@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef359|)))
(assert (forall ((n@583@01 $Ref)) (!
  (=>
    (Set_in n@583@01 g@257@01)
    (and (= (inv@584@01 n@583@01) n@583@01) (img@585@01 n@583@01)))
  :pattern ((Set_in n@583@01 g@257@01))
  :pattern ((inv@584@01 n@583@01))
  :pattern ((img@585@01 n@583@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@585@01 r) (Set_in (inv@584@01 r) g@257@01)) (= (inv@584@01 r) r))
  :pattern ((inv@584@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r)))
    (=>
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@587@01  $FVF<next>))))
  :qid |qp.fvfDomDef363|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@584@01 r) g@257@01) (img@585@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@587@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef361|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@587@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef362|)))
(assert (=>
  (not (= y@259@01 $Ref.null))
  (and
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@579@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@574@01  $FVF<next>) r) r))
      :pattern ((inv@579@01 r))
      :qid |quant-u-426|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@582@01  $FVF<next>)) g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@584@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@566@01  $FVF<next>) r) r))
      :pattern ((inv@584@01 r))
      :qid |quant-u-431|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01)
    (forall ((v1@576@01 $Ref) (v2@577@01 $Ref)) (!
      (and
        (=>
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
          (and
            (not
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
            (or (= v1@576@01 last@318@01) (not (= v1@576@01 last@318@01)))))
        (or
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01)))
      :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@291@27@293@78-aux|)))))
(assert (=>
  (not (= y@259@01 $Ref.null))
  (forall ((v1@576@01 $Ref) (v2@577@01 $Ref)) (!
    (=
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@582@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01)
      (or
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01)
        (and (= v1@576@01 last@318@01) (= v2@577@01 y@259@01))))
    :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@587@01  $FVF<next>)) g@257@01) v1@576@01 v2@577@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@291@27@293@78|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@569@01))))))
  $Snap.unit))
; [eval] y != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)))
; [eval] y != null
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (= y@259@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 8
; 0,01s
; (get-info :all-statistics)
; [then-branch: 78 | y@259@01 != Null | live]
; [else-branch: 78 | y@259@01 == Null | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 78 | y@259@01 != Null]
; [eval] (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)))
(declare-const v1@588@01 $Ref)
(declare-const v2@589@01 $Ref)
(push) ; 9
; [eval] exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2))
; [eval] exists_path($$(g), v1, v2)
; [eval] $$(g)
(push) ; 10
(declare-const n@590@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@590@01 g@257@01))
(pop) ; 11
(declare-fun inv@591@01 ($Ref) $Ref)
(declare-fun img@592@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@593@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@593@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef364|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef365|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@590@01 $Ref) (n2@590@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@590@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@593@01  $FVF<next>) n1@590@01) n1@590@01))
      (and
        (Set_in n2@590@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@593@01  $FVF<next>) n2@590@01) n2@590@01))
      (= n1@590@01 n2@590@01))
    (= n1@590@01 n2@590@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@590@01 $Ref)) (!
  (=>
    (Set_in n@590@01 g@257@01)
    (and (= (inv@591@01 n@590@01) n@590@01) (img@592@01 n@590@01)))
  :pattern ((Set_in n@590@01 g@257@01))
  :pattern ((inv@591@01 n@590@01))
  :pattern ((img@592@01 n@590@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@592@01 r) (Set_in (inv@591@01 r) g@257@01)) (= (inv@591@01 r) r))
  :pattern ((inv@591@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@591@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@593@01  $FVF<next>) r) r))
  :pattern ((inv@591@01 r))
  :qid |quant-u-436|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@594@01 ((r $Ref) (v1@588@01 $Ref) (v2@589@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r) (= r (inv@591@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@594@01 r v1@588@01 v2@589@01))
    $Perm.No)
  
  :qid |quant-u-438|))))
(check-sat)
; unsat
(pop) ; 11
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r) (= r (inv@591@01 r)))
    (= (- $Perm.Write (pTaken@594@01 r v1@588@01 v2@589@01)) $Perm.No))
  
  :qid |quant-u-439|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@595@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r)))
    (=>
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>))))
  :qid |qp.fvfDomDef368|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@595@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef366|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef367|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@593@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef364|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef365|)))
(assert (forall ((n@590@01 $Ref)) (!
  (=>
    (Set_in n@590@01 g@257@01)
    (and (= (inv@591@01 n@590@01) n@590@01) (img@592@01 n@590@01)))
  :pattern ((Set_in n@590@01 g@257@01))
  :pattern ((inv@591@01 n@590@01))
  :pattern ((img@592@01 n@590@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@592@01 r) (Set_in (inv@591@01 r) g@257@01)) (= (inv@591@01 r) r))
  :pattern ((inv@591@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r)))
    (=>
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>))))
  :qid |qp.fvfDomDef368|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@595@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef366|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef367|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@591@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@593@01  $FVF<next>) r) r))
    :pattern ((inv@591@01 r))
    :qid |quant-u-436|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01)))
; [eval] exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)
; [eval] exists_path(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 10
(declare-const n@596@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@596@01 g@257@01))
(pop) ; 11
(declare-fun inv@597@01 ($Ref) $Ref)
(declare-fun img@598@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@599@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@599@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef369|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef370|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@596@01 $Ref) (n2@596@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@596@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@599@01  $FVF<next>) n1@596@01) n1@596@01))
      (and
        (Set_in n2@596@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@599@01  $FVF<next>) n2@596@01) n2@596@01))
      (= n1@596@01 n2@596@01))
    (= n1@596@01 n2@596@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@596@01 $Ref)) (!
  (=>
    (Set_in n@596@01 g@257@01)
    (and (= (inv@597@01 n@596@01) n@596@01) (img@598@01 n@596@01)))
  :pattern ((Set_in n@596@01 g@257@01))
  :pattern ((inv@597@01 n@596@01))
  :pattern ((img@598@01 n@596@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@598@01 r) (Set_in (inv@597@01 r) g@257@01)) (= (inv@597@01 r) r))
  :pattern ((inv@597@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@597@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@599@01  $FVF<next>) r) r))
  :pattern ((inv@597@01 r))
  :qid |quant-u-441|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@600@01 ((r $Ref) (v1@588@01 $Ref) (v2@589@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r) (= r (inv@597@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@600@01 r v1@588@01 v2@589@01))
    $Perm.No)
  
  :qid |quant-u-443|))))
(check-sat)
; unsat
(pop) ; 11
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r) (= r (inv@597@01 r)))
    (= (- $Perm.Write (pTaken@600@01 r v1@588@01 v2@589@01)) $Perm.No))
  
  :qid |quant-u-444|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@601@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r)))
    (=>
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>))))
  :qid |qp.fvfDomDef373|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@601@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef371|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef372|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@599@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef369|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef370|)))
(assert (forall ((n@596@01 $Ref)) (!
  (=>
    (Set_in n@596@01 g@257@01)
    (and (= (inv@597@01 n@596@01) n@596@01) (img@598@01 n@596@01)))
  :pattern ((Set_in n@596@01 g@257@01))
  :pattern ((inv@597@01 n@596@01))
  :pattern ((img@598@01 n@596@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@598@01 r) (Set_in (inv@597@01 r) g@257@01)) (= (inv@597@01 r) r))
  :pattern ((inv@597@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r)))
    (=>
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>))))
  :qid |qp.fvfDomDef373|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@601@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef371|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef372|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@597@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@599@01  $FVF<next>) r) r))
    :pattern ((inv@597@01 r))
    :qid |quant-u-441|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 79 | exists_path[Bool]($$(sm@601@01, g@257@01), v1@588@01, v2@589@01) | live]
; [else-branch: 79 | !(exists_path[Bool]($$(sm@601@01, g@257@01), v1@588@01, v2@589@01)) | live]
(push) ; 11
; [then-branch: 79 | exists_path[Bool]($$(sm@601@01, g@257@01), v1@588@01, v2@589@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
(pop) ; 11
(push) ; 11
; [else-branch: 79 | !(exists_path[Bool]($$(sm@601@01, g@257@01), v1@588@01, v2@589@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01)))
; [eval] exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)
; [eval] exists_path(old($$(g)), v1, x)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 12
(declare-const n@602@01 $Ref)
(push) ; 13
; [eval] (n in refs)
(assert (Set_in n@602@01 g@257@01))
(pop) ; 13
(declare-fun inv@603@01 ($Ref) $Ref)
(declare-fun img@604@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@605@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@605@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef374|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef375|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((n1@602@01 $Ref) (n2@602@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@602@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) n1@602@01) n1@602@01))
      (and
        (Set_in n2@602@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) n2@602@01) n2@602@01))
      (= n1@602@01 n2@602@01))
    (= n1@602@01 n2@602@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@602@01 $Ref)) (!
  (=>
    (Set_in n@602@01 g@257@01)
    (and (= (inv@603@01 n@602@01) n@602@01) (img@604@01 n@602@01)))
  :pattern ((Set_in n@602@01 g@257@01))
  :pattern ((inv@603@01 n@602@01))
  :pattern ((img@604@01 n@602@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@604@01 r) (Set_in (inv@603@01 r) g@257@01)) (= (inv@603@01 r) r))
  :pattern ((inv@603@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@603@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) r) r))
  :pattern ((inv@603@01 r))
  :qid |quant-u-446|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@606@01 ((r $Ref) (v1@588@01 $Ref) (v2@589@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r) (= r (inv@603@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@606@01 r v1@588@01 v2@589@01))
    $Perm.No)
  
  :qid |quant-u-448|))))
(check-sat)
; unsat
(pop) ; 13
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r) (= r (inv@603@01 r)))
    (= (- $Perm.Write (pTaken@606@01 r v1@588@01 v2@589@01)) $Perm.No))
  
  :qid |quant-u-449|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@607@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r)))
    (=>
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>))))
  :qid |qp.fvfDomDef378|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@607@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef376|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef377|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01))
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@605@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef374|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef375|)))
(assert (forall ((n@602@01 $Ref)) (!
  (=>
    (Set_in n@602@01 g@257@01)
    (and (= (inv@603@01 n@602@01) n@602@01) (img@604@01 n@602@01)))
  :pattern ((Set_in n@602@01 g@257@01))
  :pattern ((inv@603@01 n@602@01))
  :pattern ((img@604@01 n@602@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@604@01 r) (Set_in (inv@603@01 r) g@257@01)) (= (inv@603@01 r) r))
  :pattern ((inv@603@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r)))
    (=>
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>))))
  :qid |qp.fvfDomDef378|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@607@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef376|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef377|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@603@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) r) r))
    :pattern ((inv@603@01 r))
    :qid |quant-u-446|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 12
; [then-branch: 80 | !(exists_path[Bool]($$(sm@607@01, g@257@01), v1@588@01, last@318@01)) | live]
; [else-branch: 80 | exists_path[Bool]($$(sm@607@01, g@257@01), v1@588@01, last@318@01) | live]
(push) ; 13
; [then-branch: 80 | !(exists_path[Bool]($$(sm@607@01, g@257@01), v1@588@01, last@318@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)))
(pop) ; 13
(push) ; 13
; [else-branch: 80 | exists_path[Bool]($$(sm@607@01, g@257@01), v1@588@01, last@318@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01))
; [eval] exists_path(old($$(g)), y, v2)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 14
(declare-const n@608@01 $Ref)
(push) ; 15
; [eval] (n in refs)
(assert (Set_in n@608@01 g@257@01))
(pop) ; 15
(declare-fun inv@609@01 ($Ref) $Ref)
(declare-fun img@610@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@611@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@611@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef379|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef380|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((n1@608@01 $Ref) (n2@608@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@608@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) n1@608@01) n1@608@01))
      (and
        (Set_in n2@608@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) n2@608@01) n2@608@01))
      (= n1@608@01 n2@608@01))
    (= n1@608@01 n2@608@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@608@01 $Ref)) (!
  (=>
    (Set_in n@608@01 g@257@01)
    (and (= (inv@609@01 n@608@01) n@608@01) (img@610@01 n@608@01)))
  :pattern ((Set_in n@608@01 g@257@01))
  :pattern ((inv@609@01 n@608@01))
  :pattern ((img@610@01 n@608@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@610@01 r) (Set_in (inv@609@01 r) g@257@01)) (= (inv@609@01 r) r))
  :pattern ((inv@609@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@609@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) r) r))
  :pattern ((inv@609@01 r))
  :qid |quant-u-451|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@612@01 ((r $Ref) (v1@588@01 $Ref) (v2@589@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r) (= r (inv@609@01 r)))
    ($Perm.min
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@612@01 r v1@588@01 v2@589@01))
    $Perm.No)
  
  :qid |quant-u-453|))))
(check-sat)
; unsat
(pop) ; 15
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r) (= r (inv@609@01 r)))
    (= (- $Perm.Write (pTaken@612@01 r v1@588@01 v2@589@01)) $Perm.No))
  
  :qid |quant-u-454|))))
(check-sat)
; unsat
(pop) ; 15
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@613@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r)))
    (=>
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>))))
  :qid |qp.fvfDomDef383|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@613@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef381|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef382|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01))
(pop) ; 14
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@611@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef379|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef380|)))
(assert (forall ((n@608@01 $Ref)) (!
  (=>
    (Set_in n@608@01 g@257@01)
    (and (= (inv@609@01 n@608@01) n@608@01) (img@610@01 n@608@01)))
  :pattern ((Set_in n@608@01 g@257@01))
  :pattern ((inv@609@01 n@608@01))
  :pattern ((img@610@01 n@608@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@610@01 r) (Set_in (inv@609@01 r) g@257@01)) (= (inv@609@01 r) r))
  :pattern ((inv@609@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r)))
    (=>
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>))))
  :qid |qp.fvfDomDef383|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@613@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef381|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef382|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@609@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) r) r))
    :pattern ((inv@609@01 r))
    :qid |quant-u-451|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@611@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef379|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef380|)))
(assert (forall ((n@608@01 $Ref)) (!
  (=>
    (Set_in n@608@01 g@257@01)
    (and (= (inv@609@01 n@608@01) n@608@01) (img@610@01 n@608@01)))
  :pattern ((Set_in n@608@01 g@257@01))
  :pattern ((inv@609@01 n@608@01))
  :pattern ((img@610@01 n@608@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@610@01 r) (Set_in (inv@609@01 r) g@257@01)) (= (inv@609@01 r) r))
  :pattern ((inv@609@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r)))
    (=>
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>))))
  :qid |qp.fvfDomDef383|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@613@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef381|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef382|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@609@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) r) r))
      :pattern ((inv@609@01 r))
      :qid |quant-u-451|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@605@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef374|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef375|)))
(assert (forall ((n@602@01 $Ref)) (!
  (=>
    (Set_in n@602@01 g@257@01)
    (and (= (inv@603@01 n@602@01) n@602@01) (img@604@01 n@602@01)))
  :pattern ((Set_in n@602@01 g@257@01))
  :pattern ((inv@603@01 n@602@01))
  :pattern ((img@604@01 n@602@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@604@01 r) (Set_in (inv@603@01 r) g@257@01)) (= (inv@603@01 r) r))
  :pattern ((inv@603@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r)))
    (=>
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>))))
  :qid |qp.fvfDomDef378|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@607@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef376|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef377|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@611@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef379|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef380|)))
(assert (forall ((n@608@01 $Ref)) (!
  (=>
    (Set_in n@608@01 g@257@01)
    (and (= (inv@609@01 n@608@01) n@608@01) (img@610@01 n@608@01)))
  :pattern ((Set_in n@608@01 g@257@01))
  :pattern ((inv@609@01 n@608@01))
  :pattern ((img@610@01 n@608@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@610@01 r) (Set_in (inv@609@01 r) g@257@01)) (= (inv@609@01 r) r))
  :pattern ((inv@609@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r)))
    (=>
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>))))
  :qid |qp.fvfDomDef383|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@613@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef381|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef382|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@603@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) r) r))
      :pattern ((inv@603@01 r))
      :qid |quant-u-446|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@609@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) r) r))
          :pattern ((inv@609@01 r))
          :qid |quant-u-451|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01))))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01)))
(pop) ; 9
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@593@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef364|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef365|)))
(assert (forall ((n@590@01 $Ref)) (!
  (=>
    (Set_in n@590@01 g@257@01)
    (and (= (inv@591@01 n@590@01) n@590@01) (img@592@01 n@590@01)))
  :pattern ((Set_in n@590@01 g@257@01))
  :pattern ((inv@591@01 n@590@01))
  :pattern ((img@592@01 n@590@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@592@01 r) (Set_in (inv@591@01 r) g@257@01)) (= (inv@591@01 r) r))
  :pattern ((inv@591@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r)))
    (=>
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>))))
  :qid |qp.fvfDomDef368|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@595@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef366|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef367|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@599@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef369|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef370|)))
(assert (forall ((n@596@01 $Ref)) (!
  (=>
    (Set_in n@596@01 g@257@01)
    (and (= (inv@597@01 n@596@01) n@596@01) (img@598@01 n@596@01)))
  :pattern ((Set_in n@596@01 g@257@01))
  :pattern ((inv@597@01 n@596@01))
  :pattern ((img@598@01 n@596@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@598@01 r) (Set_in (inv@597@01 r) g@257@01)) (= (inv@597@01 r) r))
  :pattern ((inv@597@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r)))
    (=>
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>))))
  :qid |qp.fvfDomDef373|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@601@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef371|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef372|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@605@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef374|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef375|)))
(assert (forall ((n@602@01 $Ref)) (!
  (=>
    (Set_in n@602@01 g@257@01)
    (and (= (inv@603@01 n@602@01) n@602@01) (img@604@01 n@602@01)))
  :pattern ((Set_in n@602@01 g@257@01))
  :pattern ((inv@603@01 n@602@01))
  :pattern ((img@604@01 n@602@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@604@01 r) (Set_in (inv@603@01 r) g@257@01)) (= (inv@603@01 r) r))
  :pattern ((inv@603@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r)))
    (=>
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>))))
  :qid |qp.fvfDomDef378|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@607@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef376|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef377|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@611@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef379|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef380|)))
(assert (forall ((n@608@01 $Ref)) (!
  (=>
    (Set_in n@608@01 g@257@01)
    (and (= (inv@609@01 n@608@01) n@608@01) (img@610@01 n@608@01)))
  :pattern ((Set_in n@608@01 g@257@01))
  :pattern ((inv@609@01 n@608@01))
  :pattern ((img@610@01 n@608@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@610@01 r) (Set_in (inv@609@01 r) g@257@01)) (= (inv@609@01 r) r))
  :pattern ((inv@609@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r)))
    (=>
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>))))
  :qid |qp.fvfDomDef383|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@613@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef381|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef382|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@591@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@593@01  $FVF<next>) r) r))
  :pattern ((inv@591@01 r))
  :qid |quant-u-436|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@597@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@599@01  $FVF<next>) r) r))
  :pattern ((inv@597@01 r))
  :qid |quant-u-441|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@588@01 $Ref) (v2@589@01 $Ref)) (!
  (and
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@603@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) r) r))
          :pattern ((inv@603@01 r))
          :qid |quant-u-446|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@609@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) r) r))
              :pattern ((inv@609@01 r))
              :qid |quant-u-451|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)))))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@294@27@296@138-aux|)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@593@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef364|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@593@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef365|)))
(assert (forall ((n@590@01 $Ref)) (!
  (=>
    (Set_in n@590@01 g@257@01)
    (and (= (inv@591@01 n@590@01) n@590@01) (img@592@01 n@590@01)))
  :pattern ((Set_in n@590@01 g@257@01))
  :pattern ((inv@591@01 n@590@01))
  :pattern ((img@592@01 n@590@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@592@01 r) (Set_in (inv@591@01 r) g@257@01)) (= (inv@591@01 r) r))
  :pattern ((inv@591@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r)))
    (=>
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@595@01  $FVF<next>))))
  :qid |qp.fvfDomDef368|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@591@01 r) g@257@01) (img@592@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@595@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef366|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@595@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef367|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@599@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef369|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@599@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef370|)))
(assert (forall ((n@596@01 $Ref)) (!
  (=>
    (Set_in n@596@01 g@257@01)
    (and (= (inv@597@01 n@596@01) n@596@01) (img@598@01 n@596@01)))
  :pattern ((Set_in n@596@01 g@257@01))
  :pattern ((inv@597@01 n@596@01))
  :pattern ((img@598@01 n@596@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@598@01 r) (Set_in (inv@597@01 r) g@257@01)) (= (inv@597@01 r) r))
  :pattern ((inv@597@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r)))
    (=>
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@601@01  $FVF<next>))))
  :qid |qp.fvfDomDef373|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@597@01 r) g@257@01) (img@598@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@601@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef371|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@601@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef372|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@605@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef374|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@605@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef375|)))
(assert (forall ((n@602@01 $Ref)) (!
  (=>
    (Set_in n@602@01 g@257@01)
    (and (= (inv@603@01 n@602@01) n@602@01) (img@604@01 n@602@01)))
  :pattern ((Set_in n@602@01 g@257@01))
  :pattern ((inv@603@01 n@602@01))
  :pattern ((img@604@01 n@602@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@604@01 r) (Set_in (inv@603@01 r) g@257@01)) (= (inv@603@01 r) r))
  :pattern ((inv@603@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r)))
    (=>
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@607@01  $FVF<next>))))
  :qid |qp.fvfDomDef378|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@603@01 r) g@257@01) (img@604@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@607@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef376|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@607@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef377|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@611@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef379|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@611@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef380|)))
(assert (forall ((n@608@01 $Ref)) (!
  (=>
    (Set_in n@608@01 g@257@01)
    (and (= (inv@609@01 n@608@01) n@608@01) (img@610@01 n@608@01)))
  :pattern ((Set_in n@608@01 g@257@01))
  :pattern ((inv@609@01 n@608@01))
  :pattern ((img@610@01 n@608@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@610@01 r) (Set_in (inv@609@01 r) g@257@01)) (= (inv@609@01 r) r))
  :pattern ((inv@609@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r)))
    (=>
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@613@01  $FVF<next>))))
  :qid |qp.fvfDomDef383|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@609@01 r) g@257@01) (img@610@01 r))
      (and (img@323@01 r) (Set_in (inv@322@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@613@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r)))
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r))
  :qid |qp.fvfValDef381|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@319@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@613@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef382|)))
(assert (=>
  (not (= y@259@01 $Ref.null))
  (and
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@591@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@593@01  $FVF<next>) r) r))
      :pattern ((inv@591@01 r))
      :qid |quant-u-436|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@597@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@599@01  $FVF<next>) r) r))
      :pattern ((inv@597@01 r))
      :qid |quant-u-441|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01)
    (forall ((v1@588@01 $Ref) (v2@589@01 $Ref)) (!
      (and
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@603@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@605@01  $FVF<next>) r) r))
              :pattern ((inv@603@01 r))
              :qid |quant-u-446|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01)
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@609@01 r) g@257@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@611@01  $FVF<next>) r) r))
                  :pattern ((inv@609@01 r))
                  :qid |quant-u-451|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01)))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)))))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01)))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@294@27@296@138-aux|)))))
(assert (=>
  (not (= y@259@01 $Ref.null))
  (forall ((v1@588@01 $Ref) (v2@589@01 $Ref)) (!
    (=
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01)
      (or
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@601@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01)
        (and
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@607@01  $FVF<next>)) g@257@01) v1@588@01 last@318@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@613@01  $FVF<next>)) g@257@01) y@259@01 v2@589@01))))
    :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@595@01  $FVF<next>)) g@257@01) v1@588@01 v2@589@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@294@27@296@138|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; assert (forall u: Ref, v: Ref ::
;     { exists_path($$(g), u, v) }
;     !exists_path($$(g), u, v) ==>
;     u != v &&
;     (forall w: Ref ::
;       { edge($$(g), u, w) }
;       { exists_path($$(g), w, v) }
;       !edge($$(g), u, w) || !exists_path($$(g), w, v)))
; [eval] (forall u: Ref, v: Ref :: { exists_path($$(g), u, v) } !exists_path($$(g), u, v) ==> u != v && (forall w: Ref :: { edge($$(g), u, w) } { exists_path($$(g), w, v) } !edge($$(g), u, w) || !exists_path($$(g), w, v)))
(declare-const u@614@01 $Ref)
(declare-const v@615@01 $Ref)
(set-option :timeout 0)
(push) ; 7
; [eval] !exists_path($$(g), u, v) ==> u != v && (forall w: Ref :: { edge($$(g), u, w) } { exists_path($$(g), w, v) } !edge($$(g), u, w) || !exists_path($$(g), w, v))
; [eval] !exists_path($$(g), u, v)
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 8
(declare-const n@616@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@616@01 g@257@01))
(pop) ; 9
(declare-fun inv@617@01 ($Ref) $Ref)
(declare-fun img@618@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@619@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@619@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@619@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef384|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@619@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef385|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@616@01 $Ref) (n2@616@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@616@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@619@01  $FVF<next>) n1@616@01) n1@616@01))
      (and
        (Set_in n2@616@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@619@01  $FVF<next>) n2@616@01) n2@616@01))
      (= n1@616@01 n2@616@01))
    (= n1@616@01 n2@616@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@616@01 $Ref)) (!
  (=>
    (Set_in n@616@01 g@257@01)
    (and (= (inv@617@01 n@616@01) n@616@01) (img@618@01 n@616@01)))
  :pattern ((Set_in n@616@01 g@257@01))
  :pattern ((inv@617@01 n@616@01))
  :pattern ((img@618@01 n@616@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@618@01 r) (Set_in (inv@617@01 r) g@257@01)) (= (inv@617@01 r) r))
  :pattern ((inv@617@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@617@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@619@01  $FVF<next>) r) r))
  :pattern ((inv@617@01 r))
  :qid |quant-u-456|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@620@01 ((r $Ref) (u@614@01 $Ref) (v@615@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r) (= r (inv@617@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@620@01 r u@614@01 v@615@01))
    $Perm.No)
  
  :qid |quant-u-458|))))
(check-sat)
; unsat
(pop) ; 9
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r) (= r (inv@617@01 r)))
    (= (- $Perm.Write (pTaken@620@01 r u@614@01 v@615@01)) $Perm.No))
  
  :qid |quant-u-459|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@621@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>)))
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r)))
    (=>
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r))
      (Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>))))
  :qid |qp.fvfDomDef388|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@621@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@621@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef386|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@621@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef387|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@619@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@619@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef384|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@619@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef385|)))
(assert (forall ((n@616@01 $Ref)) (!
  (=>
    (Set_in n@616@01 g@257@01)
    (and (= (inv@617@01 n@616@01) n@616@01) (img@618@01 n@616@01)))
  :pattern ((Set_in n@616@01 g@257@01))
  :pattern ((inv@617@01 n@616@01))
  :pattern ((img@618@01 n@616@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@618@01 r) (Set_in (inv@617@01 r) g@257@01)) (= (inv@617@01 r) r))
  :pattern ((inv@617@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>)))
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r)))
    (=>
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r))
      (Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>))))
  :qid |qp.fvfDomDef388|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@621@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@621@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef386|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@621@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef387|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@617@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@619@01  $FVF<next>) r) r))
    :pattern ((inv@617@01 r))
    :qid |quant-u-456|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 81 | !(exists_path[Bool]($$(sm@621@01, g@257@01), u@614@01, v@615@01)) | live]
; [else-branch: 81 | exists_path[Bool]($$(sm@621@01, g@257@01), u@614@01, v@615@01) | live]
(push) ; 9
; [then-branch: 81 | !(exists_path[Bool]($$(sm@621@01, g@257@01), u@614@01, v@615@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01)))
; [eval] u != v && (forall w: Ref :: { edge($$(g), u, w) } { exists_path($$(g), w, v) } !edge($$(g), u, w) || !exists_path($$(g), w, v))
; [eval] u != v
(push) ; 10
; [then-branch: 82 | u@614@01 == v@615@01 | live]
; [else-branch: 82 | u@614@01 != v@615@01 | live]
(push) ; 11
; [then-branch: 82 | u@614@01 == v@615@01]
(assert (= u@614@01 v@615@01))
(pop) ; 11
(push) ; 11
; [else-branch: 82 | u@614@01 != v@615@01]
(assert (not (= u@614@01 v@615@01)))
; [eval] (forall w: Ref :: { edge($$(g), u, w) } { exists_path($$(g), w, v) } !edge($$(g), u, w) || !exists_path($$(g), w, v))
(declare-const w@622@01 $Ref)
(push) ; 12
; [eval] !edge($$(g), u, w) || !exists_path($$(g), w, v)
; [eval] !edge($$(g), u, w)
; [eval] edge($$(g), u, w)
; [eval] $$(g)
(push) ; 13
(declare-const n@623@01 $Ref)
(push) ; 14
; [eval] (n in refs)
(assert (Set_in n@623@01 g@257@01))
(pop) ; 14
(declare-fun inv@624@01 ($Ref) $Ref)
(declare-fun img@625@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@626@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@626@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef390|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((n1@623@01 $Ref) (n2@623@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@623@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) n1@623@01) n1@623@01))
      (and
        (Set_in n2@623@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) n2@623@01) n2@623@01))
      (= n1@623@01 n2@623@01))
    (= n1@623@01 n2@623@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@623@01 $Ref)) (!
  (=>
    (Set_in n@623@01 g@257@01)
    (and (= (inv@624@01 n@623@01) n@623@01) (img@625@01 n@623@01)))
  :pattern ((Set_in n@623@01 g@257@01))
  :pattern ((inv@624@01 n@623@01))
  :pattern ((img@625@01 n@623@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@625@01 r) (Set_in (inv@624@01 r) g@257@01)) (= (inv@624@01 r) r))
  :pattern ((inv@624@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@624@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) r) r))
  :pattern ((inv@624@01 r))
  :qid |quant-u-461|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@627@01 ((r $Ref) (w@622@01 $Ref) (u@614@01 $Ref) (v@615@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r) (= r (inv@624@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@627@01 r w@622@01 u@614@01 v@615@01))
    $Perm.No)
  
  :qid |quant-u-463|))))
(check-sat)
; unsat
(pop) ; 14
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r) (= r (inv@624@01 r)))
    (= (- $Perm.Write (pTaken@627@01 r w@622@01 u@614@01 v@615@01)) $Perm.No))
  
  :qid |quant-u-464|))))
(check-sat)
; unsat
(pop) ; 14
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@628@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r)))
    (=>
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>))))
  :qid |qp.fvfDomDef393|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@628@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef391|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef392|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01))
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@626@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef390|)))
(assert (forall ((n@623@01 $Ref)) (!
  (=>
    (Set_in n@623@01 g@257@01)
    (and (= (inv@624@01 n@623@01) n@623@01) (img@625@01 n@623@01)))
  :pattern ((Set_in n@623@01 g@257@01))
  :pattern ((inv@624@01 n@623@01))
  :pattern ((img@625@01 n@623@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@625@01 r) (Set_in (inv@624@01 r) g@257@01)) (= (inv@624@01 r) r))
  :pattern ((inv@624@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r)))
    (=>
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>))))
  :qid |qp.fvfDomDef393|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@628@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef391|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef392|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@624@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) r) r))
    :pattern ((inv@624@01 r))
    :qid |quant-u-461|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 13
; [then-branch: 83 | !(edge[Bool]($$(sm@628@01, g@257@01), u@614@01, w@622@01)) | live]
; [else-branch: 83 | edge[Bool]($$(sm@628@01, g@257@01), u@614@01, w@622@01) | live]
(push) ; 14
; [then-branch: 83 | !(edge[Bool]($$(sm@628@01, g@257@01), u@614@01, w@622@01))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)))
(pop) ; 14
(push) ; 14
; [else-branch: 83 | edge[Bool]($$(sm@628@01, g@257@01), u@614@01, w@622@01)]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
; [eval] !exists_path($$(g), w, v)
; [eval] exists_path($$(g), w, v)
; [eval] $$(g)
(push) ; 15
(declare-const n@629@01 $Ref)
(push) ; 16
; [eval] (n in refs)
(assert (Set_in n@629@01 g@257@01))
(pop) ; 16
(declare-fun inv@630@01 ($Ref) $Ref)
(declare-fun img@631@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@632@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((n1@629@01 $Ref) (n2@629@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@629@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) n1@629@01) n1@629@01))
      (and
        (Set_in n2@629@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) n2@629@01) n2@629@01))
      (= n1@629@01 n2@629@01))
    (= n1@629@01 n2@629@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@630@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
  :pattern ((inv@630@01 r))
  :qid |quant-u-466|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@633@01 ((r $Ref) (w@622@01 $Ref) (u@614@01 $Ref) (v@615@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r) (= r (inv@630@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@633@01 r w@622@01 u@614@01 v@615@01))
    $Perm.No)
  
  :qid |quant-u-468|))))
(check-sat)
; unsat
(pop) ; 16
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r) (= r (inv@630@01 r)))
    (= (- $Perm.Write (pTaken@633@01 r w@622@01 u@614@01 v@615@01)) $Perm.No))
  
  :qid |quant-u-469|))))
(check-sat)
; unsat
(pop) ; 16
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@634@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01))
(pop) ; 15
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@630@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
    :pattern ((inv@630@01 r))
    :qid |quant-u-466|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert (=>
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@630@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
      :pattern ((inv@630@01 r))
      :qid |quant-u-466|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01))))
(assert (or
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
(pop) ; 12
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@626@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef390|)))
(assert (forall ((n@623@01 $Ref)) (!
  (=>
    (Set_in n@623@01 g@257@01)
    (and (= (inv@624@01 n@623@01) n@623@01) (img@625@01 n@623@01)))
  :pattern ((Set_in n@623@01 g@257@01))
  :pattern ((inv@624@01 n@623@01))
  :pattern ((img@625@01 n@623@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@625@01 r) (Set_in (inv@624@01 r) g@257@01)) (= (inv@624@01 r) r))
  :pattern ((inv@624@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r)))
    (=>
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>))))
  :qid |qp.fvfDomDef393|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@628@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef391|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef392|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@624@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) r) r))
  :pattern ((inv@624@01 r))
  :qid |quant-u-461|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((w@622@01 $Ref)) (!
  (and
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@630@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
          :pattern ((inv@630@01 r))
          :qid |quant-u-466|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|)))
(assert (forall ((w@622@01 $Ref)) (!
  (and
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@630@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
          :pattern ((inv@630@01 r))
          :qid |quant-u-466|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@626@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef390|)))
(assert (forall ((n@623@01 $Ref)) (!
  (=>
    (Set_in n@623@01 g@257@01)
    (and (= (inv@624@01 n@623@01) n@623@01) (img@625@01 n@623@01)))
  :pattern ((Set_in n@623@01 g@257@01))
  :pattern ((inv@624@01 n@623@01))
  :pattern ((img@625@01 n@623@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@625@01 r) (Set_in (inv@624@01 r) g@257@01)) (= (inv@624@01 r) r))
  :pattern ((inv@624@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r)))
    (=>
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>))))
  :qid |qp.fvfDomDef393|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@628@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef391|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef392|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert (=>
  (not (= u@614@01 v@615@01))
  (and
    (not (= u@614@01 v@615@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@624@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) r) r))
      :pattern ((inv@624@01 r))
      :qid |quant-u-461|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01)
    (forall ((w@622@01 $Ref)) (!
      (and
        (=>
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
          (and
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@630@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
              :pattern ((inv@630@01 r))
              :qid |quant-u-466|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
        (or
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
      :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|))
    (forall ((w@622@01 $Ref)) (!
      (and
        (=>
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
          (and
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@630@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
              :pattern ((inv@630@01 r))
              :qid |quant-u-466|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
        (or
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|)))))
(assert (or (not (= u@614@01 v@615@01)) (= u@614@01 v@615@01)))
(pop) ; 9
(set-option :timeout 0)
(push) ; 9
; [else-branch: 81 | exists_path[Bool]($$(sm@621@01, g@257@01), u@614@01, v@615@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@626@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef390|)))
(assert (forall ((n@623@01 $Ref)) (!
  (=>
    (Set_in n@623@01 g@257@01)
    (and (= (inv@624@01 n@623@01) n@623@01) (img@625@01 n@623@01)))
  :pattern ((Set_in n@623@01 g@257@01))
  :pattern ((inv@624@01 n@623@01))
  :pattern ((img@625@01 n@623@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@625@01 r) (Set_in (inv@624@01 r) g@257@01)) (= (inv@624@01 r) r))
  :pattern ((inv@624@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r)))
    (=>
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>))))
  :qid |qp.fvfDomDef393|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@628@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef391|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef392|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
    (=>
      (not (= u@614@01 v@615@01))
      (and
        (not (= u@614@01 v@615@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@624@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) r) r))
          :pattern ((inv@624@01 r))
          :qid |quant-u-461|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01)
        (forall ((w@622@01 $Ref)) (!
          (and
            (=>
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
              (and
                (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@630@01 r) g@257@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
                  :pattern ((inv@630@01 r))
                  :qid |quant-u-466|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
            (or
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
              (not
                (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
          :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
          :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|))
        (forall ((w@622@01 $Ref)) (!
          (and
            (=>
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
              (and
                (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@630@01 r) g@257@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
                  :pattern ((inv@630@01 r))
                  :qid |quant-u-466|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
            (or
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
              (not
                (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
          :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
          :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|))))
    (or (not (= u@614@01 v@615@01)) (= u@614@01 v@615@01)))))
; Joined path conditions
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))))
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@619@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@619@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef384|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@619@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef385|)))
(assert (forall ((n@616@01 $Ref)) (!
  (=>
    (Set_in n@616@01 g@257@01)
    (and (= (inv@617@01 n@616@01) n@616@01) (img@618@01 n@616@01)))
  :pattern ((Set_in n@616@01 g@257@01))
  :pattern ((inv@617@01 n@616@01))
  :pattern ((img@618@01 n@616@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@618@01 r) (Set_in (inv@617@01 r) g@257@01)) (= (inv@617@01 r) r))
  :pattern ((inv@617@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>)))
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r)))
    (=>
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r))
      (Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@621@01  $FVF<next>))))
  :qid |qp.fvfDomDef388|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@617@01 r) g@257@01) (img@618@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@621@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@621@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef386|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@621@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef387|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@626@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef389|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@626@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef390|)))
(assert (forall ((n@623@01 $Ref)) (!
  (=>
    (Set_in n@623@01 g@257@01)
    (and (= (inv@624@01 n@623@01) n@623@01) (img@625@01 n@623@01)))
  :pattern ((Set_in n@623@01 g@257@01))
  :pattern ((inv@624@01 n@623@01))
  :pattern ((img@625@01 n@623@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@625@01 r) (Set_in (inv@624@01 r) g@257@01)) (= (inv@624@01 r) r))
  :pattern ((inv@624@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r)))
    (=>
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@628@01  $FVF<next>))))
  :qid |qp.fvfDomDef393|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@624@01 r) g@257@01) (img@625@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@628@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef391|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@628@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef392|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@632@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef394|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@632@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef395|)))
(assert (forall ((n@629@01 $Ref)) (!
  (=>
    (Set_in n@629@01 g@257@01)
    (and (= (inv@630@01 n@629@01) n@629@01) (img@631@01 n@629@01)))
  :pattern ((Set_in n@629@01 g@257@01))
  :pattern ((inv@630@01 n@629@01))
  :pattern ((img@631@01 n@629@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@631@01 r) (Set_in (inv@630@01 r) g@257@01)) (= (inv@630@01 r) r))
  :pattern ((inv@630@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r)))
    (=>
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@634@01  $FVF<next>))))
  :qid |qp.fvfDomDef398|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@630@01 r) g@257@01) (img@631@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@634@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef396|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@634@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef397|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@617@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@619@01  $FVF<next>) r) r))
  :pattern ((inv@617@01 r))
  :qid |quant-u-456|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@614@01 $Ref) (v@615@01 $Ref)) (!
  (and
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
        (=>
          (not (= u@614@01 v@615@01))
          (and
            (not (= u@614@01 v@615@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@624@01 r) g@257@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@626@01  $FVF<next>) r) r))
              :pattern ((inv@624@01 r))
              :qid |quant-u-461|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01)
            (forall ((w@622@01 $Ref)) (!
              (and
                (=>
                  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                  (and
                    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                    (forall ((r $Ref)) (!
                      (=>
                        (Set_in (inv@630@01 r) g@257@01)
                        ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
                      :pattern ((inv@630@01 r))
                      :qid |quant-u-466|))
                    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
                (or
                  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                  (not
                    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
              :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
              :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|))
            (forall ((w@622@01 $Ref)) (!
              (and
                (=>
                  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                  (and
                    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                    (forall ((r $Ref)) (!
                      (=>
                        (Set_in (inv@630@01 r) g@257@01)
                        ($FVF.loc_next ($FVF.lookup_next (as sm@632@01  $FVF<next>) r) r))
                      :pattern ((inv@630@01 r))
                      :qid |quant-u-466|))
                    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
                (or
                  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                  (not
                    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))))
              :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
              :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136-aux|))))
        (or (not (= u@614@01 v@615@01)) (= u@614@01 v@615@01))))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@16@467@136-aux|)))
(assert (forall ((u@614@01 $Ref) (v@615@01 $Ref)) (!
  (and
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01)
    (=>
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
        (not (= u@614@01 v@615@01)))
      (forall ((w@622@01 $Ref)) (!
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01)
          (=>
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
        :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
        :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
        :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136|))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@16@467@136_precondition|)))
(push) ; 7
(assert (not (forall ((u@614@01 $Ref) (v@615@01 $Ref)) (!
  (=>
    (and
      (and
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01)
        (=>
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
            (not (= u@614@01 v@615@01)))
          (forall ((w@622@01 $Ref)) (!
            (and
              ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01)
              (=>
                (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01)
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01)))
            :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
            :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
            :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136|))))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01)))
    (and
      (not (= u@614@01 v@615@01))
      (forall ((w@622@01 $Ref)) (!
        (or
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01)))
        :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
        :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
        :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136|))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@16@467@136|))))
(check-sat)
; unsat
(pop) ; 7
; 3,31s
; (get-info :all-statistics)
(assert (forall ((u@614@01 $Ref) (v@615@01 $Ref)) (!
  (=>
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
    (and
      (not (= u@614@01 v@615@01))
      (forall ((w@622@01 $Ref)) (!
        (or
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01)))
        :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@628@01  $FVF<next>)) g@257@01) u@614@01 w@622@01))
        :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@634@01  $FVF<next>)) g@257@01) w@622@01 v@615@01))
        :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@77@467@136|))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@621@01  $FVF<next>)) g@257@01) u@614@01 v@615@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@467@16@467@136|)))
; [exec]
; assert (forall u: Ref, v: Ref ::
;     { exists_path($$(g), u, v) }
;     { edge($$(g), u, v) }
;     !exists_path($$(g), u, v) ==> !edge($$(g), u, v))
; [eval] (forall u: Ref, v: Ref :: { exists_path($$(g), u, v) } { edge($$(g), u, v) } !exists_path($$(g), u, v) ==> !edge($$(g), u, v))
(declare-const u@635@01 $Ref)
(declare-const v@636@01 $Ref)
(push) ; 7
; [eval] !exists_path($$(g), u, v) ==> !edge($$(g), u, v)
; [eval] !exists_path($$(g), u, v)
; [eval] exists_path($$(g), u, v)
; [eval] $$(g)
(push) ; 8
(declare-const n@637@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@637@01 g@257@01))
(pop) ; 9
(declare-fun inv@638@01 ($Ref) $Ref)
(declare-fun img@639@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@640@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@640@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@640@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef399|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@640@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef400|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@637@01 $Ref) (n2@637@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@637@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@640@01  $FVF<next>) n1@637@01) n1@637@01))
      (and
        (Set_in n2@637@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@640@01  $FVF<next>) n2@637@01) n2@637@01))
      (= n1@637@01 n2@637@01))
    (= n1@637@01 n2@637@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@637@01 $Ref)) (!
  (=>
    (Set_in n@637@01 g@257@01)
    (and (= (inv@638@01 n@637@01) n@637@01) (img@639@01 n@637@01)))
  :pattern ((Set_in n@637@01 g@257@01))
  :pattern ((inv@638@01 n@637@01))
  :pattern ((img@639@01 n@637@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@639@01 r) (Set_in (inv@638@01 r) g@257@01)) (= (inv@638@01 r) r))
  :pattern ((inv@638@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@638@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@640@01  $FVF<next>) r) r))
  :pattern ((inv@638@01 r))
  :qid |quant-u-471|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@641@01 ((r $Ref) (u@635@01 $Ref) (v@636@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r) (= r (inv@638@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@641@01 r u@635@01 v@636@01))
    $Perm.No)
  
  :qid |quant-u-473|))))
(check-sat)
; unsat
(pop) ; 9
; 0,05s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r) (= r (inv@638@01 r)))
    (= (- $Perm.Write (pTaken@641@01 r u@635@01 v@636@01)) $Perm.No))
  
  :qid |quant-u-474|))))
(check-sat)
; unsat
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@642@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>)))
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r)))
    (=>
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r))
      (Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>))))
  :qid |qp.fvfDomDef403|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@642@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@642@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef401|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@642@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef402|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@640@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@640@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef399|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@640@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef400|)))
(assert (forall ((n@637@01 $Ref)) (!
  (=>
    (Set_in n@637@01 g@257@01)
    (and (= (inv@638@01 n@637@01) n@637@01) (img@639@01 n@637@01)))
  :pattern ((Set_in n@637@01 g@257@01))
  :pattern ((inv@638@01 n@637@01))
  :pattern ((img@639@01 n@637@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@639@01 r) (Set_in (inv@638@01 r) g@257@01)) (= (inv@638@01 r) r))
  :pattern ((inv@638@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>)))
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r)))
    (=>
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r))
      (Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>))))
  :qid |qp.fvfDomDef403|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@642@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@642@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef401|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@642@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef402|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@638@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@640@01  $FVF<next>) r) r))
    :pattern ((inv@638@01 r))
    :qid |quant-u-471|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 84 | !(exists_path[Bool]($$(sm@642@01, g@257@01), u@635@01, v@636@01)) | live]
; [else-branch: 84 | exists_path[Bool]($$(sm@642@01, g@257@01), u@635@01, v@636@01) | live]
(push) ; 9
; [then-branch: 84 | !(exists_path[Bool]($$(sm@642@01, g@257@01), u@635@01, v@636@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01)))
; [eval] !edge($$(g), u, v)
; [eval] edge($$(g), u, v)
; [eval] $$(g)
(push) ; 10
(declare-const n@643@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@643@01 g@257@01))
(pop) ; 11
(declare-fun inv@644@01 ($Ref) $Ref)
(declare-fun img@645@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@646@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@646@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef404|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef405|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@643@01 $Ref) (n2@643@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@643@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) n1@643@01) n1@643@01))
      (and
        (Set_in n2@643@01 g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) n2@643@01) n2@643@01))
      (= n1@643@01 n2@643@01))
    (= n1@643@01 n2@643@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@643@01 $Ref)) (!
  (=>
    (Set_in n@643@01 g@257@01)
    (and (= (inv@644@01 n@643@01) n@643@01) (img@645@01 n@643@01)))
  :pattern ((Set_in n@643@01 g@257@01))
  :pattern ((inv@644@01 n@643@01))
  :pattern ((img@645@01 n@643@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@645@01 r) (Set_in (inv@644@01 r) g@257@01)) (= (inv@644@01 r) r))
  :pattern ((inv@644@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@644@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) r) r))
  :pattern ((inv@644@01 r))
  :qid |quant-u-476|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@647@01 ((r $Ref) (u@635@01 $Ref) (v@636@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r) (= r (inv@644@01 r)))
    ($Perm.min
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
        $Perm.Write
        $Perm.No)
      (pTaken@647@01 r u@635@01 v@636@01))
    $Perm.No)
  
  :qid |quant-u-478|))))
(check-sat)
; unsat
(pop) ; 11
; 0,07s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r) (= r (inv@644@01 r)))
    (= (- $Perm.Write (pTaken@647@01 r u@635@01 v@636@01)) $Perm.No))
  
  :qid |quant-u-479|))))
(check-sat)
; unsat
(pop) ; 11
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@648@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r)))
    (=>
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>))))
  :qid |qp.fvfDomDef408|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@648@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef406|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef407|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@646@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef404|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef405|)))
(assert (forall ((n@643@01 $Ref)) (!
  (=>
    (Set_in n@643@01 g@257@01)
    (and (= (inv@644@01 n@643@01) n@643@01) (img@645@01 n@643@01)))
  :pattern ((Set_in n@643@01 g@257@01))
  :pattern ((inv@644@01 n@643@01))
  :pattern ((img@645@01 n@643@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@645@01 r) (Set_in (inv@644@01 r) g@257@01)) (= (inv@644@01 r) r))
  :pattern ((inv@644@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r)))
    (=>
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>))))
  :qid |qp.fvfDomDef408|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@648@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef406|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef407|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@644@01 r) g@257@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) r) r))
    :pattern ((inv@644@01 r))
    :qid |quant-u-476|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01)))
(pop) ; 9
(set-option :timeout 0)
(push) ; 9
; [else-branch: 84 | exists_path[Bool]($$(sm@642@01, g@257@01), u@635@01, v@636@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@646@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef404|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef405|)))
(assert (forall ((n@643@01 $Ref)) (!
  (=>
    (Set_in n@643@01 g@257@01)
    (and (= (inv@644@01 n@643@01) n@643@01) (img@645@01 n@643@01)))
  :pattern ((Set_in n@643@01 g@257@01))
  :pattern ((inv@644@01 n@643@01))
  :pattern ((img@645@01 n@643@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@645@01 r) (Set_in (inv@644@01 r) g@257@01)) (= (inv@644@01 r) r))
  :pattern ((inv@644@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r)))
    (=>
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>))))
  :qid |qp.fvfDomDef408|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@648@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef406|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef407|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@644@01 r) g@257@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) r) r))
      :pattern ((inv@644@01 r))
      :qid |quant-u-476|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01))))
; Joined path conditions
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))))
(pop) ; 7
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@640@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@640@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef399|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@640@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef400|)))
(assert (forall ((n@637@01 $Ref)) (!
  (=>
    (Set_in n@637@01 g@257@01)
    (and (= (inv@638@01 n@637@01) n@637@01) (img@639@01 n@637@01)))
  :pattern ((Set_in n@637@01 g@257@01))
  :pattern ((inv@638@01 n@637@01))
  :pattern ((img@639@01 n@637@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@639@01 r) (Set_in (inv@638@01 r) g@257@01)) (= (inv@638@01 r) r))
  :pattern ((inv@638@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>)))
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r)))
    (=>
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r))
      (Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@642@01  $FVF<next>))))
  :qid |qp.fvfDomDef403|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@638@01 r) g@257@01) (img@639@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@642@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@642@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef401|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@642@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef402|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01))
    (=
      ($FVF.lookup_next (as sm@646@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef404|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@646@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef405|)))
(assert (forall ((n@643@01 $Ref)) (!
  (=>
    (Set_in n@643@01 g@257@01)
    (and (= (inv@644@01 n@643@01) n@643@01) (img@645@01 n@643@01)))
  :pattern ((Set_in n@643@01 g@257@01))
  :pattern ((inv@644@01 n@643@01))
  :pattern ((img@645@01 n@643@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@645@01 r) (Set_in (inv@644@01 r) g@257@01)) (= (inv@644@01 r) r))
  :pattern ((inv@644@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r)))
    (=>
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@648@01  $FVF<next>))))
  :qid |qp.fvfDomDef408|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@644@01 r) g@257@01) (img@645@01 r))
      (and (img@573@01 r) (Set_in (inv@572@01 r) g@257@01)))
    (=
      ($FVF.lookup_next (as sm@648@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r)))
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r))
  :qid |qp.fvfValDef406|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@569@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@648@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef407|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@638@01 r) g@257@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@640@01  $FVF<next>) r) r))
  :pattern ((inv@638@01 r))
  :qid |quant-u-471|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@635@01 $Ref) (v@636@01 $Ref)) (!
  (and
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@644@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) r) r))
          :pattern ((inv@644@01 r))
          :qid |quant-u-476|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@468@16@468@83-aux|)))
(assert (forall ((u@635@01 $Ref) (v@636@01 $Ref)) (!
  (and
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@644@01 r) g@257@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@646@01  $FVF<next>) r) r))
          :pattern ((inv@644@01 r))
          :qid |quant-u-476|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@468@16@468@83-aux|)))
(assert (forall ((u@635@01 $Ref) (v@636@01 $Ref)) (!
  (and
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01)
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@468@16@468@83_precondition|)))
(push) ; 7
(assert (not (forall ((u@635@01 $Ref) (v@636@01 $Ref)) (!
  (=>
    (and
      (and
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01)))
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01)))
    (not
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01) u@635@01 v@636@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@642@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@648@01  $FVF<next>)) g@257@01) u@635@01 v@636@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/outlines/list_append.vpr@468@16@468@83|))))
(check-sat)
