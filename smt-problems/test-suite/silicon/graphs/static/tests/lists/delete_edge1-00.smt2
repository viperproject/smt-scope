(get-info :version)
; (:version "4.8.7")
; Started: 2024-11-17 20:13:33
; Silicon.version: 1.1-SNAPSHOT (4d756c79+)
; Input file: /silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Set<$Ref> 0)
(declare-sort Set<Edge> 0)
(declare-sort Set<$Snap> 0)
(declare-sort Edge 0)
(declare-sort TrClo 0)
(declare-sort $FVF<next> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<Edge>To$Snap (Set<Edge>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Edge> ($Snap) Set<Edge>)
(assert (forall ((x Set<Edge>)) (!
    (= x ($SortWrappers.$SnapToSet<Edge>($SortWrappers.Set<Edge>To$Snap x)))
    :pattern (($SortWrappers.Set<Edge>To$Snap x))
    :qid |$Snap.$SnapToSet<Edge>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Edge>To$Snap($SortWrappers.$SnapToSet<Edge> x)))
    :pattern (($SortWrappers.$SnapToSet<Edge> x))
    :qid |$Snap.Set<Edge>To$SnapToSet<Edge>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.EdgeTo$Snap (Edge) $Snap)
(declare-fun $SortWrappers.$SnapToEdge ($Snap) Edge)
(assert (forall ((x Edge)) (!
    (= x ($SortWrappers.$SnapToEdge($SortWrappers.EdgeTo$Snap x)))
    :pattern (($SortWrappers.EdgeTo$Snap x))
    :qid |$Snap.$SnapToEdgeTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.EdgeTo$Snap($SortWrappers.$SnapToEdge x)))
    :pattern (($SortWrappers.$SnapToEdge x))
    :qid |$Snap.EdgeTo$SnapToEdge|
    )))
(declare-fun $SortWrappers.TrCloTo$Snap (TrClo) $Snap)
(declare-fun $SortWrappers.$SnapToTrClo ($Snap) TrClo)
(assert (forall ((x TrClo)) (!
    (= x ($SortWrappers.$SnapToTrClo($SortWrappers.TrCloTo$Snap x)))
    :pattern (($SortWrappers.TrCloTo$Snap x))
    :qid |$Snap.$SnapToTrCloTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.TrCloTo$Snap($SortWrappers.$SnapToTrClo x)))
    :pattern (($SortWrappers.$SnapToTrClo x))
    :qid |$Snap.TrCloTo$SnapToTrClo|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<next>To$Snap ($FVF<next>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<next> ($Snap) $FVF<next>)
(assert (forall ((x $FVF<next>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<next>($SortWrappers.$FVF<next>To$Snap x)))
    :pattern (($SortWrappers.$FVF<next>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<next>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<next>To$Snap($SortWrappers.$SnapTo$FVF<next> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<next> x))
    :qid |$Snap.$FVF<next>To$SnapTo$FVF<next>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<Edge>) Int)
(declare-const Set_empty Set<Edge>)
(declare-fun Set_in (Edge Set<Edge>) Bool)
(declare-fun Set_singleton (Edge) Set<Edge>)
(declare-fun Set_unionone (Set<Edge> Edge) Set<Edge>)
(declare-fun Set_union (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_intersection (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_difference (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_subset (Set<Edge> Set<Edge>) Bool)
(declare-fun Set_equal (Set<Edge> Set<Edge>) Bool)
(declare-fun Set_skolem_diff (Set<Edge> Set<Edge>) Edge)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
(declare-fun edge_pred<Ref> (Edge) $Ref)
(declare-fun edge_succ<Ref> (Edge) $Ref)
(declare-fun create_edge<Edge> ($Ref $Ref) Edge)
(declare-fun create_edge_<Edge> ($Ref $Ref) Edge)
(declare-fun exists_path<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_path_<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_spath<Bool> (Set<Edge> Set<$Ref> $Ref) Bool)
(declare-fun apply_noExit<Bool> (Set<Edge> Set<$Ref> Set<$Ref>) Bool)
(declare-fun inst_uReach<Set<Ref>> (Set<Edge> $Ref) Set<$Ref>)
(declare-fun acyclic_graph<Bool> (Set<Edge>) Bool)
(declare-fun unshared_graph<Bool> (Set<Edge>) Bool)
(declare-fun func_graph<Bool> (Set<Edge>) Bool)
(declare-fun edge<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun edge_<Bool> (Set<Edge> $Ref $Ref) Bool)
; /field_value_functions_declarations.smt2 [next: Ref]
(declare-fun $FVF.domain_next ($FVF<next>) Set<$Ref>)
(declare-fun $FVF.lookup_next ($FVF<next> $Ref) $Ref)
(declare-fun $FVF.after_next ($FVF<next> $FVF<next>) Bool)
(declare-fun $FVF.loc_next ($Ref $Ref) Bool)
(declare-fun $FVF.perm_next ($FPM $Ref) $Perm)
(declare-const $fvfTOP_next $FVF<next>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun $$ ($Snap Set<$Ref>) Set<Edge>)
(declare-fun $$%limited ($Snap Set<$Ref>) Set<Edge>)
(declare-fun $$%stateless (Set<$Ref>) Bool)
(declare-fun $$%precondition ($Snap Set<$Ref>) Bool)
(declare-fun apply_TCFraming ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_TCFraming%limited ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_TCFraming%stateless (Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_TCFraming%precondition ($Snap Set<$Ref> Set<$Ref>) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Edge>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Edge)) (!
  (not (Set_in o (as Set_empty  Set<Edge>)))
  :pattern ((Set_in o (as Set_empty  Set<Edge>)))
  )))
(assert (forall ((s Set<Edge>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Edge>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Edge))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Edge)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Edge) (o Edge)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Edge)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Edge>) (x Edge) (o Edge)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Edge>) (x Edge) (y Edge)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=
    (Set_subset a b)
    (forall ((o Edge)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((p $Ref) (s $Ref)) (!
  (and
    (= (edge_pred<Ref> (create_edge<Edge> p s)) p)
    (= (edge_succ<Ref> (create_edge<Edge> p s)) s))
  :pattern ((create_edge<Edge> p s))
  :qid |prog.edge_injectivity|)))
(assert (forall ((EG Set<Edge>) (p $Ref) (s $Ref)) (!
  (= (edge<Bool> EG p s) (edge_<Bool> EG p s))
  :pattern ((edge<Bool> EG p s))
  :qid |prog.ax_EdgeSynonim|)))
(assert (forall ((EG Set<Edge>) (p $Ref) (s $Ref)) (!
  (= (edge_<Bool> EG p s) (Set_in (create_edge<Edge> p s) EG))
  :pattern ((Set_in (create_edge<Edge> p s) EG))
  :pattern ((edge<Bool> EG p s))
  :qid |prog.ax_Edge|)))
(assert (forall ((EG Set<Edge>) (U Set<$Ref>) (M Set<$Ref>)) (!
  (=>
    (and
      (apply_noExit<Bool> EG U M)
      (forall ((u $Ref) (v $Ref)) (!
        (=>
          (and (Set_in u M) (and (Set_in v U) (not (Set_in v M))))
          (not (edge<Bool> EG u v)))
        :pattern ((edge<Bool> EG u v))
        :pattern ((Set_in u M) (Set_in v M))
        )))
    (forall ((u $Ref) (v $Ref)) (!
      (=>
        (and (Set_in u M) (and (Set_in v U) (not (Set_in v M))))
        (not (exists_path<Bool> EG u v)))
      :pattern ((exists_path<Bool> EG u v))
      :pattern ((Set_in u M) (Set_in v M))
      )))
  :pattern ((apply_noExit<Bool> EG U M))
  :qid |prog.ax_NoExit|)))
(assert (forall ((EG Set<Edge>) (x $Ref) (v $Ref)) (!
  (= (Set_in v (inst_uReach<Set<Ref>> EG x)) (exists_path<Bool> EG x v))
  :pattern ((Set_in v (inst_uReach<Set<Ref>> EG x)))
  :pattern ((exists_path<Bool> EG x v))
  :qid |prog.ax_instantiation_uReach|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (= (exists_path<Bool> EG start end) (exists_path_<Bool> EG start end))
  :pattern ((exists_path<Bool> EG start end))
  :qid |prog.ax_Alias|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (=
    (exists_path_<Bool> EG start end)
    (or
      (= start end)
      (exists ((w $Ref)) (!
        (and (edge<Bool> EG start w) (exists_path_<Bool> EG w end))
        :pattern ((edge<Bool> EG start w))
        :pattern ((exists_path_<Bool> EG w end))
        ))))
  :pattern ((exists_path<Bool> EG start end))
  :pattern ((edge<Bool> EG start end))
  :qid |prog.ax_ExistsPath|)))
(assert (forall ((EG Set<Edge>) (u $Ref) (v $Ref) (w $Ref)) (!
  (=>
    (and (exists_path_<Bool> EG u w) (exists_path_<Bool> EG w v))
    (exists_path_<Bool> EG u v))
  :pattern ((exists_path<Bool> EG u w) (exists_path<Bool> EG w v))
  :qid |prog.ax_ExistsPathTrans|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (acyclic_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref)) (!
      (or (not (edge<Bool> EG v1 v2)) (not (exists_path<Bool> EG v2 v1)))
      :pattern ((edge<Bool> EG v1 v2))
      :pattern ((exists_path<Bool> EG v2 v1))
      )))
  :pattern ((acyclic_graph<Bool> EG))
  :qid |prog.ax_AcyclicGraph|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (unshared_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref) (v $Ref)) (!
      (=> (and (edge<Bool> EG v1 v) (edge<Bool> EG v2 v)) (= v1 v2))
      :pattern ((edge<Bool> EG v1 v) (edge<Bool> EG v2 v))
      )))
  :pattern ((unshared_graph<Bool> EG))
  :qid |prog.ax_UnsharedGraph|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (func_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref) (v $Ref)) (!
      (=> (and (edge<Bool> EG v v1) (edge<Bool> EG v v2)) (= v1 v2))
      :pattern ((edge<Bool> EG v v1) (edge<Bool> EG v v2))
      )))
  :pattern ((func_graph<Bool> EG))
  :qid |prog.ax_FuncGraph|)))
; /field_value_functions_axioms.smt2 [next: Ref]
(assert (forall ((vs $FVF<next>) (ws $FVF<next>)) (!
    (=>
      (and
        (Set_equal ($FVF.domain_next vs) ($FVF.domain_next ws))
        (forall ((x $Ref)) (!
          (=>
            (Set_in x ($FVF.domain_next vs))
            (= ($FVF.lookup_next vs x) ($FVF.lookup_next ws x)))
          :pattern (($FVF.lookup_next vs x) ($FVF.lookup_next ws x))
          :qid |qp.$FVF<next>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<next>To$Snap vs)
              ($SortWrappers.$FVF<next>To$Snap ws)
              )
    :qid |qp.$FVF<next>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_next pm r))
    :pattern (($FVF.perm_next pm r)))))
(assert (forall ((r $Ref) (f $Ref)) (!
    (= ($FVF.loc_next f r) true)
    :pattern (($FVF.loc_next f r)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun inv@7@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@8@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun sm@6@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun sm@9@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun inv@19@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@20@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@23@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@24@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@30@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@31@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@34@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@35@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@41@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@42@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@46@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@47@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@53@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@54@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@58@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@59@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@65@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@66@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@70@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@71@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun sm@18@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@21@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@32@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@37@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@44@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@49@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@56@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@61@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@68@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@73@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (= ($$%limited s@$ refs@0@00) ($$ s@$ refs@0@00))
  :pattern (($$ s@$ refs@0@00))
  :qid |quant-u-0|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  ($$%stateless refs@0@00)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-1|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) (and
    (forall ((n@5@00 $Ref)) (!
      (=>
        (Set_in n@5@00 refs@0@00)
        (and
          (= (inv@7@00 s@$ refs@0@00 n@5@00) n@5@00)
          (img@8@00 s@$ refs@0@00 n@5@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) n@5@00) n@5@00))
      :qid |quant-u-5|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@8@00 s@$ refs@0@00 r)
          (Set_in (inv@7@00 s@$ refs@0@00 r) refs@0@00))
        (= (inv@7@00 s@$ refs@0@00 r) r))
      :pattern ((inv@7@00 s@$ refs@0@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@6@00 s@$ refs@0@00) r))
      :qid |qp.fvfResTrgDef0|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@8@00 s@$ refs@0@00 r)
          (Set_in (inv@7@00 s@$ refs@0@00 r) refs@0@00))
        (=
          ($FVF.lookup_next (sm@9@00 s@$ refs@0@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r)))
      :pattern (($FVF.lookup_next (sm@9@00 s@$ refs@0@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r))
      :qid |qp.fvfValDef1|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r) r)
      :pattern (($FVF.lookup_next (sm@9@00 s@$ refs@0@00) r))
      :qid |qp.fvfResTrgDef2|))
    (=>
      ($$%precondition s@$ refs@0@00)
      (and
        (forall ((p $Ref) (s $Ref)) (!
          (=
            (and
              (Set_in p refs@0@00)
              (and
                (Set_in s refs@0@00)
                (= ($FVF.lookup_next (sm@9@00 s@$ refs@0@00) p) s)))
            (Set_in (create_edge<Edge> p s) result@1@00))
          :pattern ((create_edge<Edge> p s))
          ))
        (forall ((p $Ref) (s $Ref)) (!
          (=>
            (and (Set_in p refs@0@00) (exists_path<Bool> result@1@00 p s))
            (Set_in s refs@0@00))
          :pattern ((Set_in p refs@0@00) (Set_in s refs@0@00) (exists_path<Bool> result@1@00 p s))
          ))
        (forall ((p $Ref) (s $Ref)) (!
          (=>
            (and (Set_in s refs@0@00) (exists_path<Bool> result@1@00 p s))
            (Set_in p refs@0@00))
          :pattern ((Set_in p refs@0@00) (Set_in s refs@0@00) (exists_path<Bool> result@1@00 p s))
          ))))))
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-7|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) true)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-8|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) true)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-9|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) true)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-10|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (=
    (apply_TCFraming%limited s@$ g0@2@00 g1@3@00)
    (apply_TCFraming s@$ g0@2@00 g1@3@00))
  :pattern ((apply_TCFraming s@$ g0@2@00 g1@3@00))
  :qid |quant-u-2|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (apply_TCFraming%stateless g0@2@00 g1@3@00)
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-3|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (and
    (forall ((n@17@00 $Ref)) (!
      (=>
        (Set_in n@17@00 g0@2@00)
        (and
          (= (inv@19@00 s@$ g0@2@00 g1@3@00 n@17@00) n@17@00)
          (img@20@00 s@$ g0@2@00 g1@3@00 n@17@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) n@17@00) n@17@00))
      :qid |quant-u-12|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@20@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (= (inv@19@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@19@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@22@00 $Ref)) (!
      (=>
        (Set_in n@22@00 g1@3@00)
        (and
          (= (inv@23@00 s@$ g0@2@00 g1@3@00 n@22@00) n@22@00)
          (img@24@00 s@$ g0@2@00 g1@3@00 n@22@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) n@22@00) n@22@00))
      :qid |quant-u-15|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@24@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00))
        (= (inv@23@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@23@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@29@00 $Ref)) (!
      (=>
        (Set_in n@29@00 g0@2@00)
        (and
          (= (inv@30@00 s@$ g0@2@00 g1@3@00 n@29@00) n@29@00)
          (img@31@00 s@$ g0@2@00 g1@3@00 n@29@00)))
      :pattern ((Set_in n@29@00 g0@2@00))
      :pattern ((inv@30@00 s@$ g0@2@00 g1@3@00 n@29@00))
      :pattern ((img@31@00 s@$ g0@2@00 g1@3@00 n@29@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@31@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@30@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (= (inv@30@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@30@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@33@00 $Ref)) (!
      (=>
        (Set_in n@33@00 (Set_union g0@2@00 g1@3@00))
        (and
          (= (inv@34@00 s@$ g0@2@00 g1@3@00 n@33@00) n@33@00)
          (img@35@00 s@$ g0@2@00 g1@3@00 n@33@00)))
      :pattern ((Set_in n@33@00 (Set_union g0@2@00 g1@3@00)))
      :pattern ((inv@34@00 s@$ g0@2@00 g1@3@00 n@33@00))
      :pattern ((img@35@00 s@$ g0@2@00 g1@3@00 n@33@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@35@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@34@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00)))
        (= (inv@34@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@34@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@40@00 $Ref)) (!
      (=>
        (Set_in n@40@00 g1@3@00)
        (and
          (= (inv@41@00 s@$ g0@2@00 g1@3@00 n@40@00) n@40@00)
          (img@42@00 s@$ g0@2@00 g1@3@00 n@40@00)))
      :pattern ((Set_in n@40@00 g1@3@00))
      :pattern ((inv@41@00 s@$ g0@2@00 g1@3@00 n@40@00))
      :pattern ((img@42@00 s@$ g0@2@00 g1@3@00 n@40@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@42@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@41@00 s@$ g0@2@00 g1@3@00 r) g1@3@00))
        (= (inv@41@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@41@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@45@00 $Ref)) (!
      (=>
        (Set_in n@45@00 (Set_union g1@3@00 g0@2@00))
        (and
          (= (inv@46@00 s@$ g0@2@00 g1@3@00 n@45@00) n@45@00)
          (img@47@00 s@$ g0@2@00 g1@3@00 n@45@00)))
      :pattern ((Set_in n@45@00 (Set_union g1@3@00 g0@2@00)))
      :pattern ((inv@46@00 s@$ g0@2@00 g1@3@00 n@45@00))
      :pattern ((img@47@00 s@$ g0@2@00 g1@3@00 n@45@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@47@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@46@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00)))
        (= (inv@46@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@46@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@52@00 $Ref)) (!
      (=>
        (Set_in n@52@00 g0@2@00)
        (and
          (= (inv@53@00 s@$ g0@2@00 g1@3@00 n@52@00) n@52@00)
          (img@54@00 s@$ g0@2@00 g1@3@00 n@52@00)))
      :pattern ((Set_in n@52@00 g0@2@00))
      :pattern ((inv@53@00 s@$ g0@2@00 g1@3@00 n@52@00))
      :pattern ((img@54@00 s@$ g0@2@00 g1@3@00 n@52@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@54@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@53@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (= (inv@53@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@53@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@57@00 $Ref)) (!
      (=>
        (Set_in n@57@00 (Set_union g0@2@00 g1@3@00))
        (and
          (= (inv@58@00 s@$ g0@2@00 g1@3@00 n@57@00) n@57@00)
          (img@59@00 s@$ g0@2@00 g1@3@00 n@57@00)))
      :pattern ((Set_in n@57@00 (Set_union g0@2@00 g1@3@00)))
      :pattern ((inv@58@00 s@$ g0@2@00 g1@3@00 n@57@00))
      :pattern ((img@59@00 s@$ g0@2@00 g1@3@00 n@57@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@59@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@58@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00)))
        (= (inv@58@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@58@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@64@00 $Ref)) (!
      (=>
        (Set_in n@64@00 g1@3@00)
        (and
          (= (inv@65@00 s@$ g0@2@00 g1@3@00 n@64@00) n@64@00)
          (img@66@00 s@$ g0@2@00 g1@3@00 n@64@00)))
      :pattern ((Set_in n@64@00 g1@3@00))
      :pattern ((inv@65@00 s@$ g0@2@00 g1@3@00 n@64@00))
      :pattern ((img@66@00 s@$ g0@2@00 g1@3@00 n@64@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@66@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@65@00 s@$ g0@2@00 g1@3@00 r) g1@3@00))
        (= (inv@65@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@65@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@69@00 $Ref)) (!
      (=>
        (Set_in n@69@00 (Set_union g1@3@00 g0@2@00))
        (and
          (= (inv@70@00 s@$ g0@2@00 g1@3@00 n@69@00) n@69@00)
          (img@71@00 s@$ g0@2@00 g1@3@00 n@69@00)))
      :pattern ((Set_in n@69@00 (Set_union g1@3@00 g0@2@00)))
      :pattern ((inv@70@00 s@$ g0@2@00 g1@3@00 n@69@00))
      :pattern ((img@71@00 s@$ g0@2@00 g1@3@00 n@69@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@71@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@70@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00)))
        (= (inv@70@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@70@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@18@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef3|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@20@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (=
          ($FVF.lookup_next (sm@21@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@21@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef4|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
      :pattern (($FVF.lookup_next (sm@21@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef5|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@32@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@30@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@31@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@30@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@31@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@32@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@32@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef12|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@30@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@31@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@32@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@32@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef9|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@30@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@31@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@32@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@32@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef10|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@32@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef11|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@37@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@34@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@35@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@34@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@35@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@37@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@37@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef19|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@34@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@35@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@37@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@37@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef16|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@34@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@35@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@37@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@37@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef17|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@37@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef18|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@44@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@41@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@42@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@41@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@42@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@44@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@44@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef26|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@41@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@42@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@44@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@44@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef23|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@41@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@42@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@44@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@44@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef24|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@44@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef25|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@49@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@46@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@47@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@46@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@47@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@49@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@49@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef33|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@46@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@47@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@49@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@49@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef30|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@46@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@47@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@49@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@49@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef31|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@49@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef32|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@56@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@53@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@54@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@53@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@54@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@56@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@56@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef40|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@53@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@54@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@56@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@56@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef37|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@53@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@54@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@56@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@56@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef38|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@56@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef39|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@61@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@58@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@59@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@58@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@59@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@61@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@61@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef47|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@58@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@59@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@61@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@61@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef44|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@58@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@59@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@61@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@61@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef45|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@61@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef46|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@68@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@65@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@66@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@65@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@66@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@68@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@68@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef54|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@65@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@66@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@68@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@68@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef51|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@65@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@66@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@68@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@68@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef52|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@68@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef53|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@73@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@70@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@71@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@70@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@71@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@73@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@73@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef61|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@70@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@71@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@20@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@19@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@73@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r)))
      :pattern (($FVF.lookup_next (sm@73@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r))
      :qid |qp.fvfValDef58|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@70@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@71@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@24@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@23@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@73@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@73@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef59|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first s@$)) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r))
      :pattern (($FVF.lookup_next (sm@73@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef60|))
    (=>
      (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
      (and
        (Set_equal (Set_union g0@2@00 g1@3@00) (Set_union g1@3@00 g0@2@00))
        (forall ((u $Ref) (v $Ref)) (!
          (=>
            (and
              (Set_in u g0@2@00)
              (and
                (Set_in v g0@2@00)
                (exists_path<Bool> ($$ (ite
                  (Set_in v g0@2@00)
                  (ite
                    (Set_in u g0@2@00)
                    ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
                    ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
                  ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v)))
            (exists_path<Bool> ($$ (ite
              (and
                (Set_in u g0@2@00)
                (and
                  (Set_in v g0@2@00)
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
              ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
          :pattern ((exists_path<Bool> ($$ (ite
            (Set_in v g0@2@00)
            (ite
              (Set_in u g0@2@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v))
          :pattern ((exists_path<Bool> ($$ (ite
            (and
              (Set_in u g0@2@00)
              (and
                (Set_in v g0@2@00)
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
            ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
            ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
          ))
        (forall ((u $Ref) (v $Ref)) (!
          (=>
            (and
              (Set_in u g1@3@00)
              (and
                (Set_in v g1@3@00)
                (exists_path<Bool> ($$ (ite
                  (Set_in v g1@3@00)
                  (ite
                    (Set_in u g1@3@00)
                    ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
                    ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
                  ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v)))
            (exists_path<Bool> ($$ (ite
              (and
                (Set_in u g1@3@00)
                (and
                  (Set_in v g1@3@00)
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)))
              ($SortWrappers.$FVF<next>To$Snap (sm@49@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@73@00 s@$ g0@2@00 g1@3@00))) (Set_union g1@3@00 g0@2@00)) u v))
          :pattern ((exists_path<Bool> ($$ (ite
            (Set_in v g1@3@00)
            (ite
              (Set_in u g1@3@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v))
          :pattern ((exists_path<Bool> ($$ (ite
            (and
              (Set_in u g1@3@00)
              (and
                (Set_in v g1@3@00)
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)))
            ($SortWrappers.$FVF<next>To$Snap (sm@49@00 s@$ g0@2@00 g1@3@00))
            ($SortWrappers.$FVF<next>To$Snap (sm@73@00 s@$ g0@2@00 g1@3@00))) (Set_union g1@3@00 g0@2@00)) u v))
          ))
        (forall ((u $Ref) (v $Ref)) (!
          (=>
            (and
              (Set_in u g0@2@00)
              (and
                (Set_in v g0@2@00)
                (not
                  (exists_path<Bool> ($$ (ite
                    (Set_in v g0@2@00)
                    (ite
                      (Set_in u g0@2@00)
                      ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
                      ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
                    ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v))))
            (not
              (exists_path<Bool> ($$ (ite
                (and
                  (Set_in u g0@2@00)
                  (and
                    (Set_in v g0@2@00)
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
                ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
                ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v)))
          :pattern ((exists_path<Bool> ($$ (ite
            (Set_in v g0@2@00)
            (ite
              (Set_in u g0@2@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v))
          :pattern ((exists_path<Bool> ($$ (ite
            (and
              (Set_in u g0@2@00)
              (and
                (Set_in v g0@2@00)
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
            ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
            ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
          ))
        (forall ((u $Ref) (v $Ref)) (!
          (=>
            (and
              (Set_in u g1@3@00)
              (and
                (Set_in v g1@3@00)
                (not
                  (exists_path<Bool> ($$ (ite
                    (Set_in v g1@3@00)
                    (ite
                      (Set_in u g1@3@00)
                      ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
                      ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
                    ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v))))
            (not
              (exists_path<Bool> ($$ (ite
                (and
                  (Set_in u g1@3@00)
                  (and
                    (Set_in v g1@3@00)
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)))
                ($SortWrappers.$FVF<next>To$Snap (sm@49@00 s@$ g0@2@00 g1@3@00))
                ($SortWrappers.$FVF<next>To$Snap (sm@73@00 s@$ g0@2@00 g1@3@00))) (Set_union g1@3@00 g0@2@00)) u v)))
          :pattern ((exists_path<Bool> ($$ (ite
            (Set_in v g1@3@00)
            (ite
              (Set_in u g1@3@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v))
          :pattern ((exists_path<Bool> ($$ (ite
            (and
              (Set_in u g0@2@00)
              (and
                (Set_in v g0@2@00)
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
            ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
            ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
          ))))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-93|)))
; WARNING: (1509,11): 'if' cannot be used in patterns.
; WARNING: (1509,11): 'if' cannot be used in patterns.
; WARNING: (1509,11): 'and' cannot be used in patterns.
; WARNING: (1509,11): 'and' cannot be used in patterns.
; WARNING: (1509,11): 'if' cannot be used in patterns.
; WARNING: (1546,11): 'if' cannot be used in patterns.
; WARNING: (1546,11): 'if' cannot be used in patterns.
; WARNING: (1546,11): 'and' cannot be used in patterns.
; WARNING: (1546,11): 'and' cannot be used in patterns.
; WARNING: (1546,11): 'if' cannot be used in patterns.
; WARNING: (1585,11): 'if' cannot be used in patterns.
; WARNING: (1585,11): 'if' cannot be used in patterns.
; WARNING: (1585,11): 'and' cannot be used in patterns.
; WARNING: (1585,11): 'and' cannot be used in patterns.
; WARNING: (1585,11): 'if' cannot be used in patterns.
; WARNING: (1624,11): 'if' cannot be used in patterns.
; WARNING: (1624,11): 'if' cannot be used in patterns.
; WARNING: (1624,11): 'and' cannot be used in patterns.
; WARNING: (1624,11): 'and' cannot be used in patterns.
; WARNING: (1624,11): 'if' cannot be used in patterns.
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) true)
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-94|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (=>
    (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
    (forall ((u $Ref) (v $Ref)) (!
      (and
        (=>
          (and (Set_in u g0@2@00) (Set_in v g0@2@00))
          ($$%precondition (ite
            (Set_in v g0@2@00)
            (ite
              (Set_in u g0@2@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00))
        (=>
          (and
            (Set_in u g0@2@00)
            (and
              (Set_in v g0@2@00)
              (exists_path<Bool> ($$ (ite
                (Set_in v g0@2@00)
                (ite
                  (Set_in u g0@2@00)
                  ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
                  ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
                ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v)))
          (and
            (=>
              (and (Set_in u g0@2@00) (Set_in v g0@2@00))
              ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00))
            ($$%precondition (ite
              (and
                (Set_in u g0@2@00)
                (and
                  (Set_in v g0@2@00)
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
              ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)))))
      :pattern ((exists_path<Bool> ($$ (ite
        (Set_in v g0@2@00)
        (ite
          (Set_in u g0@2@00)
          ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
          ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
        ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v))
      :pattern ((exists_path<Bool> ($$ (ite
        (and
          (Set_in u g0@2@00)
          (and
            (Set_in v g0@2@00)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
        ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
        ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
      ))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-95|)))
; WARNING: (1684,7): 'if' cannot be used in patterns.
; WARNING: (1684,7): 'if' cannot be used in patterns.
; WARNING: (1684,7): 'and' cannot be used in patterns.
; WARNING: (1684,7): 'and' cannot be used in patterns.
; WARNING: (1684,7): 'if' cannot be used in patterns.
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (=>
    (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
    (forall ((u $Ref) (v $Ref)) (!
      (and
        (=>
          (and (Set_in u g1@3@00) (Set_in v g1@3@00))
          ($$%precondition (ite
            (Set_in v g1@3@00)
            (ite
              (Set_in u g1@3@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00))
        (=>
          (and
            (Set_in u g1@3@00)
            (and
              (Set_in v g1@3@00)
              (exists_path<Bool> ($$ (ite
                (Set_in v g1@3@00)
                (ite
                  (Set_in u g1@3@00)
                  ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
                  ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
                ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v)))
          (and
            (=>
              (and (Set_in u g1@3@00) (Set_in v g1@3@00))
              ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00))
            ($$%precondition (ite
              (and
                (Set_in u g1@3@00)
                (and
                  (Set_in v g1@3@00)
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)))
              ($SortWrappers.$FVF<next>To$Snap (sm@49@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@73@00 s@$ g0@2@00 g1@3@00))) (Set_union g1@3@00 g0@2@00)))))
      :pattern ((exists_path<Bool> ($$ (ite
        (Set_in v g1@3@00)
        (ite
          (Set_in u g1@3@00)
          ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
          ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
        ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v))
      :pattern ((exists_path<Bool> ($$ (ite
        (and
          (Set_in u g1@3@00)
          (and
            (Set_in v g1@3@00)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)))
        ($SortWrappers.$FVF<next>To$Snap (sm@49@00 s@$ g0@2@00 g1@3@00))
        ($SortWrappers.$FVF<next>To$Snap (sm@73@00 s@$ g0@2@00 g1@3@00))) (Set_union g1@3@00 g0@2@00)) u v))
      ))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-96|)))
; WARNING: (1740,7): 'if' cannot be used in patterns.
; WARNING: (1740,7): 'if' cannot be used in patterns.
; WARNING: (1740,7): 'and' cannot be used in patterns.
; WARNING: (1740,7): 'and' cannot be used in patterns.
; WARNING: (1740,7): 'if' cannot be used in patterns.
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (=>
    (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
    (forall ((u $Ref) (v $Ref)) (!
      (and
        (=>
          (and (Set_in u g0@2@00) (Set_in v g0@2@00))
          ($$%precondition (ite
            (Set_in v g0@2@00)
            (ite
              (Set_in u g0@2@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00))
        (=>
          (and
            (Set_in u g0@2@00)
            (and
              (Set_in v g0@2@00)
              (not
                (exists_path<Bool> ($$ (ite
                  (Set_in v g0@2@00)
                  (ite
                    (Set_in u g0@2@00)
                    ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
                    ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
                  ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v))))
          (and
            (=>
              (and (Set_in u g0@2@00) (Set_in v g0@2@00))
              ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00))
            ($$%precondition (ite
              (and
                (Set_in u g0@2@00)
                (and
                  (Set_in v g0@2@00)
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
              ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)))))
      :pattern ((exists_path<Bool> ($$ (ite
        (Set_in v g0@2@00)
        (ite
          (Set_in u g0@2@00)
          ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00))
          ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00)))
        ($SortWrappers.$FVF<next>To$Snap (sm@56@00 s@$ g0@2@00 g1@3@00))) g0@2@00) u v))
      :pattern ((exists_path<Bool> ($$ (ite
        (and
          (Set_in u g0@2@00)
          (and
            (Set_in v g0@2@00)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
        ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
        ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
      ))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-97|)))
; WARNING: (1797,7): 'if' cannot be used in patterns.
; WARNING: (1797,7): 'if' cannot be used in patterns.
; WARNING: (1797,7): 'and' cannot be used in patterns.
; WARNING: (1797,7): 'and' cannot be used in patterns.
; WARNING: (1797,7): 'if' cannot be used in patterns.
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (=>
    (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
    (forall ((u $Ref) (v $Ref)) (!
      (and
        (=>
          (and (Set_in u g1@3@00) (Set_in v g1@3@00))
          ($$%precondition (ite
            (Set_in v g1@3@00)
            (ite
              (Set_in u g1@3@00)
              ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
            ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00))
        (=>
          (and
            (Set_in u g1@3@00)
            (and
              (Set_in v g1@3@00)
              (not
                (exists_path<Bool> ($$ (ite
                  (Set_in v g1@3@00)
                  (ite
                    (Set_in u g1@3@00)
                    ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
                    ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
                  ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v))))
          (and
            (=>
              (and (Set_in u g1@3@00) (Set_in v g1@3@00))
              ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00))
            ($$%precondition (ite
              (and
                (Set_in u g1@3@00)
                (and
                  (Set_in v g1@3@00)
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)))
              ($SortWrappers.$FVF<next>To$Snap (sm@49@00 s@$ g0@2@00 g1@3@00))
              ($SortWrappers.$FVF<next>To$Snap (sm@73@00 s@$ g0@2@00 g1@3@00))) (Set_union g1@3@00 g0@2@00)))))
      :pattern ((exists_path<Bool> ($$ (ite
        (Set_in v g1@3@00)
        (ite
          (Set_in u g1@3@00)
          ($SortWrappers.$FVF<next>To$Snap (sm@44@00 s@$ g0@2@00 g1@3@00))
          ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00)))
        ($SortWrappers.$FVF<next>To$Snap (sm@68@00 s@$ g0@2@00 g1@3@00))) g1@3@00) u v))
      :pattern ((exists_path<Bool> ($$ (ite
        (and
          (Set_in u g0@2@00)
          (and
            (Set_in v g0@2@00)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@32@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)))
        ($SortWrappers.$FVF<next>To$Snap (sm@37@00 s@$ g0@2@00 g1@3@00))
        ($SortWrappers.$FVF<next>To$Snap (sm@61@00 s@$ g0@2@00 g1@3@00))) (Set_union g0@2@00 g1@3@00)) u v))
      ))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-98|)))
; WARNING: (1854,7): 'if' cannot be used in patterns.
; WARNING: (1854,7): 'if' cannot be used in patterns.
; WARNING: (1854,7): 'and' cannot be used in patterns.
; WARNING: (1854,7): 'and' cannot be used in patterns.
; WARNING: (1854,7): 'if' cannot be used in patterns.
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- link ----------
(declare-const g@0@01 Set<$Ref>)
(declare-const x@1@01 $Ref)
(declare-const y@2@01 $Ref)
(declare-const g@3@01 Set<$Ref>)
(declare-const x@4@01 $Ref)
(declare-const y@5@01 $Ref)
(set-option :timeout 0)
(push) ; 1
(declare-const $t@6@01 $Snap)
(assert (= $t@6@01 ($Snap.combine ($Snap.first $t@6@01) ($Snap.second $t@6@01))))
(assert (= ($Snap.first $t@6@01) $Snap.unit))
; [eval] (x in g)
(assert (Set_in x@4@01 g@3@01))
(assert (=
  ($Snap.second $t@6@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@6@01))
    ($Snap.second ($Snap.second $t@6@01)))))
(assert (= ($Snap.first ($Snap.second $t@6@01)) $Snap.unit))
; [eval] y != null ==> (y in g)
; [eval] y != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; [then-branch: 0 | y@5@01 != Null | live]
; [else-branch: 0 | y@5@01 == Null | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 0 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
; [eval] (y in g)
(pop) ; 3
(push) ; 3
; [else-branch: 0 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (= y@5@01 $Ref.null) (not (= y@5@01 $Ref.null))))
(assert (=> (not (= y@5@01 $Ref.null)) (Set_in y@5@01 g@3@01)))
(assert (=
  ($Snap.second ($Snap.second $t@6@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@6@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@6@01))) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@3@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@6@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@6@01)))) $Snap.unit))
; [eval] (x in g)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))))
(declare-const sm@7@01 $FVF<next>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($FVF.lookup_next (as sm@7@01  $FVF<next>) x@4@01)
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))))
(assert (not (= x@4@01 $Ref.null)))
(declare-const sm@8@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@8@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@8@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
  :pattern (($FVF.lookup_next (as sm@8@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef1|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@8@01  $FVF<next>) x@4@01) x@4@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))))))
(declare-const n@9@01 $Ref)
(push) ; 2
; [eval] (n in g) && n != x
; [eval] (n in g)
(push) ; 3
; [then-branch: 1 | !(n@9@01 in g@3@01) | live]
; [else-branch: 1 | n@9@01 in g@3@01 | live]
(push) ; 4
; [then-branch: 1 | !(n@9@01 in g@3@01)]
(assert (not (Set_in n@9@01 g@3@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 1 | n@9@01 in g@3@01]
(assert (Set_in n@9@01 g@3@01))
; [eval] n != x
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (Set_in n@9@01 g@3@01) (not (Set_in n@9@01 g@3@01))))
(assert (and (Set_in n@9@01 g@3@01) (not (= n@9@01 x@4@01))))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@10@01 ($Ref) $Ref)
(declare-fun img@11@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((n@9@01 $Ref)) (!
  (=>
    (and (Set_in n@9@01 g@3@01) (not (= n@9@01 x@4@01)))
    (or (Set_in n@9@01 g@3@01) (not (Set_in n@9@01 g@3@01))))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) n@9@01) n@9@01))
  :qid |next-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@9@01 $Ref) (n2@9@01 $Ref)) (!
  (=>
    (and
      (and (Set_in n1@9@01 g@3@01) (not (= n1@9@01 x@4@01)))
      (and (Set_in n2@9@01 g@3@01) (not (= n2@9@01 x@4@01)))
      (= n1@9@01 n2@9@01))
    (= n1@9@01 n2@9@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@9@01 $Ref)) (!
  (=>
    (and (Set_in n@9@01 g@3@01) (not (= n@9@01 x@4@01)))
    (and (= (inv@10@01 n@9@01) n@9@01) (img@11@01 n@9@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) n@9@01) n@9@01))
  :qid |quant-u-100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (= (inv@10@01 r) r))
  :pattern ((inv@10@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@9@01 $Ref)) (!
  (=>
    (and (Set_in n@9@01 g@3@01) (not (= n@9@01 x@4@01)))
    (not (= n@9@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) n@9@01) n@9@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@12@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef4|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
  :pattern ((inv@10@01 r))
  :qid |quant-u-101|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))))
  $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@13@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 2 | !(n$0@13@01 in g@3@01) | live]
; [else-branch: 2 | n$0@13@01 in g@3@01 | live]
(push) ; 4
; [then-branch: 2 | !(n$0@13@01 in g@3@01)]
(assert (not (Set_in n$0@13@01 g@3@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 2 | n$0@13@01 in g@3@01]
(assert (Set_in n$0@13@01 g@3@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@4@01)
      (=
        ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
    :qid |qp.fvfValDef2|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
      (=
        ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
    :qid |qp.fvfValDef3|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef4|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite (= n$0@13@01 x@4@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@11@01 n$0@13@01)
        (and
          (Set_in (inv@10@01 n$0@13@01) g@3@01)
          (not (= (inv@10@01 n$0@13@01) x@4@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef4|)))
(assert (=>
  (Set_in n$0@13@01 g@3@01)
  (and
    (Set_in n$0@13@01 g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01))))
(assert (or (Set_in n$0@13@01 g@3@01) (not (Set_in n$0@13@01 g@3@01))))
(push) ; 3
; [then-branch: 3 | n$0@13@01 in g@3@01 && Lookup(next, sm@12@01, n$0@13@01) != Null | live]
; [else-branch: 3 | !(n$0@13@01 in g@3@01 && Lookup(next, sm@12@01, n$0@13@01) != Null) | live]
(push) ; 4
; [then-branch: 3 | n$0@13@01 in g@3@01 && Lookup(next, sm@12@01, n$0@13@01) != Null]
(assert (and
  (Set_in n$0@13@01 g@3@01)
  (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@4@01)
      (=
        ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
    :qid |qp.fvfValDef2|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
      (=
        ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
    :qid |qp.fvfValDef3|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef4|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite (= n$0@13@01 x@4@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@11@01 n$0@13@01)
        (and
          (Set_in (inv@10@01 n$0@13@01) g@3@01)
          (not (= (inv@10@01 n$0@13@01) x@4@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 3 | !(n$0@13@01 in g@3@01 && Lookup(next, sm@12@01, n$0@13@01) != Null)]
(assert (not
  (and
    (Set_in n$0@13@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef4|)))
(assert (=>
  (and
    (Set_in n$0@13@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))
  (and
    (Set_in n$0@13@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@13@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))))
  (and
    (Set_in n$0@13@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef4|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@13@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@13@01 g@3@01)
      (and
        (Set_in n$0@13@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01)))
    (or (Set_in n$0@13@01 g@3@01) (not (Set_in n$0@13@01 g@3@01)))
    (=>
      (and
        (Set_in n$0@13@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))
      (and
        (Set_in n$0@13@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01)))
    (or
      (not
        (and
          (Set_in n$0@13@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))))
      (and
        (Set_in n$0@13@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) g@3@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@276@14@276@34-aux|)))
(assert (forall ((n$0@13@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@13@01 g@3@01)
      (and
        (Set_in n$0@13@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01)))
    (or (Set_in n$0@13@01 g@3@01) (not (Set_in n$0@13@01 g@3@01)))
    (=>
      (and
        (Set_in n$0@13@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))
      (and
        (Set_in n$0@13@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01)))
    (or
      (not
        (and
          (Set_in n$0@13@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null))))
      (and
        (Set_in n$0@13@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))))
  :pattern ((Set_in n$0@13@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@276@14@276@34-aux|)))
(assert (forall ((n$0@13@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@13@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) g@3@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) g@3@01))
  :pattern ((Set_in n$0@13@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n$0@13@01) n$0@13@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@276@14@276@34|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01)))))))
  $Snap.unit))
; [eval] x.next == null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@4@01)
      (=
        ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
    :qid |qp.fvfValDef2|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
      (=
        ($FVF.lookup_next (as sm@12@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
    :qid |qp.fvfValDef3|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
    :pattern (($FVF.lookup_next (as sm@12@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef4|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) x@4@01) x@4@01))
(push) ; 2
(assert (not (<
  $Perm.No
  (+
    $Perm.Write
    (ite
      (and
        (img@11@01 x@4@01)
        (and
          (Set_in (inv@10@01 x@4@01) g@3@01)
          (not (= (inv@10@01 x@4@01) x@4@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
(assert (= ($FVF.lookup_next (as sm@12@01  $FVF<next>) x@4@01) $Ref.null))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@14@01 $Snap)
(assert (= $t@14@01 ($Snap.combine ($Snap.first $t@14@01) ($Snap.second $t@14@01))))
(assert (= ($Snap.first $t@14@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@14@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@14@01))
    ($Snap.second ($Snap.second $t@14@01)))))
(assert (= ($Snap.first ($Snap.second $t@14@01)) $Snap.unit))
; [eval] (x in g)
(assert (=
  ($Snap.second ($Snap.second $t@14@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@14@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
(declare-const sm@15@01 $FVF<next>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($FVF.lookup_next (as sm@15@01  $FVF<next>) x@4@01)
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@14@01))))))
(declare-const sm@16@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@16@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@16@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
  :pattern (($FVF.lookup_next (as sm@16@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef6|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@16@01  $FVF<next>) x@4@01) x@4@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@14@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))
(declare-const n$1@17@01 $Ref)
(push) ; 3
; [eval] (n$1 in g) && n$1 != x
; [eval] (n$1 in g)
(push) ; 4
; [then-branch: 4 | !(n$1@17@01 in g@3@01) | live]
; [else-branch: 4 | n$1@17@01 in g@3@01 | live]
(push) ; 5
; [then-branch: 4 | !(n$1@17@01 in g@3@01)]
(assert (not (Set_in n$1@17@01 g@3@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 4 | n$1@17@01 in g@3@01]
(assert (Set_in n$1@17@01 g@3@01))
; [eval] n$1 != x
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in n$1@17@01 g@3@01) (not (Set_in n$1@17@01 g@3@01))))
(assert (and (Set_in n$1@17@01 g@3@01) (not (= n$1@17@01 x@4@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@18@01 ($Ref) $Ref)
(declare-fun img@19@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((n$1@17@01 $Ref)) (!
  (=>
    (and (Set_in n$1@17@01 g@3@01) (not (= n$1@17@01 x@4@01)))
    (or (Set_in n$1@17@01 g@3@01) (not (Set_in n$1@17@01 g@3@01))))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) n$1@17@01) n$1@17@01))
  :qid |next-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@17@01 $Ref) (n$12@17@01 $Ref)) (!
  (=>
    (and
      (and (Set_in n$11@17@01 g@3@01) (not (= n$11@17@01 x@4@01)))
      (and (Set_in n$12@17@01 g@3@01) (not (= n$12@17@01 x@4@01)))
      (= n$11@17@01 n$12@17@01))
    (= n$11@17@01 n$12@17@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@17@01 $Ref)) (!
  (=>
    (and (Set_in n$1@17@01 g@3@01) (not (= n$1@17@01 x@4@01)))
    (and (= (inv@18@01 n$1@17@01) n$1@17@01) (img@19@01 n$1@17@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) n$1@17@01) n$1@17@01))
  :qid |quant-u-103|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@19@01 r)
      (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
    (= (inv@18@01 r) r))
  :pattern ((inv@18@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@17@01 $Ref)) (!
  (=>
    (and (Set_in n$1@17@01 g@3@01) (not (= n$1@17@01 x@4@01)))
    (not (= n$1@17@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) n$1@17@01) n$1@17@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@20@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@19@01 r)
      (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef9|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
  :pattern ((inv@18@01 r))
  :qid |quant-u-104|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@21@01 $Ref)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 5 | !(n$2@21@01 in g@3@01) | live]
; [else-branch: 5 | n$2@21@01 in g@3@01 | live]
(push) ; 5
; [then-branch: 5 | !(n$2@21@01 in g@3@01)]
(assert (not (Set_in n$2@21@01 g@3@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 5 | n$2@21@01 in g@3@01]
(assert (Set_in n$2@21@01 g@3@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@4@01)
      (=
        ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
    :qid |qp.fvfValDef7|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
      (=
        ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
    :qid |qp.fvfValDef8|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef9|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite (= n$2@21@01 x@4@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@19@01 n$2@21@01)
        (and
          (Set_in (inv@18@01 n$2@21@01) g@3@01)
          (not (= (inv@18@01 n$2@21@01) x@4@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@19@01 r)
      (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef9|)))
(assert (=>
  (Set_in n$2@21@01 g@3@01)
  (and
    (Set_in n$2@21@01 g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01))))
(assert (or (Set_in n$2@21@01 g@3@01) (not (Set_in n$2@21@01 g@3@01))))
(push) ; 4
; [then-branch: 6 | n$2@21@01 in g@3@01 && Lookup(next, sm@20@01, n$2@21@01) != Null | live]
; [else-branch: 6 | !(n$2@21@01 in g@3@01 && Lookup(next, sm@20@01, n$2@21@01) != Null) | live]
(push) ; 5
; [then-branch: 6 | n$2@21@01 in g@3@01 && Lookup(next, sm@20@01, n$2@21@01) != Null]
(assert (and
  (Set_in n$2@21@01 g@3@01)
  (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@4@01)
      (=
        ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
    :qid |qp.fvfValDef7|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
      (=
        ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
    :qid |qp.fvfValDef8|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef9|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite (= n$2@21@01 x@4@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@19@01 n$2@21@01)
        (and
          (Set_in (inv@18@01 n$2@21@01) g@3@01)
          (not (= (inv@18@01 n$2@21@01) x@4@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 6 | !(n$2@21@01 in g@3@01 && Lookup(next, sm@20@01, n$2@21@01) != Null)]
(assert (not
  (and
    (Set_in n$2@21@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@19@01 r)
      (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef9|)))
(assert (=>
  (and
    (Set_in n$2@21@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))
  (and
    (Set_in n$2@21@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@21@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))))
  (and
    (Set_in n$2@21@01 g@3@01)
    (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@19@01 r)
      (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef9|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@21@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@21@01 g@3@01)
      (and
        (Set_in n$2@21@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01)))
    (or (Set_in n$2@21@01 g@3@01) (not (Set_in n$2@21@01 g@3@01)))
    (=>
      (and
        (Set_in n$2@21@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))
      (and
        (Set_in n$2@21@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01)))
    (or
      (not
        (and
          (Set_in n$2@21@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))))
      (and
        (Set_in n$2@21@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) g@3@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@278@13@278@33-aux|)))
(assert (forall ((n$2@21@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@21@01 g@3@01)
      (and
        (Set_in n$2@21@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01)))
    (or (Set_in n$2@21@01 g@3@01) (not (Set_in n$2@21@01 g@3@01)))
    (=>
      (and
        (Set_in n$2@21@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))
      (and
        (Set_in n$2@21@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01)))
    (or
      (not
        (and
          (Set_in n$2@21@01 g@3@01)
          (not
            (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null))))
      (and
        (Set_in n$2@21@01 g@3@01)
        (not
          (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))))
  :pattern ((Set_in n$2@21@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@278@13@278@33-aux|)))
(assert (forall ((n$2@21@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@21@01 g@3@01)
      (not (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) g@3@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) g@3@01))
  :pattern ((Set_in n$2@21@01 g@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n$2@21@01) n$2@21@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@278@13@278@33|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
  $Snap.unit))
; [eval] x.next == y
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@4@01)
      (=
        ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
    :qid |qp.fvfValDef7|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
      (=
        ($FVF.lookup_next (as sm@20@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
    :qid |qp.fvfValDef8|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@20@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef9|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) x@4@01) x@4@01))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    $Perm.Write
    (ite
      (and
        (img@19@01 x@4@01)
        (and
          (Set_in (inv@18@01 x@4@01) g@3@01)
          (not (= (inv@18@01 x@4@01) x@4@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (= ($FVF.lookup_next (as sm@20@01  $FVF<next>) x@4@01) y@5@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))
  $Snap.unit))
; [eval] y == null ==> $$(g) == old($$(g))
; [eval] y == null
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 7 | y@5@01 == Null | live]
; [else-branch: 7 | y@5@01 != Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 7 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
; [eval] $$(g) == old($$(g))
; [eval] $$(g)
(push) ; 5
(declare-const n@22@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@22@01 g@3@01))
(pop) ; 6
(declare-fun inv@23@01 ($Ref) $Ref)
(declare-fun img@24@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@22@01 $Ref) (n2@22@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@22@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n1@22@01) n1@22@01))
      (and
        (Set_in n2@22@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n2@22@01) n2@22@01))
      (= n1@22@01 n2@22@01))
    (= n1@22@01 n2@22@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@22@01 $Ref)) (!
  (=>
    (Set_in n@22@01 g@3@01)
    (and (= (inv@23@01 n@22@01) n@22@01) (img@24@01 n@22@01)))
  :pattern ((Set_in n@22@01 g@3@01))
  :pattern ((inv@23@01 n@22@01))
  :pattern ((img@24@01 n@22@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@24@01 r) (Set_in (inv@23@01 r) g@3@01)) (= (inv@23@01 r) r))
  :pattern ((inv@23@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@23@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
  :pattern ((inv@23@01 r))
  :qid |quant-u-106|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@25@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r) (= r (inv@23@01 r)))
    ($Perm.min
      (ite
        (and
          (img@19@01 r)
          (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@26@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r) (= r (inv@23@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@25@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@19@01 r)
          (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@25@01 r))
    $Perm.No)
  
  :qid |quant-u-108|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r) (= r (inv@23@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@25@01 r)) $Perm.No))
  
  :qid |quant-u-109|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@26@01 x@4@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@26@01 r) $Perm.No)
  
  :qid |quant-u-111|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r) (= r (inv@23@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@25@01 r)) (pTaken@26@01 r))
      $Perm.No))
  
  :qid |quant-u-112|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@27@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>)))
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r)))
    (=>
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r))
      (Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>))))
  :qid |qp.fvfDomDef13|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@27@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@27@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@27@01  $FVF<next>)) g@3@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@22@01 $Ref)) (!
  (=>
    (Set_in n@22@01 g@3@01)
    (and (= (inv@23@01 n@22@01) n@22@01) (img@24@01 n@22@01)))
  :pattern ((Set_in n@22@01 g@3@01))
  :pattern ((inv@23@01 n@22@01))
  :pattern ((img@24@01 n@22@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@24@01 r) (Set_in (inv@23@01 r) g@3@01)) (= (inv@23@01 r) r))
  :pattern ((inv@23@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>)))
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r)))
    (=>
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r))
      (Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>))))
  :qid |qp.fvfDomDef13|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@27@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@27@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@23@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
    :pattern ((inv@23@01 r))
    :qid |quant-u-106|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@27@01  $FVF<next>)) g@3@01)))
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 5
(declare-const n@28@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@28@01 g@3@01))
(pop) ; 6
(declare-fun inv@29@01 ($Ref) $Ref)
(declare-fun img@30@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@28@01 $Ref) (n2@28@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@28@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n1@28@01) n1@28@01))
      (and
        (Set_in n2@28@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n2@28@01) n2@28@01))
      (= n1@28@01 n2@28@01))
    (= n1@28@01 n2@28@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@28@01 $Ref)) (!
  (=>
    (Set_in n@28@01 g@3@01)
    (and (= (inv@29@01 n@28@01) n@28@01) (img@30@01 n@28@01)))
  :pattern ((Set_in n@28@01 g@3@01))
  :pattern ((inv@29@01 n@28@01))
  :pattern ((img@30@01 n@28@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@30@01 r) (Set_in (inv@29@01 r) g@3@01)) (= (inv@29@01 r) r))
  :pattern ((inv@29@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@29@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
  :pattern ((inv@29@01 r))
  :qid |quant-u-114|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@31@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r) (= r (inv@29@01 r)))
    ($Perm.min
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@32@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r) (= r (inv@29@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@31@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@31@01 r))
    $Perm.No)
  
  :qid |quant-u-116|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r) (= r (inv@29@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@31@01 r)) $Perm.No))
  
  :qid |quant-u-117|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@32@01 x@4@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@32@01 r) $Perm.No)
  
  :qid |quant-u-119|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r) (= r (inv@29@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@31@01 r)) (pTaken@32@01 r))
      $Perm.No))
  
  :qid |quant-u-120|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@33@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>)))
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r)))
    (=>
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r))
      (Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@33@01  $FVF<next>)) g@3@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@28@01 $Ref)) (!
  (=>
    (Set_in n@28@01 g@3@01)
    (and (= (inv@29@01 n@28@01) n@28@01) (img@30@01 n@28@01)))
  :pattern ((Set_in n@28@01 g@3@01))
  :pattern ((inv@29@01 n@28@01))
  :pattern ((img@30@01 n@28@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@30@01 r) (Set_in (inv@29@01 r) g@3@01)) (= (inv@29@01 r) r))
  :pattern ((inv@29@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>)))
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r)))
    (=>
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r))
      (Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@29@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
    :pattern ((inv@29@01 r))
    :qid |quant-u-114|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@33@01  $FVF<next>)) g@3@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 7 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@22@01 $Ref)) (!
  (=>
    (Set_in n@22@01 g@3@01)
    (and (= (inv@23@01 n@22@01) n@22@01) (img@24@01 n@22@01)))
  :pattern ((Set_in n@22@01 g@3@01))
  :pattern ((inv@23@01 n@22@01))
  :pattern ((img@24@01 n@22@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@24@01 r) (Set_in (inv@23@01 r) g@3@01)) (= (inv@23@01 r) r))
  :pattern ((inv@23@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>)))
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r)))
    (=>
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r))
      (Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@27@01  $FVF<next>))))
  :qid |qp.fvfDomDef13|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@27@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@23@01 r) g@3@01) (img@24@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@27@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@27@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (forall ((n@28@01 $Ref)) (!
  (=>
    (Set_in n@28@01 g@3@01)
    (and (= (inv@29@01 n@28@01) n@28@01) (img@30@01 n@28@01)))
  :pattern ((Set_in n@28@01 g@3@01))
  :pattern ((inv@29@01 n@28@01))
  :pattern ((img@30@01 n@28@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@30@01 r) (Set_in (inv@29@01 r) g@3@01)) (= (inv@29@01 r) r))
  :pattern ((inv@29@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>)))
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r)))
    (=>
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r))
      (Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@33@01  $FVF<next>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@29@01 r) g@3@01) (img@30@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (=>
  (= y@5@01 $Ref.null)
  (and
    (= y@5@01 $Ref.null)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@23@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
      :pattern ((inv@23@01 r))
      :qid |quant-u-106|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@27@01  $FVF<next>)) g@3@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@29@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
      :pattern ((inv@29@01 r))
      :qid |quant-u-114|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@33@01  $FVF<next>)) g@3@01))))
; Joined path conditions
(assert (or (not (= y@5@01 $Ref.null)) (= y@5@01 $Ref.null)))
(assert (=>
  (= y@5@01 $Ref.null)
  (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@27@01  $FVF<next>)) g@3@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@33@01  $FVF<next>)) g@3@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))))
  $Snap.unit))
; [eval] y != null ==> (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y))
; [eval] y != null
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 8 | y@5@01 != Null | live]
; [else-branch: 8 | y@5@01 == Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 8 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y))
(declare-const v1@34@01 $Ref)
(declare-const v2@35@01 $Ref)
(push) ; 5
; [eval] edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x && v2 == y)
; [eval] edge($$(g), v1, v2)
; [eval] $$(g)
(push) ; 6
(declare-const n@36@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@36@01 g@3@01))
(pop) ; 7
(declare-fun inv@37@01 ($Ref) $Ref)
(declare-fun img@38@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@36@01 $Ref) (n2@36@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@36@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n1@36@01) n1@36@01))
      (and
        (Set_in n2@36@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n2@36@01) n2@36@01))
      (= n1@36@01 n2@36@01))
    (= n1@36@01 n2@36@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@36@01 $Ref)) (!
  (=>
    (Set_in n@36@01 g@3@01)
    (and (= (inv@37@01 n@36@01) n@36@01) (img@38@01 n@36@01)))
  :pattern ((Set_in n@36@01 g@3@01))
  :pattern ((inv@37@01 n@36@01))
  :pattern ((img@38@01 n@36@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@38@01 r) (Set_in (inv@37@01 r) g@3@01)) (= (inv@37@01 r) r))
  :pattern ((inv@37@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@37@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
  :pattern ((inv@37@01 r))
  :qid |quant-u-122|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@39@01 ((r $Ref) (v1@34@01 $Ref) (v2@35@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r) (= r (inv@37@01 r)))
    ($Perm.min
      (ite
        (and
          (img@19@01 r)
          (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@40@01 ((r $Ref) (v1@34@01 $Ref) (v2@35@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r) (= r (inv@37@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@39@01 r v1@34@01 v2@35@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@19@01 r)
          (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@39@01 r v1@34@01 v2@35@01))
    $Perm.No)
  
  :qid |quant-u-124|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r) (= r (inv@37@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@39@01 r v1@34@01 v2@35@01))
      $Perm.No))
  
  :qid |quant-u-125|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@40@01 x@4@01 v1@34@01 v2@35@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@40@01 r v1@34@01 v2@35@01) $Perm.No)
  
  :qid |quant-u-127|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r) (= r (inv@37@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@39@01 r v1@34@01 v2@35@01))
        (pTaken@40@01 r v1@34@01 v2@35@01))
      $Perm.No))
  
  :qid |quant-u-128|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@41@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)))
    (=>
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef21|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef20|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@36@01 $Ref)) (!
  (=>
    (Set_in n@36@01 g@3@01)
    (and (= (inv@37@01 n@36@01) n@36@01) (img@38@01 n@36@01)))
  :pattern ((Set_in n@36@01 g@3@01))
  :pattern ((inv@37@01 n@36@01))
  :pattern ((img@38@01 n@36@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@38@01 r) (Set_in (inv@37@01 r) g@3@01)) (= (inv@37@01 r) r))
  :pattern ((inv@37@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)))
    (=>
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef21|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@37@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
    :pattern ((inv@37@01 r))
    :qid |quant-u-122|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01)))
; [eval] edge(old($$(g)), v1, v2) || v1 == x && v2 == y
; [eval] edge(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 6
(declare-const n@42@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@42@01 g@3@01))
(pop) ; 7
(declare-fun inv@43@01 ($Ref) $Ref)
(declare-fun img@44@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@42@01 $Ref) (n2@42@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@42@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n1@42@01) n1@42@01))
      (and
        (Set_in n2@42@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n2@42@01) n2@42@01))
      (= n1@42@01 n2@42@01))
    (= n1@42@01 n2@42@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@42@01 $Ref)) (!
  (=>
    (Set_in n@42@01 g@3@01)
    (and (= (inv@43@01 n@42@01) n@42@01) (img@44@01 n@42@01)))
  :pattern ((Set_in n@42@01 g@3@01))
  :pattern ((inv@43@01 n@42@01))
  :pattern ((img@44@01 n@42@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@44@01 r) (Set_in (inv@43@01 r) g@3@01)) (= (inv@43@01 r) r))
  :pattern ((inv@43@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@43@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
  :pattern ((inv@43@01 r))
  :qid |quant-u-130|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@45@01 ((r $Ref) (v1@34@01 $Ref) (v2@35@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r) (= r (inv@43@01 r)))
    ($Perm.min
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@46@01 ((r $Ref) (v1@34@01 $Ref) (v2@35@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r) (= r (inv@43@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@45@01 r v1@34@01 v2@35@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@45@01 r v1@34@01 v2@35@01))
    $Perm.No)
  
  :qid |quant-u-132|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r) (= r (inv@43@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@45@01 r v1@34@01 v2@35@01))
      $Perm.No))
  
  :qid |quant-u-133|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@46@01 x@4@01 v1@34@01 v2@35@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@46@01 r v1@34@01 v2@35@01) $Perm.No)
  
  :qid |quant-u-135|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r) (= r (inv@43@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@45@01 r v1@34@01 v2@35@01))
        (pTaken@46@01 r v1@34@01 v2@35@01))
      $Perm.No))
  
  :qid |quant-u-136|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@47@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)))
    (=>
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>))))
  :qid |qp.fvfDomDef25|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef23|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef24|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@42@01 $Ref)) (!
  (=>
    (Set_in n@42@01 g@3@01)
    (and (= (inv@43@01 n@42@01) n@42@01) (img@44@01 n@42@01)))
  :pattern ((Set_in n@42@01 g@3@01))
  :pattern ((inv@43@01 n@42@01))
  :pattern ((img@44@01 n@42@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@44@01 r) (Set_in (inv@43@01 r) g@3@01)) (= (inv@43@01 r) r))
  :pattern ((inv@43@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)))
    (=>
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>))))
  :qid |qp.fvfDomDef25|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef23|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef24|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@43@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
    :pattern ((inv@43@01 r))
    :qid |quant-u-130|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01)))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 9 | edge[Bool]($$(sm@47@01, g@3@01), v1@34@01, v2@35@01) | live]
; [else-branch: 9 | !(edge[Bool]($$(sm@47@01, g@3@01), v1@34@01, v2@35@01)) | live]
(push) ; 7
; [then-branch: 9 | edge[Bool]($$(sm@47@01, g@3@01), v1@34@01, v2@35@01)]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
(pop) ; 7
(push) ; 7
; [else-branch: 9 | !(edge[Bool]($$(sm@47@01, g@3@01), v1@34@01, v2@35@01))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01)))
; [eval] v1 == x && v2 == y
; [eval] v1 == x
(push) ; 8
; [then-branch: 10 | v1@34@01 != x@4@01 | live]
; [else-branch: 10 | v1@34@01 == x@4@01 | live]
(push) ; 9
; [then-branch: 10 | v1@34@01 != x@4@01]
(assert (not (= v1@34@01 x@4@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 10 | v1@34@01 == x@4@01]
(assert (= v1@34@01 x@4@01))
; [eval] v2 == y
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or (= v1@34@01 x@4@01) (not (= v1@34@01 x@4@01))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (=>
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
  (and
    (not
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
    (or (= v1@34@01 x@4@01) (not (= v1@34@01 x@4@01))))))
(assert (or
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01)))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@36@01 $Ref)) (!
  (=>
    (Set_in n@36@01 g@3@01)
    (and (= (inv@37@01 n@36@01) n@36@01) (img@38@01 n@36@01)))
  :pattern ((Set_in n@36@01 g@3@01))
  :pattern ((inv@37@01 n@36@01))
  :pattern ((img@38@01 n@36@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@38@01 r) (Set_in (inv@37@01 r) g@3@01)) (= (inv@37@01 r) r))
  :pattern ((inv@37@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)))
    (=>
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef21|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (forall ((n@42@01 $Ref)) (!
  (=>
    (Set_in n@42@01 g@3@01)
    (and (= (inv@43@01 n@42@01) n@42@01) (img@44@01 n@42@01)))
  :pattern ((Set_in n@42@01 g@3@01))
  :pattern ((inv@43@01 n@42@01))
  :pattern ((img@44@01 n@42@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@44@01 r) (Set_in (inv@43@01 r) g@3@01)) (= (inv@43@01 r) r))
  :pattern ((inv@43@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)))
    (=>
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>))))
  :qid |qp.fvfDomDef25|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef23|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef24|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@37@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
  :pattern ((inv@37@01 r))
  :qid |quant-u-122|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@43@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
  :pattern ((inv@43@01 r))
  :qid |quant-u-130|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@34@01 $Ref) (v2@35@01 $Ref)) (!
  (and
    (=>
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
      (and
        (not
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
        (or (= v1@34@01 x@4@01) (not (= v1@34@01 x@4@01)))))
    (or
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01)))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@281@27@283@78-aux|)))
(pop) ; 4
(push) ; 4
; [else-branch: 8 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@36@01 $Ref)) (!
  (=>
    (Set_in n@36@01 g@3@01)
    (and (= (inv@37@01 n@36@01) n@36@01) (img@38@01 n@36@01)))
  :pattern ((Set_in n@36@01 g@3@01))
  :pattern ((inv@37@01 n@36@01))
  :pattern ((img@38@01 n@36@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@38@01 r) (Set_in (inv@37@01 r) g@3@01)) (= (inv@37@01 r) r))
  :pattern ((inv@37@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)))
    (=>
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@41@01  $FVF<next>))))
  :qid |qp.fvfDomDef21|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@37@01 r) g@3@01) (img@38@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@41@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@41@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (forall ((n@42@01 $Ref)) (!
  (=>
    (Set_in n@42@01 g@3@01)
    (and (= (inv@43@01 n@42@01) n@42@01) (img@44@01 n@42@01)))
  :pattern ((Set_in n@42@01 g@3@01))
  :pattern ((inv@43@01 n@42@01))
  :pattern ((img@44@01 n@42@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@44@01 r) (Set_in (inv@43@01 r) g@3@01)) (= (inv@43@01 r) r))
  :pattern ((inv@43@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)))
    (=>
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@47@01  $FVF<next>))))
  :qid |qp.fvfDomDef25|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@43@01 r) g@3@01) (img@44@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef23|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef24|)))
(assert (=>
  (not (= y@5@01 $Ref.null))
  (and
    (not (= y@5@01 $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@37@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
      :pattern ((inv@37@01 r))
      :qid |quant-u-122|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@43@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
      :pattern ((inv@43@01 r))
      :qid |quant-u-130|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01)
    (forall ((v1@34@01 $Ref) (v2@35@01 $Ref)) (!
      (and
        (=>
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
          (and
            (not
              (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
            (or (= v1@34@01 x@4@01) (not (= v1@34@01 x@4@01)))))
        (or
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01)))
      :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@281@27@283@78-aux|)))))
; Joined path conditions
(assert (=>
  (not (= y@5@01 $Ref.null))
  (forall ((v1@34@01 $Ref) (v2@35@01 $Ref)) (!
    (=
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@41@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01)
      (or
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01)
        (and (= v1@34@01 x@4@01) (= v2@35@01 y@5@01))))
    :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@47@01  $FVF<next>)) g@3@01) v1@34@01 v2@35@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@281@27@283@78|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))))
  $Snap.unit))
; [eval] y != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)))
; [eval] y != null
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= y@5@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= y@5@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; [then-branch: 11 | y@5@01 != Null | live]
; [else-branch: 11 | y@5@01 == Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 11 | y@5@01 != Null]
(assert (not (= y@5@01 $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)))
(declare-const v1@48@01 $Ref)
(declare-const v2@49@01 $Ref)
(push) ; 5
; [eval] v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2))
; [eval] v1 != v2
(push) ; 6
; [then-branch: 12 | v1@48@01 != v2@49@01 | live]
; [else-branch: 12 | v1@48@01 == v2@49@01 | live]
(push) ; 7
; [then-branch: 12 | v1@48@01 != v2@49@01]
(assert (not (= v1@48@01 v2@49@01)))
; [eval] exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2))
; [eval] exists_path($$(g), v1, v2)
; [eval] $$(g)
(push) ; 8
(declare-const n@50@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@50@01 g@3@01))
(pop) ; 9
(declare-fun inv@51@01 ($Ref) $Ref)
(declare-fun img@52@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@50@01 $Ref) (n2@50@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@50@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n1@50@01) n1@50@01))
      (and
        (Set_in n2@50@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) n2@50@01) n2@50@01))
      (= n1@50@01 n2@50@01))
    (= n1@50@01 n2@50@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@50@01 $Ref)) (!
  (=>
    (Set_in n@50@01 g@3@01)
    (and (= (inv@51@01 n@50@01) n@50@01) (img@52@01 n@50@01)))
  :pattern ((Set_in n@50@01 g@3@01))
  :pattern ((inv@51@01 n@50@01))
  :pattern ((img@52@01 n@50@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@52@01 r) (Set_in (inv@51@01 r) g@3@01)) (= (inv@51@01 r) r))
  :pattern ((inv@51@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@51@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
  :pattern ((inv@51@01 r))
  :qid |quant-u-138|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@53@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r) (= r (inv@51@01 r)))
    ($Perm.min
      (ite
        (and
          (img@19@01 r)
          (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@54@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r) (= r (inv@51@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@53@01 r v1@48@01 v2@49@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@19@01 r)
          (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@53@01 r v1@48@01 v2@49@01))
    $Perm.No)
  
  :qid |quant-u-140|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r) (= r (inv@51@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@53@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-141|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@54@01 x@4@01 v1@48@01 v2@49@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@54@01 r v1@48@01 v2@49@01) $Perm.No)
  
  :qid |quant-u-143|))))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r) (= r (inv@51@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@53@01 r v1@48@01 v2@49@01))
        (pTaken@54@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-144|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@55@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)))
    (=>
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>))))
  :qid |qp.fvfDomDef29|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@50@01 $Ref)) (!
  (=>
    (Set_in n@50@01 g@3@01)
    (and (= (inv@51@01 n@50@01) n@50@01) (img@52@01 n@50@01)))
  :pattern ((Set_in n@50@01 g@3@01))
  :pattern ((inv@51@01 n@50@01))
  :pattern ((img@52@01 n@50@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@52@01 r) (Set_in (inv@51@01 r) g@3@01)) (= (inv@51@01 r) r))
  :pattern ((inv@51@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)))
    (=>
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>))))
  :qid |qp.fvfDomDef29|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@51@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
    :pattern ((inv@51@01 r))
    :qid |quant-u-138|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01)))
; [eval] exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)
; [eval] exists_path(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 8
(declare-const n@56@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@56@01 g@3@01))
(pop) ; 9
(declare-fun inv@57@01 ($Ref) $Ref)
(declare-fun img@58@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@56@01 $Ref) (n2@56@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@56@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n1@56@01) n1@56@01))
      (and
        (Set_in n2@56@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) n2@56@01) n2@56@01))
      (= n1@56@01 n2@56@01))
    (= n1@56@01 n2@56@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@56@01 $Ref)) (!
  (=>
    (Set_in n@56@01 g@3@01)
    (and (= (inv@57@01 n@56@01) n@56@01) (img@58@01 n@56@01)))
  :pattern ((Set_in n@56@01 g@3@01))
  :pattern ((inv@57@01 n@56@01))
  :pattern ((img@58@01 n@56@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@58@01 r) (Set_in (inv@57@01 r) g@3@01)) (= (inv@57@01 r) r))
  :pattern ((inv@57@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@57@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
  :pattern ((inv@57@01 r))
  :qid |quant-u-146|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@59@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r) (= r (inv@57@01 r)))
    ($Perm.min
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@60@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r) (= r (inv@57@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@59@01 r v1@48@01 v2@49@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@59@01 r v1@48@01 v2@49@01))
    $Perm.No)
  
  :qid |quant-u-148|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r) (= r (inv@57@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@59@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-149|))))
(check-sat)
; unknown
(pop) ; 9
; 0,02s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@60@01 x@4@01 v1@48@01 v2@49@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@60@01 r v1@48@01 v2@49@01) $Perm.No)
  
  :qid |quant-u-151|))))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r) (= r (inv@57@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@59@01 r v1@48@01 v2@49@01))
        (pTaken@60@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-152|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@61@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)))
    (=>
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@56@01 $Ref)) (!
  (=>
    (Set_in n@56@01 g@3@01)
    (and (= (inv@57@01 n@56@01) n@56@01) (img@58@01 n@56@01)))
  :pattern ((Set_in n@56@01 g@3@01))
  :pattern ((inv@57@01 n@56@01))
  :pattern ((img@58@01 n@56@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@58@01 r) (Set_in (inv@57@01 r) g@3@01)) (= (inv@57@01 r) r))
  :pattern ((inv@57@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)))
    (=>
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@57@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
    :pattern ((inv@57@01 r))
    :qid |quant-u-146|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 13 | exists_path[Bool]($$(sm@61@01, g@3@01), v1@48@01, v2@49@01) | live]
; [else-branch: 13 | !(exists_path[Bool]($$(sm@61@01, g@3@01), v1@48@01, v2@49@01)) | live]
(push) ; 9
; [then-branch: 13 | exists_path[Bool]($$(sm@61@01, g@3@01), v1@48@01, v2@49@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
(pop) ; 9
(push) ; 9
; [else-branch: 13 | !(exists_path[Bool]($$(sm@61@01, g@3@01), v1@48@01, v2@49@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01)))
; [eval] exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), y, v2)
; [eval] exists_path(old($$(g)), v1, x)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 10
(declare-const n@62@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@62@01 g@3@01))
(pop) ; 11
(declare-fun inv@63@01 ($Ref) $Ref)
(declare-fun img@64@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@65@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@62@01 $Ref) (n2@62@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@62@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) n1@62@01) n1@62@01))
      (and
        (Set_in n2@62@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) n2@62@01) n2@62@01))
      (= n1@62@01 n2@62@01))
    (= n1@62@01 n2@62@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@62@01 $Ref)) (!
  (=>
    (Set_in n@62@01 g@3@01)
    (and (= (inv@63@01 n@62@01) n@62@01) (img@64@01 n@62@01)))
  :pattern ((Set_in n@62@01 g@3@01))
  :pattern ((inv@63@01 n@62@01))
  :pattern ((img@64@01 n@62@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@64@01 r) (Set_in (inv@63@01 r) g@3@01)) (= (inv@63@01 r) r))
  :pattern ((inv@63@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@63@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) r) r))
  :pattern ((inv@63@01 r))
  :qid |quant-u-154|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@66@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r) (= r (inv@63@01 r)))
    ($Perm.min
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@67@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r) (= r (inv@63@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@66@01 r v1@48@01 v2@49@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@66@01 r v1@48@01 v2@49@01))
    $Perm.No)
  
  :qid |quant-u-156|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r) (= r (inv@63@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@66@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-157|))))
(check-sat)
; unknown
(pop) ; 11
; 0,01s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@67@01 x@4@01 v1@48@01 v2@49@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 11
; 0,03s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@67@01 r v1@48@01 v2@49@01) $Perm.No)
  
  :qid |quant-u-159|))))
(check-sat)
; unknown
(pop) ; 11
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r) (= r (inv@63@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@66@01 r v1@48@01 v2@49@01))
        (pTaken@67@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-160|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@68@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)))
    (=>
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>))))
  :qid |qp.fvfDomDef40|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((n@62@01 $Ref)) (!
  (=>
    (Set_in n@62@01 g@3@01)
    (and (= (inv@63@01 n@62@01) n@62@01) (img@64@01 n@62@01)))
  :pattern ((Set_in n@62@01 g@3@01))
  :pattern ((inv@63@01 n@62@01))
  :pattern ((img@64@01 n@62@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@64@01 r) (Set_in (inv@63@01 r) g@3@01)) (= (inv@63@01 r) r))
  :pattern ((inv@63@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)))
    (=>
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@63@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) r) r))
    :pattern ((inv@63@01 r))
    :qid |quant-u-154|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01)))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 14 | !(exists_path[Bool]($$(sm@68@01, g@3@01), v1@48@01, x@4@01)) | live]
; [else-branch: 14 | exists_path[Bool]($$(sm@68@01, g@3@01), v1@48@01, x@4@01) | live]
(push) ; 11
; [then-branch: 14 | !(exists_path[Bool]($$(sm@68@01, g@3@01), v1@48@01, x@4@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)))
(pop) ; 11
(push) ; 11
; [else-branch: 14 | exists_path[Bool]($$(sm@68@01, g@3@01), v1@48@01, x@4@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01))
; [eval] exists_path(old($$(g)), y, v2)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 12
(declare-const n@69@01 $Ref)
(push) ; 13
; [eval] (n in refs)
(assert (Set_in n@69@01 g@3@01))
(pop) ; 13
(declare-fun inv@70@01 ($Ref) $Ref)
(declare-fun img@71@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@72@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((n1@69@01 $Ref) (n2@69@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@69@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n1@69@01) n1@69@01))
      (and
        (Set_in n2@69@01 g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n2@69@01) n2@69@01))
      (= n1@69@01 n2@69@01))
    (= n1@69@01 n2@69@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@70@01 r) g@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
  :pattern ((inv@70@01 r))
  :qid |quant-u-162|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@73@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r) (= r (inv@70@01 r)))
    ($Perm.min
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@74@01 ((r $Ref) (v1@48@01 $Ref) (v2@49@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r) (= r (inv@70@01 r)))
    ($Perm.min
      (ite (= r x@4@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@73@01 r v1@48@01 v2@49@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@11@01 r)
          (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@73@01 r v1@48@01 v2@49@01))
    $Perm.No)
  
  :qid |quant-u-164|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r) (= r (inv@70@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@73@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-165|))))
(check-sat)
; unknown
(pop) ; 13
; 0,02s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@74@01 x@4@01 v1@48@01 v2@49@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 13
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@74@01 r v1@48@01 v2@49@01) $Perm.No)
  
  :qid |quant-u-167|))))
(check-sat)
; unknown
(pop) ; 13
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r) (= r (inv@70@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@73@01 r v1@48@01 v2@49@01))
        (pTaken@74@01 r v1@48@01 v2@49@01))
      $Perm.No))
  
  :qid |quant-u-168|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@75@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01))
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@70@01 r) g@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
    :pattern ((inv@70@01 r))
    :qid |quant-u-162|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@70@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
      :pattern ((inv@70@01 r))
      :qid |quant-u-162|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((n@62@01 $Ref)) (!
  (=>
    (Set_in n@62@01 g@3@01)
    (and (= (inv@63@01 n@62@01) n@62@01) (img@64@01 n@62@01)))
  :pattern ((Set_in n@62@01 g@3@01))
  :pattern ((inv@63@01 n@62@01))
  :pattern ((img@64@01 n@62@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@64@01 r) (Set_in (inv@63@01 r) g@3@01)) (= (inv@63@01 r) r))
  :pattern ((inv@63@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)))
    (=>
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
(assert (=>
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
  (and
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@63@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) r) r))
      :pattern ((inv@63@01 r))
      :qid |quant-u-154|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@70@01 r) g@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
          :pattern ((inv@70@01 r))
          :qid |quant-u-162|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01))))))
(assert (or
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01)))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 12 | v1@48@01 == v2@49@01]
(assert (= v1@48@01 v2@49@01))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((n@50@01 $Ref)) (!
  (=>
    (Set_in n@50@01 g@3@01)
    (and (= (inv@51@01 n@50@01) n@50@01) (img@52@01 n@50@01)))
  :pattern ((Set_in n@50@01 g@3@01))
  :pattern ((inv@51@01 n@50@01))
  :pattern ((img@52@01 n@50@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@52@01 r) (Set_in (inv@51@01 r) g@3@01)) (= (inv@51@01 r) r))
  :pattern ((inv@51@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)))
    (=>
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>))))
  :qid |qp.fvfDomDef29|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (forall ((n@56@01 $Ref)) (!
  (=>
    (Set_in n@56@01 g@3@01)
    (and (= (inv@57@01 n@56@01) n@56@01) (img@58@01 n@56@01)))
  :pattern ((Set_in n@56@01 g@3@01))
  :pattern ((inv@57@01 n@56@01))
  :pattern ((img@58@01 n@56@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@58@01 r) (Set_in (inv@57@01 r) g@3@01)) (= (inv@57@01 r) r))
  :pattern ((inv@57@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)))
    (=>
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((n@62@01 $Ref)) (!
  (=>
    (Set_in n@62@01 g@3@01)
    (and (= (inv@63@01 n@62@01) n@62@01) (img@64@01 n@62@01)))
  :pattern ((Set_in n@62@01 g@3@01))
  :pattern ((inv@63@01 n@62@01))
  :pattern ((img@64@01 n@62@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@64@01 r) (Set_in (inv@63@01 r) g@3@01)) (= (inv@63@01 r) r))
  :pattern ((inv@63@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)))
    (=>
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
(assert (=>
  (not (= v1@48@01 v2@49@01))
  (and
    (not (= v1@48@01 v2@49@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@51@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
      :pattern ((inv@51@01 r))
      :qid |quant-u-138|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@57@01 r) g@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
      :pattern ((inv@57@01 r))
      :qid |quant-u-146|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01)
    (=>
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
      (and
        (not
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@63@01 r) g@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) r) r))
          :pattern ((inv@63@01 r))
          :qid |quant-u-154|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@70@01 r) g@3@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
              :pattern ((inv@70@01 r))
              :qid |quant-u-162|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)))))
    (or
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01)))))
; Joined path conditions
(assert (or (= v1@48@01 v2@49@01) (not (= v1@48@01 v2@49@01))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@50@01 $Ref)) (!
  (=>
    (Set_in n@50@01 g@3@01)
    (and (= (inv@51@01 n@50@01) n@50@01) (img@52@01 n@50@01)))
  :pattern ((Set_in n@50@01 g@3@01))
  :pattern ((inv@51@01 n@50@01))
  :pattern ((img@52@01 n@50@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@52@01 r) (Set_in (inv@51@01 r) g@3@01)) (= (inv@51@01 r) r))
  :pattern ((inv@51@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)))
    (=>
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>))))
  :qid |qp.fvfDomDef29|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (forall ((n@56@01 $Ref)) (!
  (=>
    (Set_in n@56@01 g@3@01)
    (and (= (inv@57@01 n@56@01) n@56@01) (img@58@01 n@56@01)))
  :pattern ((Set_in n@56@01 g@3@01))
  :pattern ((inv@57@01 n@56@01))
  :pattern ((img@58@01 n@56@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@58@01 r) (Set_in (inv@57@01 r) g@3@01)) (= (inv@57@01 r) r))
  :pattern ((inv@57@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)))
    (=>
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((n@62@01 $Ref)) (!
  (=>
    (Set_in n@62@01 g@3@01)
    (and (= (inv@63@01 n@62@01) n@62@01) (img@64@01 n@62@01)))
  :pattern ((Set_in n@62@01 g@3@01))
  :pattern ((inv@63@01 n@62@01))
  :pattern ((img@64@01 n@62@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@64@01 r) (Set_in (inv@63@01 r) g@3@01)) (= (inv@63@01 r) r))
  :pattern ((inv@63@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)))
    (=>
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@48@01 $Ref) (v2@49@01 $Ref)) (!
  (and
    (=>
      (not (= v1@48@01 v2@49@01))
      (and
        (not (= v1@48@01 v2@49@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@51@01 r) g@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
          :pattern ((inv@51@01 r))
          :qid |quant-u-138|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@57@01 r) g@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
          :pattern ((inv@57@01 r))
          :qid |quant-u-146|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01)
        (=>
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
          (and
            (not
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@63@01 r) g@3@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) r) r))
              :pattern ((inv@63@01 r))
              :qid |quant-u-154|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01)
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@70@01 r) g@3@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
                  :pattern ((inv@70@01 r))
                  :qid |quant-u-162|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01)))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)))))
        (or
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))))
    (or (= v1@48@01 v2@49@01) (not (= v1@48@01 v2@49@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@284@28@288@117-aux|)))
(pop) ; 4
(push) ; 4
; [else-branch: 11 | y@5@01 == Null]
(assert (= y@5@01 $Ref.null))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@50@01 $Ref)) (!
  (=>
    (Set_in n@50@01 g@3@01)
    (and (= (inv@51@01 n@50@01) n@50@01) (img@52@01 n@50@01)))
  :pattern ((Set_in n@50@01 g@3@01))
  :pattern ((inv@51@01 n@50@01))
  :pattern ((img@52@01 n@50@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@52@01 r) (Set_in (inv@51@01 r) g@3@01)) (= (inv@51@01 r) r))
  :pattern ((inv@51@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)))
    (=>
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@55@01  $FVF<next>))))
  :qid |qp.fvfDomDef29|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@15@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@15@01  $FVF<next>) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@51@01 r) g@3@01) (img@52@01 r))
      (and
        (img@19@01 r)
        (and (Set_in (inv@18@01 r) g@3@01) (not (= (inv@18@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@55@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@15@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@55@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (forall ((n@56@01 $Ref)) (!
  (=>
    (Set_in n@56@01 g@3@01)
    (and (= (inv@57@01 n@56@01) n@56@01) (img@58@01 n@56@01)))
  :pattern ((Set_in n@56@01 g@3@01))
  :pattern ((inv@57@01 n@56@01))
  :pattern ((img@58@01 n@56@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@58@01 r) (Set_in (inv@57@01 r) g@3@01)) (= (inv@57@01 r) r))
  :pattern ((inv@57@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)))
    (=>
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@61@01  $FVF<next>))))
  :qid |qp.fvfDomDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@57@01 r) g@3@01) (img@58@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@61@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@61@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@65@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@65@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((n@62@01 $Ref)) (!
  (=>
    (Set_in n@62@01 g@3@01)
    (and (= (inv@63@01 n@62@01) n@62@01) (img@64@01 n@62@01)))
  :pattern ((Set_in n@62@01 g@3@01))
  :pattern ((inv@63@01 n@62@01))
  :pattern ((img@64@01 n@62@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@64@01 r) (Set_in (inv@63@01 r) g@3@01)) (= (inv@63@01 r) r))
  :pattern ((inv@63@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)))
    (=>
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@68@01  $FVF<next>))))
  :qid |qp.fvfDomDef40|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@63@01 r) g@3@01) (img@64@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@68@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@68@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@4@01)
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@11@01 r)
      (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01))))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((n@69@01 $Ref)) (!
  (=>
    (Set_in n@69@01 g@3@01)
    (and (= (inv@70@01 n@69@01) n@69@01) (img@71@01 n@69@01)))
  :pattern ((Set_in n@69@01 g@3@01))
  :pattern ((inv@70@01 n@69@01))
  :pattern ((img@71@01 n@69@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g@3@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)))
    (=>
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@75@01  $FVF<next>))))
  :qid |qp.fvfDomDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r)) (= r x@4@01))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@7@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@7@01  $FVF<next>) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@70@01 r) g@3@01) (img@71@01 r))
      (and
        (img@11@01 r)
        (and (Set_in (inv@10@01 r) g@3@01) (not (= (inv@10@01 r) x@4@01)))))
    (=
      ($FVF.lookup_next (as sm@75@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r)))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@7@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@6@01))))))) r) r))
  :pattern (($FVF.lookup_next (as sm@75@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef46|)))
(assert (=>
  (not (= y@5@01 $Ref.null))
  (and
    (not (= y@5@01 $Ref.null))
    (forall ((v1@48@01 $Ref) (v2@49@01 $Ref)) (!
      (and
        (=>
          (not (= v1@48@01 v2@49@01))
          (and
            (not (= v1@48@01 v2@49@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@51@01 r) g@3@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@20@01  $FVF<next>) r) r))
              :pattern ((inv@51@01 r))
              :qid |quant-u-138|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@57@01 r) g@3@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@12@01  $FVF<next>) r) r))
              :pattern ((inv@57@01 r))
              :qid |quant-u-146|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01)
            (=>
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
              (and
                (not
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@63@01 r) g@3@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@65@01  $FVF<next>) r) r))
                  :pattern ((inv@63@01 r))
                  :qid |quant-u-154|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01)
                (=>
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
                  (and
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
                    (forall ((r $Ref)) (!
                      (=>
                        (Set_in (inv@70@01 r) g@3@01)
                        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
                      :pattern ((inv@70@01 r))
                      :qid |quant-u-162|))
                    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01)))
                (or
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
                  (not
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)))))
            (or
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))))
        (or (= v1@48@01 v2@49@01) (not (= v1@48@01 v2@49@01))))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@284@28@288@117-aux|)))))
; Joined path conditions
(assert (=>
  (not (= y@5@01 $Ref.null))
  (forall ((v1@48@01 $Ref) (v2@49@01 $Ref)) (!
    (=>
      (not (= v1@48@01 v2@49@01))
      (=
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01)
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@61@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@68@01  $FVF<next>)) g@3@01) v1@48@01 x@4@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@75@01  $FVF<next>)) g@3@01) y@5@01 v2@49@01)))))
    :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@55@01  $FVF<next>)) g@3@01) v1@48@01 v2@49@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@284@28@288@117|))))
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- unlink ----------
(declare-const g@76@01 Set<$Ref>)
(declare-const x@77@01 $Ref)
(declare-const g@78@01 Set<$Ref>)
(declare-const x@79@01 $Ref)
(push) ; 1
(declare-const $t@80@01 $Snap)
(assert (= $t@80@01 ($Snap.combine ($Snap.first $t@80@01) ($Snap.second $t@80@01))))
(assert (= ($Snap.first $t@80@01) $Snap.unit))
; [eval] (x in g)
(assert (Set_in x@79@01 g@78@01))
(assert (=
  ($Snap.second $t@80@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@80@01))
    ($Snap.second ($Snap.second $t@80@01)))))
(assert (= ($Snap.first ($Snap.second $t@80@01)) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (not (Set_in $Ref.null g@78@01)))
(assert (=
  ($Snap.second ($Snap.second $t@80@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@80@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@80@01))) $Snap.unit))
; [eval] (x in g)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@80@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))))
(declare-const sm@81@01 $FVF<next>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($FVF.lookup_next (as sm@81@01  $FVF<next>) x@79@01)
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))))
(assert (not (= x@79@01 $Ref.null)))
(declare-const sm@82@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@82@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@82@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
  :pattern (($FVF.lookup_next (as sm@82@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef49|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@82@01  $FVF<next>) x@79@01) x@79@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))))
(declare-const n@83@01 $Ref)
(push) ; 2
; [eval] (n in g) && n != x
; [eval] (n in g)
(push) ; 3
; [then-branch: 15 | !(n@83@01 in g@78@01) | live]
; [else-branch: 15 | n@83@01 in g@78@01 | live]
(push) ; 4
; [then-branch: 15 | !(n@83@01 in g@78@01)]
(assert (not (Set_in n@83@01 g@78@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 15 | n@83@01 in g@78@01]
(assert (Set_in n@83@01 g@78@01))
; [eval] n != x
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (Set_in n@83@01 g@78@01) (not (Set_in n@83@01 g@78@01))))
(assert (and (Set_in n@83@01 g@78@01) (not (= n@83@01 x@79@01))))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@84@01 ($Ref) $Ref)
(declare-fun img@85@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((n@83@01 $Ref)) (!
  (=>
    (and (Set_in n@83@01 g@78@01) (not (= n@83@01 x@79@01)))
    (or (Set_in n@83@01 g@78@01) (not (Set_in n@83@01 g@78@01))))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) n@83@01) n@83@01))
  :qid |next-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@83@01 $Ref) (n2@83@01 $Ref)) (!
  (=>
    (and
      (and (Set_in n1@83@01 g@78@01) (not (= n1@83@01 x@79@01)))
      (and (Set_in n2@83@01 g@78@01) (not (= n2@83@01 x@79@01)))
      (= n1@83@01 n2@83@01))
    (= n1@83@01 n2@83@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@83@01 $Ref)) (!
  (=>
    (and (Set_in n@83@01 g@78@01) (not (= n@83@01 x@79@01)))
    (and (= (inv@84@01 n@83@01) n@83@01) (img@85@01 n@83@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) n@83@01) n@83@01))
  :qid |quant-u-170|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (= (inv@84@01 r) r))
  :pattern ((inv@84@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@83@01 $Ref)) (!
  (=>
    (and (Set_in n@83@01 g@78@01) (not (= n@83@01 x@79@01)))
    (not (= n@83@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) n@83@01) n@83@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@86@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef52|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
  :pattern ((inv@84@01 r))
  :qid |quant-u-171|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))
  $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@87@01 $Ref)
(push) ; 2
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 3
; [then-branch: 16 | !(n$0@87@01 in g@78@01) | live]
; [else-branch: 16 | n$0@87@01 in g@78@01 | live]
(push) ; 4
; [then-branch: 16 | !(n$0@87@01 in g@78@01)]
(assert (not (Set_in n$0@87@01 g@78@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 16 | n$0@87@01 in g@78@01]
(assert (Set_in n$0@87@01 g@78@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
    :qid |qp.fvfValDef50|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef51|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef52|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite (= n$0@87@01 x@79@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@85@01 n$0@87@01)
        (and
          (Set_in (inv@84@01 n$0@87@01) g@78@01)
          (not (= (inv@84@01 n$0@87@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef52|)))
(assert (=>
  (Set_in n$0@87@01 g@78@01)
  (and
    (Set_in n$0@87@01 g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01))))
(assert (or (Set_in n$0@87@01 g@78@01) (not (Set_in n$0@87@01 g@78@01))))
(push) ; 3
; [then-branch: 17 | n$0@87@01 in g@78@01 && Lookup(next, sm@86@01, n$0@87@01) != Null | live]
; [else-branch: 17 | !(n$0@87@01 in g@78@01 && Lookup(next, sm@86@01, n$0@87@01) != Null) | live]
(push) ; 4
; [then-branch: 17 | n$0@87@01 in g@78@01 && Lookup(next, sm@86@01, n$0@87@01) != Null]
(assert (and
  (Set_in n$0@87@01 g@78@01)
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
    :qid |qp.fvfValDef50|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef51|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef52|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite (= n$0@87@01 x@79@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@85@01 n$0@87@01)
        (and
          (Set_in (inv@84@01 n$0@87@01) g@78@01)
          (not (= (inv@84@01 n$0@87@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 17 | !(n$0@87@01 in g@78@01 && Lookup(next, sm@86@01, n$0@87@01) != Null)]
(assert (not
  (and
    (Set_in n$0@87@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef52|)))
(assert (=>
  (and
    (Set_in n$0@87@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))
  (and
    (Set_in n$0@87@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@87@01 g@78@01)
      (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))))
  (and
    (Set_in n$0@87@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef52|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@87@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@87@01 g@78@01)
      (and
        (Set_in n$0@87@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01)))
    (or (Set_in n$0@87@01 g@78@01) (not (Set_in n$0@87@01 g@78@01)))
    (=>
      (and
        (Set_in n$0@87@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))
      (and
        (Set_in n$0@87@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01)))
    (or
      (not
        (and
          (Set_in n$0@87@01 g@78@01)
          (not
            (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))))
      (and
        (Set_in n$0@87@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) g@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34-aux|)))
(assert (forall ((n$0@87@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@87@01 g@78@01)
      (and
        (Set_in n$0@87@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01)))
    (or (Set_in n$0@87@01 g@78@01) (not (Set_in n$0@87@01 g@78@01)))
    (=>
      (and
        (Set_in n$0@87@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))
      (and
        (Set_in n$0@87@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01)))
    (or
      (not
        (and
          (Set_in n$0@87@01 g@78@01)
          (not
            (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null))))
      (and
        (Set_in n$0@87@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))))
  :pattern ((Set_in n$0@87@01 g@78@01) ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34-aux|)))
(assert (forall ((n$0@87@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@87@01 g@78@01)
      (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) g@78@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) g@78@01))
  :pattern ((Set_in n$0@87@01 g@78@01) ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n$0@87@01) n$0@87@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@88@01 $Snap)
(assert (= $t@88@01 ($Snap.combine ($Snap.first $t@88@01) ($Snap.second $t@88@01))))
(assert (= ($Snap.first $t@88@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@88@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@88@01))
    ($Snap.second ($Snap.second $t@88@01)))))
(assert (= ($Snap.first ($Snap.second $t@88@01)) $Snap.unit))
; [eval] (x in g)
(assert (=
  ($Snap.second ($Snap.second $t@88@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@88@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))
(declare-const sm@89@01 $FVF<next>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($FVF.lookup_next (as sm@89@01  $FVF<next>) x@79@01)
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@88@01))))))
(declare-const sm@90@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef54|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) x@79@01) x@79@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@88@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))))
(declare-const n$1@91@01 $Ref)
(push) ; 3
; [eval] (n$1 in g) && n$1 != x
; [eval] (n$1 in g)
(push) ; 4
; [then-branch: 18 | !(n$1@91@01 in g@78@01) | live]
; [else-branch: 18 | n$1@91@01 in g@78@01 | live]
(push) ; 5
; [then-branch: 18 | !(n$1@91@01 in g@78@01)]
(assert (not (Set_in n$1@91@01 g@78@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 18 | n$1@91@01 in g@78@01]
(assert (Set_in n$1@91@01 g@78@01))
; [eval] n$1 != x
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in n$1@91@01 g@78@01) (not (Set_in n$1@91@01 g@78@01))))
(assert (and (Set_in n$1@91@01 g@78@01) (not (= n$1@91@01 x@79@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@92@01 ($Ref) $Ref)
(declare-fun img@93@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((n$1@91@01 $Ref)) (!
  (=>
    (and (Set_in n$1@91@01 g@78@01) (not (= n$1@91@01 x@79@01)))
    (or (Set_in n$1@91@01 g@78@01) (not (Set_in n$1@91@01 g@78@01))))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) n$1@91@01) n$1@91@01))
  :qid |next-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@91@01 $Ref) (n$12@91@01 $Ref)) (!
  (=>
    (and
      (and (Set_in n$11@91@01 g@78@01) (not (= n$11@91@01 x@79@01)))
      (and (Set_in n$12@91@01 g@78@01) (not (= n$12@91@01 x@79@01)))
      (= n$11@91@01 n$12@91@01))
    (= n$11@91@01 n$12@91@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@91@01 $Ref)) (!
  (=>
    (and (Set_in n$1@91@01 g@78@01) (not (= n$1@91@01 x@79@01)))
    (and (= (inv@92@01 n$1@91@01) n$1@91@01) (img@93@01 n$1@91@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) n$1@91@01) n$1@91@01))
  :qid |quant-u-173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@93@01 r)
      (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
    (= (inv@92@01 r) r))
  :pattern ((inv@92@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@91@01 $Ref)) (!
  (=>
    (and (Set_in n$1@91@01 g@78@01) (not (= n$1@91@01 x@79@01)))
    (not (= n$1@91@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) n$1@91@01) n$1@91@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@94@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@93@01 r)
      (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef57|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
  :pattern ((inv@92@01 r))
  :qid |quant-u-174|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@95@01 $Ref)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 19 | !(n$2@95@01 in g@78@01) | live]
; [else-branch: 19 | n$2@95@01 in g@78@01 | live]
(push) ; 5
; [then-branch: 19 | !(n$2@95@01 in g@78@01)]
(assert (not (Set_in n$2@95@01 g@78@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 19 | n$2@95@01 in g@78@01]
(assert (Set_in n$2@95@01 g@78@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :qid |qp.fvfValDef55|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
    :qid |qp.fvfValDef56|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef57|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite (= n$2@95@01 x@79@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@93@01 n$2@95@01)
        (and
          (Set_in (inv@92@01 n$2@95@01) g@78@01)
          (not (= (inv@92@01 n$2@95@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@93@01 r)
      (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef57|)))
(assert (=>
  (Set_in n$2@95@01 g@78@01)
  (and
    (Set_in n$2@95@01 g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01))))
(assert (or (Set_in n$2@95@01 g@78@01) (not (Set_in n$2@95@01 g@78@01))))
(push) ; 4
; [then-branch: 20 | n$2@95@01 in g@78@01 && Lookup(next, sm@94@01, n$2@95@01) != Null | live]
; [else-branch: 20 | !(n$2@95@01 in g@78@01 && Lookup(next, sm@94@01, n$2@95@01) != Null) | live]
(push) ; 5
; [then-branch: 20 | n$2@95@01 in g@78@01 && Lookup(next, sm@94@01, n$2@95@01) != Null]
(assert (and
  (Set_in n$2@95@01 g@78@01)
  (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :qid |qp.fvfValDef55|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
    :qid |qp.fvfValDef56|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef57|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite (= n$2@95@01 x@79@01) $Perm.Write $Perm.No)
    (ite
      (and
        (img@93@01 n$2@95@01)
        (and
          (Set_in (inv@92@01 n$2@95@01) g@78@01)
          (not (= (inv@92@01 n$2@95@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 20 | !(n$2@95@01 in g@78@01 && Lookup(next, sm@94@01, n$2@95@01) != Null)]
(assert (not
  (and
    (Set_in n$2@95@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@93@01 r)
      (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef57|)))
(assert (=>
  (and
    (Set_in n$2@95@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))
  (and
    (Set_in n$2@95@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@95@01 g@78@01)
      (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))))
  (and
    (Set_in n$2@95@01 g@78@01)
    (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@93@01 r)
      (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef57|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@95@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@95@01 g@78@01)
      (and
        (Set_in n$2@95@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01)))
    (or (Set_in n$2@95@01 g@78@01) (not (Set_in n$2@95@01 g@78@01)))
    (=>
      (and
        (Set_in n$2@95@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))
      (and
        (Set_in n$2@95@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01)))
    (or
      (not
        (and
          (Set_in n$2@95@01 g@78@01)
          (not
            (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))))
      (and
        (Set_in n$2@95@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) g@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@310@13@310@33-aux|)))
(assert (forall ((n$2@95@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@95@01 g@78@01)
      (and
        (Set_in n$2@95@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01)))
    (or (Set_in n$2@95@01 g@78@01) (not (Set_in n$2@95@01 g@78@01)))
    (=>
      (and
        (Set_in n$2@95@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))
      (and
        (Set_in n$2@95@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01)))
    (or
      (not
        (and
          (Set_in n$2@95@01 g@78@01)
          (not
            (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null))))
      (and
        (Set_in n$2@95@01 g@78@01)
        (not
          (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))))
  :pattern ((Set_in n$2@95@01 g@78@01) ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@310@13@310@33-aux|)))
(assert (forall ((n$2@95@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@95@01 g@78@01)
      (not (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) g@78@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) g@78@01))
  :pattern ((Set_in n$2@95@01 g@78@01) ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n$2@95@01) n$2@95@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@310@13@310@33|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))
  $Snap.unit))
; [eval] x.next == null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
    :qid |qp.fvfValDef55|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@94@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
    :qid |qp.fvfValDef56|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@94@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef57|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) x@79@01) x@79@01))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    $Perm.Write
    (ite
      (and
        (img@93@01 x@79@01)
        (and
          (Set_in (inv@92@01 x@79@01) g@78@01)
          (not (= (inv@92@01 x@79@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (= ($FVF.lookup_next (as sm@94@01  $FVF<next>) x@79@01) $Ref.null))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))))
  $Snap.unit))
; [eval] old(x.next) == null ==> $$(g) == old($$(g))
; [eval] old(x.next) == null
; [eval] old(x.next)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
    :qid |qp.fvfValDef50|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef51|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef52|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) x@79@01))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    $Perm.Write
    (ite
      (and
        (img@85@01 x@79@01)
        (and
          (Set_in (inv@84@01 x@79@01) g@78@01)
          (not (= (inv@84@01 x@79@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 21 | Lookup(next, sm@86@01, x@79@01) == Null | live]
; [else-branch: 21 | Lookup(next, sm@86@01, x@79@01) != Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 21 | Lookup(next, sm@86@01, x@79@01) == Null]
(assert (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
; [eval] $$(g) == old($$(g))
; [eval] $$(g)
(push) ; 5
(declare-const n@96@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@96@01 g@78@01))
(pop) ; 6
(declare-fun inv@97@01 ($Ref) $Ref)
(declare-fun img@98@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@96@01 $Ref) (n2@96@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@96@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n1@96@01) n1@96@01))
      (and
        (Set_in n2@96@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n2@96@01) n2@96@01))
      (= n1@96@01 n2@96@01))
    (= n1@96@01 n2@96@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@96@01 $Ref)) (!
  (=>
    (Set_in n@96@01 g@78@01)
    (and (= (inv@97@01 n@96@01) n@96@01) (img@98@01 n@96@01)))
  :pattern ((Set_in n@96@01 g@78@01))
  :pattern ((inv@97@01 n@96@01))
  :pattern ((img@98@01 n@96@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@98@01 r) (Set_in (inv@97@01 r) g@78@01)) (= (inv@97@01 r) r))
  :pattern ((inv@97@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@97@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
  :pattern ((inv@97@01 r))
  :qid |quant-u-176|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@99@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r) (= r (inv@97@01 r)))
    ($Perm.min
      (ite
        (and
          (img@93@01 r)
          (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@100@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r) (= r (inv@97@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@99@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@93@01 r)
          (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@99@01 r))
    $Perm.No)
  
  :qid |quant-u-178|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r) (= r (inv@97@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@99@01 r)) $Perm.No))
  
  :qid |quant-u-179|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@100@01 x@79@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@100@01 r) $Perm.No)
  
  :qid |quant-u-181|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r) (= r (inv@97@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@99@01 r)) (pTaken@100@01 r))
      $Perm.No))
  
  :qid |quant-u-182|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@101@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>)))
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r)))
    (=>
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r))
      (Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>))))
  :qid |qp.fvfDomDef61|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@101@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@101@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef60|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@101@01  $FVF<next>)) g@78@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@96@01 $Ref)) (!
  (=>
    (Set_in n@96@01 g@78@01)
    (and (= (inv@97@01 n@96@01) n@96@01) (img@98@01 n@96@01)))
  :pattern ((Set_in n@96@01 g@78@01))
  :pattern ((inv@97@01 n@96@01))
  :pattern ((img@98@01 n@96@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@98@01 r) (Set_in (inv@97@01 r) g@78@01)) (= (inv@97@01 r) r))
  :pattern ((inv@97@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>)))
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r)))
    (=>
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r))
      (Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>))))
  :qid |qp.fvfDomDef61|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@101@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@101@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@97@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
    :pattern ((inv@97@01 r))
    :qid |quant-u-176|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@101@01  $FVF<next>)) g@78@01)))
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 5
(declare-const n@102@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@102@01 g@78@01))
(pop) ; 6
(declare-fun inv@103@01 ($Ref) $Ref)
(declare-fun img@104@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@102@01 $Ref) (n2@102@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@102@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n1@102@01) n1@102@01))
      (and
        (Set_in n2@102@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n2@102@01) n2@102@01))
      (= n1@102@01 n2@102@01))
    (= n1@102@01 n2@102@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@102@01 $Ref)) (!
  (=>
    (Set_in n@102@01 g@78@01)
    (and (= (inv@103@01 n@102@01) n@102@01) (img@104@01 n@102@01)))
  :pattern ((Set_in n@102@01 g@78@01))
  :pattern ((inv@103@01 n@102@01))
  :pattern ((img@104@01 n@102@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@104@01 r) (Set_in (inv@103@01 r) g@78@01)) (= (inv@103@01 r) r))
  :pattern ((inv@103@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@103@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
  :pattern ((inv@103@01 r))
  :qid |quant-u-184|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@105@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r) (= r (inv@103@01 r)))
    ($Perm.min
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@106@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r) (= r (inv@103@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@105@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@105@01 r))
    $Perm.No)
  
  :qid |quant-u-186|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r) (= r (inv@103@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@105@01 r)) $Perm.No))
  
  :qid |quant-u-187|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@106@01 x@79@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@106@01 r) $Perm.No)
  
  :qid |quant-u-189|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r) (= r (inv@103@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@105@01 r)) (pTaken@106@01 r))
      $Perm.No))
  
  :qid |quant-u-190|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@107@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>)))
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r)))
    (=>
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r))
      (Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@107@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@107@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@107@01  $FVF<next>)) g@78@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@102@01 $Ref)) (!
  (=>
    (Set_in n@102@01 g@78@01)
    (and (= (inv@103@01 n@102@01) n@102@01) (img@104@01 n@102@01)))
  :pattern ((Set_in n@102@01 g@78@01))
  :pattern ((inv@103@01 n@102@01))
  :pattern ((img@104@01 n@102@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@104@01 r) (Set_in (inv@103@01 r) g@78@01)) (= (inv@103@01 r) r))
  :pattern ((inv@103@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>)))
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r)))
    (=>
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r))
      (Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@107@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@107@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@103@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
    :pattern ((inv@103@01 r))
    :qid |quant-u-184|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@107@01  $FVF<next>)) g@78@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 21 | Lookup(next, sm@86@01, x@79@01) != Null]
(assert (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@96@01 $Ref)) (!
  (=>
    (Set_in n@96@01 g@78@01)
    (and (= (inv@97@01 n@96@01) n@96@01) (img@98@01 n@96@01)))
  :pattern ((Set_in n@96@01 g@78@01))
  :pattern ((inv@97@01 n@96@01))
  :pattern ((img@98@01 n@96@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@98@01 r) (Set_in (inv@97@01 r) g@78@01)) (= (inv@97@01 r) r))
  :pattern ((inv@97@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>)))
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r)))
    (=>
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r))
      (Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@101@01  $FVF<next>))))
  :qid |qp.fvfDomDef61|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@101@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@97@01 r) g@78@01) (img@98@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@101@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@101@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef60|)))
(assert (forall ((n@102@01 $Ref)) (!
  (=>
    (Set_in n@102@01 g@78@01)
    (and (= (inv@103@01 n@102@01) n@102@01) (img@104@01 n@102@01)))
  :pattern ((Set_in n@102@01 g@78@01))
  :pattern ((inv@103@01 n@102@01))
  :pattern ((img@104@01 n@102@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@104@01 r) (Set_in (inv@103@01 r) g@78@01)) (= (inv@103@01 r) r))
  :pattern ((inv@103@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>)))
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r)))
    (=>
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r))
      (Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@107@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@107@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@103@01 r) g@78@01) (img@104@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@107@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@107@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (=>
  (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)
  (and
    (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@97@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
      :pattern ((inv@97@01 r))
      :qid |quant-u-176|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@101@01  $FVF<next>)) g@78@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@103@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
      :pattern ((inv@103@01 r))
      :qid |quant-u-184|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@107@01  $FVF<next>)) g@78@01))))
; Joined path conditions
(assert (or
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
  (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
(assert (=>
  (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)
  (Set_equal ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@101@01  $FVF<next>)) g@78@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@107@01  $FVF<next>)) g@78@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))))
  $Snap.unit))
; [eval] old(x.next) != null ==> (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next))))
; [eval] old(x.next) != null
; [eval] old(x.next)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
    :qid |qp.fvfValDef50|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef51|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef52|))))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    $Perm.Write
    (ite
      (and
        (img@85@01 x@79@01)
        (and
          (Set_in (inv@84@01 x@79@01) g@78@01)
          (not (= (inv@84@01 x@79@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; [then-branch: 22 | Lookup(next, sm@86@01, x@79@01) != Null | live]
; [else-branch: 22 | Lookup(next, sm@86@01, x@79@01) == Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 22 | Lookup(next, sm@86@01, x@79@01) != Null]
(assert (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next))))
(declare-const v1@108@01 $Ref)
(declare-const v2@109@01 $Ref)
(push) ; 5
; [eval] edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next)))
; [eval] edge($$(g), v1, v2)
; [eval] $$(g)
(push) ; 6
(declare-const n@110@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@110@01 g@78@01))
(pop) ; 7
(declare-fun inv@111@01 ($Ref) $Ref)
(declare-fun img@112@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@110@01 $Ref) (n2@110@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@110@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n1@110@01) n1@110@01))
      (and
        (Set_in n2@110@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n2@110@01) n2@110@01))
      (= n1@110@01 n2@110@01))
    (= n1@110@01 n2@110@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@110@01 $Ref)) (!
  (=>
    (Set_in n@110@01 g@78@01)
    (and (= (inv@111@01 n@110@01) n@110@01) (img@112@01 n@110@01)))
  :pattern ((Set_in n@110@01 g@78@01))
  :pattern ((inv@111@01 n@110@01))
  :pattern ((img@112@01 n@110@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@112@01 r) (Set_in (inv@111@01 r) g@78@01)) (= (inv@111@01 r) r))
  :pattern ((inv@111@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@111@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
  :pattern ((inv@111@01 r))
  :qid |quant-u-192|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@113@01 ((r $Ref) (v1@108@01 $Ref) (v2@109@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r) (= r (inv@111@01 r)))
    ($Perm.min
      (ite
        (and
          (img@93@01 r)
          (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@114@01 ((r $Ref) (v1@108@01 $Ref) (v2@109@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r) (= r (inv@111@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@113@01 r v1@108@01 v2@109@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@93@01 r)
          (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@113@01 r v1@108@01 v2@109@01))
    $Perm.No)
  
  :qid |quant-u-194|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r) (= r (inv@111@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@113@01 r v1@108@01 v2@109@01))
      $Perm.No))
  
  :qid |quant-u-195|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@114@01 x@79@01 v1@108@01 v2@109@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@114@01 r v1@108@01 v2@109@01) $Perm.No)
  
  :qid |quant-u-197|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r) (= r (inv@111@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@113@01 r v1@108@01 v2@109@01))
        (pTaken@114@01 r v1@108@01 v2@109@01))
      $Perm.No))
  
  :qid |quant-u-198|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@115@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)))
    (=>
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>))))
  :qid |qp.fvfDomDef69|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef68|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@110@01 $Ref)) (!
  (=>
    (Set_in n@110@01 g@78@01)
    (and (= (inv@111@01 n@110@01) n@110@01) (img@112@01 n@110@01)))
  :pattern ((Set_in n@110@01 g@78@01))
  :pattern ((inv@111@01 n@110@01))
  :pattern ((img@112@01 n@110@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@112@01 r) (Set_in (inv@111@01 r) g@78@01)) (= (inv@111@01 r) r))
  :pattern ((inv@111@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)))
    (=>
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>))))
  :qid |qp.fvfDomDef69|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@111@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
    :pattern ((inv@111@01 r))
    :qid |quant-u-192|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01)))
; [eval] edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next))
; [eval] edge(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 6
(declare-const n@116@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@116@01 g@78@01))
(pop) ; 7
(declare-fun inv@117@01 ($Ref) $Ref)
(declare-fun img@118@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@116@01 $Ref) (n2@116@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@116@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n1@116@01) n1@116@01))
      (and
        (Set_in n2@116@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n2@116@01) n2@116@01))
      (= n1@116@01 n2@116@01))
    (= n1@116@01 n2@116@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@116@01 $Ref)) (!
  (=>
    (Set_in n@116@01 g@78@01)
    (and (= (inv@117@01 n@116@01) n@116@01) (img@118@01 n@116@01)))
  :pattern ((Set_in n@116@01 g@78@01))
  :pattern ((inv@117@01 n@116@01))
  :pattern ((img@118@01 n@116@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@118@01 r) (Set_in (inv@117@01 r) g@78@01)) (= (inv@117@01 r) r))
  :pattern ((inv@117@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@117@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
  :pattern ((inv@117@01 r))
  :qid |quant-u-200|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@119@01 ((r $Ref) (v1@108@01 $Ref) (v2@109@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r) (= r (inv@117@01 r)))
    ($Perm.min
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@120@01 ((r $Ref) (v1@108@01 $Ref) (v2@109@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r) (= r (inv@117@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@119@01 r v1@108@01 v2@109@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@119@01 r v1@108@01 v2@109@01))
    $Perm.No)
  
  :qid |quant-u-202|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r) (= r (inv@117@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@119@01 r v1@108@01 v2@109@01))
      $Perm.No))
  
  :qid |quant-u-203|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@120@01 x@79@01 v1@108@01 v2@109@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@120@01 r v1@108@01 v2@109@01) $Perm.No)
  
  :qid |quant-u-205|))))
(check-sat)
; unknown
(pop) ; 7
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r) (= r (inv@117@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@119@01 r v1@108@01 v2@109@01))
        (pTaken@120@01 r v1@108@01 v2@109@01))
      $Perm.No))
  
  :qid |quant-u-206|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@121@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)))
    (=>
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>))))
  :qid |qp.fvfDomDef73|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@116@01 $Ref)) (!
  (=>
    (Set_in n@116@01 g@78@01)
    (and (= (inv@117@01 n@116@01) n@116@01) (img@118@01 n@116@01)))
  :pattern ((Set_in n@116@01 g@78@01))
  :pattern ((inv@117@01 n@116@01))
  :pattern ((img@118@01 n@116@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@118@01 r) (Set_in (inv@117@01 r) g@78@01)) (= (inv@117@01 r) r))
  :pattern ((inv@117@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)))
    (=>
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>))))
  :qid |qp.fvfDomDef73|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@117@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
    :pattern ((inv@117@01 r))
    :qid |quant-u-200|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01)))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 23 | !(edge[Bool]($$(sm@121@01, g@78@01), v1@108@01, v2@109@01)) | live]
; [else-branch: 23 | edge[Bool]($$(sm@121@01, g@78@01), v1@108@01, v2@109@01) | live]
(push) ; 7
; [then-branch: 23 | !(edge[Bool]($$(sm@121@01, g@78@01), v1@108@01, v2@109@01))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 23 | edge[Bool]($$(sm@121@01, g@78@01), v1@108@01, v2@109@01)]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))
; [eval] !(v1 == x && v2 == old(x.next))
; [eval] v1 == x && v2 == old(x.next)
; [eval] v1 == x
(push) ; 8
; [then-branch: 24 | v1@108@01 != x@79@01 | live]
; [else-branch: 24 | v1@108@01 == x@79@01 | live]
(push) ; 9
; [then-branch: 24 | v1@108@01 != x@79@01]
(assert (not (= v1@108@01 x@79@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 24 | v1@108@01 == x@79@01]
(assert (= v1@108@01 x@79@01))
; [eval] v2 == old(x.next)
; [eval] old(x.next)
(declare-const sm@122@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
(declare-const pm@123@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@123@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) x@79@01) x@79@01))
(push) ; 10
(assert (not (< $Perm.No ($FVF.perm_next (as pm@123@01  $FPM) x@79@01))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@123@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
(assert (=>
  (= v1@108@01 x@79@01)
  (and
    (= v1@108@01 x@79@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) x@79@01) x@79@01))))
(assert (or (= v1@108@01 x@79@01) (not (= v1@108@01 x@79@01))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@123@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
(assert (=>
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
    (=>
      (= v1@108@01 x@79@01)
      (and
        (= v1@108@01 x@79@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) x@79@01) x@79@01)))
    (or (= v1@108@01 x@79@01) (not (= v1@108@01 x@79@01))))))
(assert (or
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@110@01 $Ref)) (!
  (=>
    (Set_in n@110@01 g@78@01)
    (and (= (inv@111@01 n@110@01) n@110@01) (img@112@01 n@110@01)))
  :pattern ((Set_in n@110@01 g@78@01))
  :pattern ((inv@111@01 n@110@01))
  :pattern ((img@112@01 n@110@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@112@01 r) (Set_in (inv@111@01 r) g@78@01)) (= (inv@111@01 r) r))
  :pattern ((inv@111@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)))
    (=>
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>))))
  :qid |qp.fvfDomDef69|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((n@116@01 $Ref)) (!
  (=>
    (Set_in n@116@01 g@78@01)
    (and (= (inv@117@01 n@116@01) n@116@01) (img@118@01 n@116@01)))
  :pattern ((Set_in n@116@01 g@78@01))
  :pattern ((inv@117@01 n@116@01))
  :pattern ((img@118@01 n@116@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@118@01 r) (Set_in (inv@117@01 r) g@78@01)) (= (inv@117@01 r) r))
  :pattern ((inv@117@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)))
    (=>
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>))))
  :qid |qp.fvfDomDef73|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@123@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@111@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
  :pattern ((inv@111@01 r))
  :qid |quant-u-192|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@117@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
  :pattern ((inv@117@01 r))
  :qid |quant-u-200|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@108@01 $Ref) (v2@109@01 $Ref)) (!
  (and
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
        (=>
          (= v1@108@01 x@79@01)
          (and
            (= v1@108@01 x@79@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) x@79@01) x@79@01)))
        (or (= v1@108@01 x@79@01) (not (= v1@108@01 x@79@01)))))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@313@37@315@89-aux|)))
(pop) ; 4
(push) ; 4
; [else-branch: 22 | Lookup(next, sm@86@01, x@79@01) == Null]
(assert (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@110@01 $Ref)) (!
  (=>
    (Set_in n@110@01 g@78@01)
    (and (= (inv@111@01 n@110@01) n@110@01) (img@112@01 n@110@01)))
  :pattern ((Set_in n@110@01 g@78@01))
  :pattern ((inv@111@01 n@110@01))
  :pattern ((img@112@01 n@110@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@112@01 r) (Set_in (inv@111@01 r) g@78@01)) (= (inv@111@01 r) r))
  :pattern ((inv@111@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)))
    (=>
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@115@01  $FVF<next>))))
  :qid |qp.fvfDomDef69|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@111@01 r) g@78@01) (img@112@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@115@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@115@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((n@116@01 $Ref)) (!
  (=>
    (Set_in n@116@01 g@78@01)
    (and (= (inv@117@01 n@116@01) n@116@01) (img@118@01 n@116@01)))
  :pattern ((Set_in n@116@01 g@78@01))
  :pattern ((inv@117@01 n@116@01))
  :pattern ((img@118@01 n@116@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@118@01 r) (Set_in (inv@117@01 r) g@78@01)) (= (inv@117@01 r) r))
  :pattern ((inv@117@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)))
    (=>
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@121@01  $FVF<next>))))
  :qid |qp.fvfDomDef73|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@117@01 r) g@78@01) (img@118@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@121@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@121@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@122@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@122@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef76|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@123@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@123@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
(assert (=>
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
  (and
    (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@111@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
      :pattern ((inv@111@01 r))
      :qid |quant-u-192|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@117@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
      :pattern ((inv@117@01 r))
      :qid |quant-u-200|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01)
    (forall ((v1@108@01 $Ref) (v2@109@01 $Ref)) (!
      (and
        (=>
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
          (and
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
            (=>
              (= v1@108@01 x@79@01)
              (and
                (= v1@108@01 x@79@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@122@01  $FVF<next>) x@79@01) x@79@01)))
            (or (= v1@108@01 x@79@01) (not (= v1@108@01 x@79@01)))))
        (or
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))))
      :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@313@37@315@89-aux|)))))
; Joined path conditions
(assert (or
  (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))))
(assert (=>
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
  (forall ((v1@108@01 $Ref) (v2@109@01 $Ref)) (!
    (=
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@121@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01)
        (not
          (and
            (= v1@108@01 x@79@01)
            (= v2@109@01 ($FVF.lookup_next (as sm@122@01  $FVF<next>) x@79@01))))))
    :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@115@01  $FVF<next>)) g@78@01) v1@108@01 v2@109@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@313@37@315@89|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@88@01))))))))
  $Snap.unit))
; [eval] old(x.next) != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))))
; [eval] old(x.next) != null
; [eval] old(x.next)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (= r x@79@01)
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
    :qid |qp.fvfValDef50|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
      (=
        ($FVF.lookup_next (as sm@86@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef51|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@86@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef52|))))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    $Perm.Write
    (ite
      (and
        (img@85@01 x@79@01)
        (and
          (Set_in (inv@84@01 x@79@01) g@78@01)
          (not (= (inv@84@01 x@79@01) x@79@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0,02s
; (get-info :all-statistics)
; [then-branch: 25 | Lookup(next, sm@86@01, x@79@01) != Null | live]
; [else-branch: 25 | Lookup(next, sm@86@01, x@79@01) == Null | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 25 | Lookup(next, sm@86@01, x@79@01) != Null]
(assert (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))))
(declare-const v1@124@01 $Ref)
(declare-const v2@125@01 $Ref)
(push) ; 5
; [eval] v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2)))
; [eval] v1 != v2
(push) ; 6
; [then-branch: 26 | v1@124@01 != v2@125@01 | live]
; [else-branch: 26 | v1@124@01 == v2@125@01 | live]
(push) ; 7
; [then-branch: 26 | v1@124@01 != v2@125@01]
(assert (not (= v1@124@01 v2@125@01)))
; [eval] exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2)))
; [eval] exists_path($$(g), v1, v2)
; [eval] $$(g)
(push) ; 8
(declare-const n@126@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@126@01 g@78@01))
(pop) ; 9
(declare-fun inv@127@01 ($Ref) $Ref)
(declare-fun img@128@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@126@01 $Ref) (n2@126@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@126@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n1@126@01) n1@126@01))
      (and
        (Set_in n2@126@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) n2@126@01) n2@126@01))
      (= n1@126@01 n2@126@01))
    (= n1@126@01 n2@126@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@126@01 $Ref)) (!
  (=>
    (Set_in n@126@01 g@78@01)
    (and (= (inv@127@01 n@126@01) n@126@01) (img@128@01 n@126@01)))
  :pattern ((Set_in n@126@01 g@78@01))
  :pattern ((inv@127@01 n@126@01))
  :pattern ((img@128@01 n@126@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@128@01 r) (Set_in (inv@127@01 r) g@78@01)) (= (inv@127@01 r) r))
  :pattern ((inv@127@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@127@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
  :pattern ((inv@127@01 r))
  :qid |quant-u-208|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@129@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r) (= r (inv@127@01 r)))
    ($Perm.min
      (ite
        (and
          (img@93@01 r)
          (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@130@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r) (= r (inv@127@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@129@01 r v1@124@01 v2@125@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@93@01 r)
          (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@129@01 r v1@124@01 v2@125@01))
    $Perm.No)
  
  :qid |quant-u-210|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r) (= r (inv@127@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@129@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-211|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@130@01 x@79@01 v1@124@01 v2@125@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@130@01 r v1@124@01 v2@125@01) $Perm.No)
  
  :qid |quant-u-213|))))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r) (= r (inv@127@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@129@01 r v1@124@01 v2@125@01))
        (pTaken@130@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-214|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@131@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)))
    (=>
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>))))
  :qid |qp.fvfDomDef82|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@126@01 $Ref)) (!
  (=>
    (Set_in n@126@01 g@78@01)
    (and (= (inv@127@01 n@126@01) n@126@01) (img@128@01 n@126@01)))
  :pattern ((Set_in n@126@01 g@78@01))
  :pattern ((inv@127@01 n@126@01))
  :pattern ((img@128@01 n@126@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@128@01 r) (Set_in (inv@127@01 r) g@78@01)) (= (inv@127@01 r) r))
  :pattern ((inv@127@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)))
    (=>
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>))))
  :qid |qp.fvfDomDef82|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@127@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
    :pattern ((inv@127@01 r))
    :qid |quant-u-208|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01)))
; [eval] exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))
; [eval] exists_path(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 8
(declare-const n@132@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@132@01 g@78@01))
(pop) ; 9
(declare-fun inv@133@01 ($Ref) $Ref)
(declare-fun img@134@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@132@01 $Ref) (n2@132@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@132@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n1@132@01) n1@132@01))
      (and
        (Set_in n2@132@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) n2@132@01) n2@132@01))
      (= n1@132@01 n2@132@01))
    (= n1@132@01 n2@132@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@132@01 $Ref)) (!
  (=>
    (Set_in n@132@01 g@78@01)
    (and (= (inv@133@01 n@132@01) n@132@01) (img@134@01 n@132@01)))
  :pattern ((Set_in n@132@01 g@78@01))
  :pattern ((inv@133@01 n@132@01))
  :pattern ((img@134@01 n@132@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@134@01 r) (Set_in (inv@133@01 r) g@78@01)) (= (inv@133@01 r) r))
  :pattern ((inv@133@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@133@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
  :pattern ((inv@133@01 r))
  :qid |quant-u-216|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@135@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r) (= r (inv@133@01 r)))
    ($Perm.min
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@136@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r) (= r (inv@133@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@135@01 r v1@124@01 v2@125@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@135@01 r v1@124@01 v2@125@01))
    $Perm.No)
  
  :qid |quant-u-218|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r) (= r (inv@133@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@135@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-219|))))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@136@01 x@79@01 v1@124@01 v2@125@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@136@01 r v1@124@01 v2@125@01) $Perm.No)
  
  :qid |quant-u-221|))))
(check-sat)
; unknown
(pop) ; 9
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r) (= r (inv@133@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@135@01 r v1@124@01 v2@125@01))
        (pTaken@136@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-222|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@137@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)))
    (=>
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>))))
  :qid |qp.fvfDomDef86|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@132@01 $Ref)) (!
  (=>
    (Set_in n@132@01 g@78@01)
    (and (= (inv@133@01 n@132@01) n@132@01) (img@134@01 n@132@01)))
  :pattern ((Set_in n@132@01 g@78@01))
  :pattern ((inv@133@01 n@132@01))
  :pattern ((img@134@01 n@132@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@134@01 r) (Set_in (inv@133@01 r) g@78@01)) (= (inv@133@01 r) r))
  :pattern ((inv@133@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)))
    (=>
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>))))
  :qid |qp.fvfDomDef86|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@133@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
    :pattern ((inv@133@01 r))
    :qid |quant-u-216|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01)))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 27 | !(exists_path[Bool]($$(sm@137@01, g@78@01), v1@124@01, v2@125@01)) | live]
; [else-branch: 27 | exists_path[Bool]($$(sm@137@01, g@78@01), v1@124@01, v2@125@01) | live]
(push) ; 9
; [then-branch: 27 | !(exists_path[Bool]($$(sm@137@01, g@78@01), v1@124@01, v2@125@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 27 | exists_path[Bool]($$(sm@137@01, g@78@01), v1@124@01, v2@125@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01))
; [eval] !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))
; [eval] exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2)
; [eval] exists_path(old($$(g)), v1, x)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 10
(declare-const n@138@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@138@01 g@78@01))
(pop) ; 11
(declare-fun inv@139@01 ($Ref) $Ref)
(declare-fun img@140@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@141@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef89|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@138@01 $Ref) (n2@138@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@138@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) n1@138@01) n1@138@01))
      (and
        (Set_in n2@138@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) n2@138@01) n2@138@01))
      (= n1@138@01 n2@138@01))
    (= n1@138@01 n2@138@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@138@01 $Ref)) (!
  (=>
    (Set_in n@138@01 g@78@01)
    (and (= (inv@139@01 n@138@01) n@138@01) (img@140@01 n@138@01)))
  :pattern ((Set_in n@138@01 g@78@01))
  :pattern ((inv@139@01 n@138@01))
  :pattern ((img@140@01 n@138@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@140@01 r) (Set_in (inv@139@01 r) g@78@01)) (= (inv@139@01 r) r))
  :pattern ((inv@139@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@139@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) r) r))
  :pattern ((inv@139@01 r))
  :qid |quant-u-224|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@142@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r) (= r (inv@139@01 r)))
    ($Perm.min
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@143@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r) (= r (inv@139@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@142@01 r v1@124@01 v2@125@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@142@01 r v1@124@01 v2@125@01))
    $Perm.No)
  
  :qid |quant-u-226|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r) (= r (inv@139@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@142@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-227|))))
(check-sat)
; unknown
(pop) ; 11
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@143@01 x@79@01 v1@124@01 v2@125@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 11
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@143@01 r v1@124@01 v2@125@01) $Perm.No)
  
  :qid |quant-u-229|))))
(check-sat)
; unknown
(pop) ; 11
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r) (= r (inv@139@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@142@01 r v1@124@01 v2@125@01))
        (pTaken@143@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-230|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@144@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)))
    (=>
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>))))
  :qid |qp.fvfDomDef93|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((n@138@01 $Ref)) (!
  (=>
    (Set_in n@138@01 g@78@01)
    (and (= (inv@139@01 n@138@01) n@138@01) (img@140@01 n@138@01)))
  :pattern ((Set_in n@138@01 g@78@01))
  :pattern ((inv@139@01 n@138@01))
  :pattern ((img@140@01 n@138@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@140@01 r) (Set_in (inv@139@01 r) g@78@01)) (= (inv@139@01 r) r))
  :pattern ((inv@139@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)))
    (=>
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>))))
  :qid |qp.fvfDomDef93|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@139@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) r) r))
    :pattern ((inv@139@01 r))
    :qid |quant-u-224|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01)))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 28 | !(exists_path[Bool]($$(sm@144@01, g@78@01), v1@124@01, x@79@01)) | live]
; [else-branch: 28 | exists_path[Bool]($$(sm@144@01, g@78@01), v1@124@01, x@79@01) | live]
(push) ; 11
; [then-branch: 28 | !(exists_path[Bool]($$(sm@144@01, g@78@01), v1@124@01, x@79@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)))
(pop) ; 11
(push) ; 11
; [else-branch: 28 | exists_path[Bool]($$(sm@144@01, g@78@01), v1@124@01, x@79@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01))
; [eval] exists_path(old($$(g)), old(x.next), v2)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 12
(declare-const n@145@01 $Ref)
(push) ; 13
; [eval] (n in refs)
(assert (Set_in n@145@01 g@78@01))
(pop) ; 13
(declare-fun inv@146@01 ($Ref) $Ref)
(declare-fun img@147@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@148@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((n1@145@01 $Ref) (n2@145@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@145@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) n1@145@01) n1@145@01))
      (and
        (Set_in n2@145@01 g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) n2@145@01) n2@145@01))
      (= n1@145@01 n2@145@01))
    (= n1@145@01 n2@145@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@146@01 r) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
  :pattern ((inv@146@01 r))
  :qid |quant-u-232|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@149@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r) (= r (inv@146@01 r)))
    ($Perm.min
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@150@01 ((r $Ref) (v1@124@01 $Ref) (v2@125@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r) (= r (inv@146@01 r)))
    ($Perm.min
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@149@01 r v1@124@01 v2@125@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@149@01 r v1@124@01 v2@125@01))
    $Perm.No)
  
  :qid |quant-u-234|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r) (= r (inv@146@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@149@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-235|))))
(check-sat)
; unknown
(pop) ; 13
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@150@01 x@79@01 v1@124@01 v2@125@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 13
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@150@01 r v1@124@01 v2@125@01) $Perm.No)
  
  :qid |quant-u-237|))))
(check-sat)
; unknown
(pop) ; 13
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r) (= r (inv@146@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@149@01 r v1@124@01 v2@125@01))
        (pTaken@150@01 r v1@124@01 v2@125@01))
      $Perm.No))
  
  :qid |quant-u-238|))))
(check-sat)
; unsat
(pop) ; 13
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@151@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01))
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@146@01 r) g@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
    :pattern ((inv@146@01 r))
    :qid |quant-u-232|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01)))
; [eval] old(x.next)
(declare-const sm@152@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef103|)))
(declare-const pm@153@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@153@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) x@79@01))
(set-option :timeout 0)
(push) ; 12
(assert (not (< $Perm.No ($FVF.perm_next (as pm@153@01  $FPM) x@79@01))))
(check-sat)
; unsat
(pop) ; 12
; 0,00s
; (get-info :all-statistics)
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@153@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@146@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
      :pattern ((inv@146@01 r))
      :qid |quant-u-232|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) x@79@01))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((n@138@01 $Ref)) (!
  (=>
    (Set_in n@138@01 g@78@01)
    (and (= (inv@139@01 n@138@01) n@138@01) (img@140@01 n@138@01)))
  :pattern ((Set_in n@138@01 g@78@01))
  :pattern ((inv@139@01 n@138@01))
  :pattern ((img@140@01 n@138@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@140@01 r) (Set_in (inv@139@01 r) g@78@01)) (= (inv@139@01 r) r))
  :pattern ((inv@139@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)))
    (=>
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>))))
  :qid |qp.fvfDomDef93|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@153@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@139@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) r) r))
      :pattern ((inv@139@01 r))
      :qid |quant-u-224|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@146@01 r) g@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
          :pattern ((inv@146@01 r))
          :qid |quant-u-232|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) x@79@01)))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01))))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01))))
(pop) ; 7
(push) ; 7
; [else-branch: 26 | v1@124@01 == v2@125@01]
(assert (= v1@124@01 v2@125@01))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((n@126@01 $Ref)) (!
  (=>
    (Set_in n@126@01 g@78@01)
    (and (= (inv@127@01 n@126@01) n@126@01) (img@128@01 n@126@01)))
  :pattern ((Set_in n@126@01 g@78@01))
  :pattern ((inv@127@01 n@126@01))
  :pattern ((img@128@01 n@126@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@128@01 r) (Set_in (inv@127@01 r) g@78@01)) (= (inv@127@01 r) r))
  :pattern ((inv@127@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)))
    (=>
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>))))
  :qid |qp.fvfDomDef82|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert (forall ((n@132@01 $Ref)) (!
  (=>
    (Set_in n@132@01 g@78@01)
    (and (= (inv@133@01 n@132@01) n@132@01) (img@134@01 n@132@01)))
  :pattern ((Set_in n@132@01 g@78@01))
  :pattern ((inv@133@01 n@132@01))
  :pattern ((img@134@01 n@132@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@134@01 r) (Set_in (inv@133@01 r) g@78@01)) (= (inv@133@01 r) r))
  :pattern ((inv@133@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)))
    (=>
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>))))
  :qid |qp.fvfDomDef86|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((n@138@01 $Ref)) (!
  (=>
    (Set_in n@138@01 g@78@01)
    (and (= (inv@139@01 n@138@01) n@138@01) (img@140@01 n@138@01)))
  :pattern ((Set_in n@138@01 g@78@01))
  :pattern ((inv@139@01 n@138@01))
  :pattern ((img@140@01 n@138@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@140@01 r) (Set_in (inv@139@01 r) g@78@01)) (= (inv@139@01 r) r))
  :pattern ((inv@139@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)))
    (=>
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>))))
  :qid |qp.fvfDomDef93|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@153@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (=>
  (not (= v1@124@01 v2@125@01))
  (and
    (not (= v1@124@01 v2@125@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@127@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
      :pattern ((inv@127@01 r))
      :qid |quant-u-208|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@133@01 r) g@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
      :pattern ((inv@133@01 r))
      :qid |quant-u-216|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01)
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@139@01 r) g@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) r) r))
          :pattern ((inv@139@01 r))
          :qid |quant-u-224|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@146@01 r) g@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
              :pattern ((inv@146@01 r))
              :qid |quant-u-232|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) x@79@01)))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)))))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01))))))
; Joined path conditions
(assert (or (= v1@124@01 v2@125@01) (not (= v1@124@01 v2@125@01))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@126@01 $Ref)) (!
  (=>
    (Set_in n@126@01 g@78@01)
    (and (= (inv@127@01 n@126@01) n@126@01) (img@128@01 n@126@01)))
  :pattern ((Set_in n@126@01 g@78@01))
  :pattern ((inv@127@01 n@126@01))
  :pattern ((img@128@01 n@126@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@128@01 r) (Set_in (inv@127@01 r) g@78@01)) (= (inv@127@01 r) r))
  :pattern ((inv@127@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)))
    (=>
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>))))
  :qid |qp.fvfDomDef82|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert (forall ((n@132@01 $Ref)) (!
  (=>
    (Set_in n@132@01 g@78@01)
    (and (= (inv@133@01 n@132@01) n@132@01) (img@134@01 n@132@01)))
  :pattern ((Set_in n@132@01 g@78@01))
  :pattern ((inv@133@01 n@132@01))
  :pattern ((img@134@01 n@132@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@134@01 r) (Set_in (inv@133@01 r) g@78@01)) (= (inv@133@01 r) r))
  :pattern ((inv@133@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)))
    (=>
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>))))
  :qid |qp.fvfDomDef86|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((n@138@01 $Ref)) (!
  (=>
    (Set_in n@138@01 g@78@01)
    (and (= (inv@139@01 n@138@01) n@138@01) (img@140@01 n@138@01)))
  :pattern ((Set_in n@138@01 g@78@01))
  :pattern ((inv@139@01 n@138@01))
  :pattern ((img@140@01 n@138@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@140@01 r) (Set_in (inv@139@01 r) g@78@01)) (= (inv@139@01 r) r))
  :pattern ((inv@139@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)))
    (=>
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>))))
  :qid |qp.fvfDomDef93|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@153@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resTrgDef105|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@124@01 $Ref) (v2@125@01 $Ref)) (!
  (and
    (=>
      (not (= v1@124@01 v2@125@01))
      (and
        (not (= v1@124@01 v2@125@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@127@01 r) g@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
          :pattern ((inv@127@01 r))
          :qid |quant-u-208|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@133@01 r) g@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
          :pattern ((inv@133@01 r))
          :qid |quant-u-216|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01)
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@139@01 r) g@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) r) r))
              :pattern ((inv@139@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01)
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@146@01 r) g@78@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
                  :pattern ((inv@146@01 r))
                  :qid |quant-u-232|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) x@79@01)))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)))))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)))))
    (or (= v1@124@01 v2@125@01) (not (= v1@124@01 v2@125@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@316@38@320@128-aux|)))
(pop) ; 4
(push) ; 4
; [else-branch: 25 | Lookup(next, sm@86@01, x@79@01) == Null]
(assert (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@126@01 $Ref)) (!
  (=>
    (Set_in n@126@01 g@78@01)
    (and (= (inv@127@01 n@126@01) n@126@01) (img@128@01 n@126@01)))
  :pattern ((Set_in n@126@01 g@78@01))
  :pattern ((inv@127@01 n@126@01))
  :pattern ((img@128@01 n@126@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@128@01 r) (Set_in (inv@127@01 r) g@78@01)) (= (inv@127@01 r) r))
  :pattern ((inv@127@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)))
    (=>
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@131@01  $FVF<next>))))
  :qid |qp.fvfDomDef82|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@89@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@89@01  $FVF<next>) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@127@01 r) g@78@01) (img@128@01 r))
      (and
        (img@93@01 r)
        (and (Set_in (inv@92@01 r) g@78@01) (not (= (inv@92@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@131@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@89@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@88@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@131@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef81|)))
(assert (forall ((n@132@01 $Ref)) (!
  (=>
    (Set_in n@132@01 g@78@01)
    (and (= (inv@133@01 n@132@01) n@132@01) (img@134@01 n@132@01)))
  :pattern ((Set_in n@132@01 g@78@01))
  :pattern ((inv@133@01 n@132@01))
  :pattern ((img@134@01 n@132@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@134@01 r) (Set_in (inv@133@01 r) g@78@01)) (= (inv@133@01 r) r))
  :pattern ((inv@133@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)))
    (=>
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@137@01  $FVF<next>))))
  :qid |qp.fvfDomDef86|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@133@01 r) g@78@01) (img@134@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@137@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@137@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@141@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@141@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef89|)))
(assert (forall ((n@138@01 $Ref)) (!
  (=>
    (Set_in n@138@01 g@78@01)
    (and (= (inv@139@01 n@138@01) n@138@01) (img@140@01 n@138@01)))
  :pattern ((Set_in n@138@01 g@78@01))
  :pattern ((inv@139@01 n@138@01))
  :pattern ((img@140@01 n@138@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@140@01 r) (Set_in (inv@139@01 r) g@78@01)) (= (inv@139@01 r) r))
  :pattern ((inv@139@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)))
    (=>
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@144@01  $FVF<next>))))
  :qid |qp.fvfDomDef93|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@139@01 r) g@78@01) (img@140@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@148@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@148@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef96|)))
(assert (forall ((n@145@01 $Ref)) (!
  (=>
    (Set_in n@145@01 g@78@01)
    (and (= (inv@146@01 n@145@01) n@145@01) (img@147@01 n@145@01)))
  :pattern ((Set_in n@145@01 g@78@01))
  :pattern ((inv@146@01 n@145@01))
  :pattern ((img@147@01 n@145@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@147@01 r) (Set_in (inv@146@01 r) g@78@01)) (= (inv@146@01 r) r))
  :pattern ((inv@146@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)))
    (=>
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@151@01  $FVF<next>))))
  :qid |qp.fvfDomDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r)) (= r x@79@01))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@146@01 r) g@78@01) (img@147@01 r))
      (and
        (img@85@01 r)
        (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01)))))
    (=
      ($FVF.lookup_next (as sm@151@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@151@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x@79@01)
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@81@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@81@01  $FVF<next>) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@85@01 r)
      (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
    (=
      ($FVF.lookup_next (as sm@152@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@152@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@153@01  $FPM) r)
    (+
      (ite (= r x@79@01) $Perm.Write $Perm.No)
      (ite
        (and
          (img@85@01 r)
          (and (Set_in (inv@84@01 r) g@78@01) (not (= (inv@84@01 r) x@79@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@81@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@153@01  $FPM) r))
  :qid |qp.resTrgDef105|)))
(assert (=>
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
  (and
    (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
    (forall ((v1@124@01 $Ref) (v2@125@01 $Ref)) (!
      (and
        (=>
          (not (= v1@124@01 v2@125@01))
          (and
            (not (= v1@124@01 v2@125@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@127@01 r) g@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@94@01  $FVF<next>) r) r))
              :pattern ((inv@127@01 r))
              :qid |quant-u-208|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@133@01 r) g@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@86@01  $FVF<next>) r) r))
              :pattern ((inv@133@01 r))
              :qid |quant-u-216|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01)
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@139@01 r) g@78@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@141@01  $FVF<next>) r) r))
                  :pattern ((inv@139@01 r))
                  :qid |quant-u-224|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01)
                (=>
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
                  (and
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
                    (forall ((r $Ref)) (!
                      (=>
                        (Set_in (inv@146@01 r) g@78@01)
                        ($FVF.loc_next ($FVF.lookup_next (as sm@148@01  $FVF<next>) r) r))
                      :pattern ((inv@146@01 r))
                      :qid |quant-u-232|))
                    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01)
                    ($FVF.loc_next ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) x@79@01)))
                (or
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
                  (not
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)))))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)))))
        (or (= v1@124@01 v2@125@01) (not (= v1@124@01 v2@125@01))))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@316@38@320@128-aux|)))))
; Joined path conditions
(assert (=>
  (not (= ($FVF.lookup_next (as sm@86@01  $FVF<next>) x@79@01) $Ref.null))
  (forall ((v1@124@01 $Ref) (v2@125@01 $Ref)) (!
    (=>
      (not (= v1@124@01 v2@125@01))
      (=
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
        (and
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@137@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01)
          (not
            (and
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@144@01  $FVF<next>)) g@78@01) v1@124@01 x@79@01)
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@151@01  $FVF<next>)) g@78@01) ($FVF.lookup_next (as sm@152@01  $FVF<next>) x@79@01) v2@125@01))))))
    :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@131@01  $FVF<next>)) g@78@01) v1@124@01 v2@125@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@316@38@320@128|))))
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- unjoin ----------
(declare-const g0@154@01 Set<$Ref>)
(declare-const g1@155@01 Set<$Ref>)
(declare-const x0@156@01 $Ref)
(declare-const x1@157@01 $Ref)
(declare-const g0@158@01 Set<$Ref>)
(declare-const g1@159@01 Set<$Ref>)
(declare-const x0@160@01 $Ref)
(declare-const x1@161@01 $Ref)
(push) ; 1
(declare-const $t@162@01 $Snap)
(assert (= $t@162@01 ($Snap.combine ($Snap.first $t@162@01) ($Snap.second $t@162@01))))
(assert (= ($Snap.first $t@162@01) $Snap.unit))
; [eval] (forall r: Ref :: { (r in g0), (r in g1) } (r in g0) ==> !((r in g1)))
(declare-const r@163@01 $Ref)
(push) ; 2
; [eval] (r in g0) ==> !((r in g1))
; [eval] (r in g0)
(push) ; 3
; [then-branch: 29 | r@163@01 in g0@158@01 | live]
; [else-branch: 29 | !(r@163@01 in g0@158@01) | live]
(push) ; 4
; [then-branch: 29 | r@163@01 in g0@158@01]
(assert (Set_in r@163@01 g0@158@01))
; [eval] !((r in g1))
; [eval] (r in g1)
(pop) ; 4
(push) ; 4
; [else-branch: 29 | !(r@163@01 in g0@158@01)]
(assert (not (Set_in r@163@01 g0@158@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r@163@01 g0@158@01)) (Set_in r@163@01 g0@158@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r@163@01 $Ref)) (!
  (or (not (Set_in r@163@01 g0@158@01)) (Set_in r@163@01 g0@158@01))
  :pattern ((Set_in r@163@01 g0@158@01) (Set_in r@163@01 g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@324@14@324@34-aux|)))
(assert (forall ((r@163@01 $Ref)) (!
  (=> (Set_in r@163@01 g0@158@01) (not (Set_in r@163@01 g1@159@01)))
  :pattern ((Set_in r@163@01 g0@158@01) (Set_in r@163@01 g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@324@14@324@34|)))
(assert (=
  ($Snap.second $t@162@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@162@01))
    ($Snap.second ($Snap.second $t@162@01)))))
(assert (= ($Snap.first ($Snap.second $t@162@01)) $Snap.unit))
; [eval] (forall r$0: Ref :: { (r$0 in g0), (r$0 in g1) } (r$0 in g1) ==> !((r$0 in g0)))
(declare-const r$0@164@01 $Ref)
(push) ; 2
; [eval] (r$0 in g1) ==> !((r$0 in g0))
; [eval] (r$0 in g1)
(push) ; 3
; [then-branch: 30 | r$0@164@01 in g1@159@01 | live]
; [else-branch: 30 | !(r$0@164@01 in g1@159@01) | live]
(push) ; 4
; [then-branch: 30 | r$0@164@01 in g1@159@01]
(assert (Set_in r$0@164@01 g1@159@01))
; [eval] !((r$0 in g0))
; [eval] (r$0 in g0)
(pop) ; 4
(push) ; 4
; [else-branch: 30 | !(r$0@164@01 in g1@159@01)]
(assert (not (Set_in r$0@164@01 g1@159@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r$0@164@01 g1@159@01)) (Set_in r$0@164@01 g1@159@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r$0@164@01 $Ref)) (!
  (or (not (Set_in r$0@164@01 g1@159@01)) (Set_in r$0@164@01 g1@159@01))
  :pattern ((Set_in r$0@164@01 g0@158@01) (Set_in r$0@164@01 g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@324@14@324@34-aux|)))
(assert (forall ((r$0@164@01 $Ref)) (!
  (=> (Set_in r$0@164@01 g1@159@01) (not (Set_in r$0@164@01 g0@158@01)))
  :pattern ((Set_in r$0@164@01 g0@158@01) (Set_in r$0@164@01 g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@324@14@324@34|)))
(assert (=
  ($Snap.second ($Snap.second $t@162@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@162@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@162@01))) $Snap.unit))
; [eval] !((null in (g0 union g1)))
; [eval] (null in (g0 union g1))
; [eval] (g0 union g1)
(assert (not (Set_in $Ref.null (Set_union g0@158@01 g1@159@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@162@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))
(declare-const n@165@01 $Ref)
(push) ; 2
; [eval] (n in (g0 union g1))
; [eval] (g0 union g1)
(assert (Set_in n@165@01 (Set_union g0@158@01 g1@159@01)))
(declare-const sm@166@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@167@01 ($Ref) $Ref)
(declare-fun img@168@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@165@01 $Ref) (n2@165@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@165@01 (Set_union g0@158@01 g1@159@01))
      (Set_in n2@165@01 (Set_union g0@158@01 g1@159@01))
      (= n1@165@01 n2@165@01))
    (= n1@165@01 n2@165@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@165@01 $Ref)) (!
  (=>
    (Set_in n@165@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@167@01 n@165@01) n@165@01) (img@168@01 n@165@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) n@165@01) n@165@01))
  :qid |quant-u-240|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@167@01 r) r))
  :pattern ((inv@167@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@165@01 $Ref)) (!
  (=>
    (Set_in n@165@01 (Set_union g0@158@01 g1@159@01))
    (not (= n@165@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) n@165@01) n@165@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@169@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@169@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
  :pattern ((inv@167@01 r))
  :qid |quant-u-241|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))
  $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in (g0 union g1)) } { (n$0 in (g0 union g1)), n$0.next } (n$0 in (g0 union g1)) && n$0.next != null ==> (n$0.next in (g0 union g1)))
(declare-const n$0@170@01 $Ref)
(push) ; 2
; [eval] (n$0 in (g0 union g1)) && n$0.next != null ==> (n$0.next in (g0 union g1))
; [eval] (n$0 in (g0 union g1)) && n$0.next != null
; [eval] (n$0 in (g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
; [then-branch: 31 | !(n$0@170@01 in g0@158@01 ∪ g1@159@01) | live]
; [else-branch: 31 | n$0@170@01 in g0@158@01 ∪ g1@159@01 | live]
(push) ; 4
; [then-branch: 31 | !(n$0@170@01 in g0@158@01 ∪ g1@159@01)]
(assert (not (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))))
(pop) ; 4
(push) ; 4
; [else-branch: 31 | n$0@170@01 in g0@158@01 ∪ g1@159@01]
(assert (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01)))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (=
        ($FVF.lookup_next (as sm@169@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef107|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef108|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01))
(push) ; 5
(assert (not (and
  (img@168@01 n$0@170@01)
  (Set_in (inv@167@01 n$0@170@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@169@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (=>
  (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
  (and
    (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01))))
(assert (or
  (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
  (not (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01)))))
(push) ; 3
; [then-branch: 32 | n$0@170@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@169@01, n$0@170@01) != Null | live]
; [else-branch: 32 | !(n$0@170@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@169@01, n$0@170@01) != Null) | live]
(push) ; 4
; [then-branch: 32 | n$0@170@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@169@01, n$0@170@01) != Null]
(assert (and
  (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
  (not (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null))))
; [eval] (n$0.next in (g0 union g1))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (=
        ($FVF.lookup_next (as sm@169@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef107|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef108|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01))
(push) ; 5
(assert (not (and
  (img@168@01 n$0@170@01)
  (Set_in (inv@167@01 n$0@170@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; [eval] (g0 union g1)
(pop) ; 4
(push) ; 4
; [else-branch: 32 | !(n$0@170@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@169@01, n$0@170@01) != Null)]
(assert (not
  (and
    (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@169@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (=>
  (and
    (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))
  (and
    (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null))))
  (and
    (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@169@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@169@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@170@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01)))
    (or
      (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))))
    (=>
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01)))
    (or
      (not
        (and
          (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
          (not
            (=
              ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01)
              $Ref.null))))
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) (Set_union g0@158@01 g1@159@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@325@14@325@32-aux|)))
(assert (forall ((n$0@170@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01)))
    (or
      (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))))
    (=>
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01)))
    (or
      (not
        (and
          (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
          (not
            (=
              ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01)
              $Ref.null))))
      (and
        (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))))
  :pattern ((Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@325@14@325@32-aux|)))
(assert (forall ((n$0@170@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in n$0@170@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n$0@170@01) n$0@170@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@325@14@325@32|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))
  $Snap.unit))
; [eval] (x0 in g0)
(assert (Set_in x0@160@01 g0@158@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))
  $Snap.unit))
; [eval] (x1 in g1)
(assert (Set_in x1@161@01 g1@159@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))
  $Snap.unit))
; [eval] (forall n$1: Ref :: { exists_path($$(g0), n$1, x0) } (n$1 in g0) ==> exists_path($$(g0), n$1, x0))
(declare-const n$1@171@01 $Ref)
(push) ; 2
; [eval] (n$1 in g0) ==> exists_path($$(g0), n$1, x0)
; [eval] (n$1 in g0)
(push) ; 3
; [then-branch: 33 | n$1@171@01 in g0@158@01 | live]
; [else-branch: 33 | !(n$1@171@01 in g0@158@01) | live]
(push) ; 4
; [then-branch: 33 | n$1@171@01 in g0@158@01]
(assert (Set_in n$1@171@01 g0@158@01))
; [eval] exists_path($$(g0), n$1, x0)
; [eval] $$(g0)
(push) ; 5
(declare-const n@172@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@172@01 g0@158@01))
(pop) ; 6
(declare-fun inv@173@01 ($Ref) $Ref)
(declare-fun img@174@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@172@01 $Ref) (n2@172@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@172@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n1@172@01) n1@172@01))
      (and
        (Set_in n2@172@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n2@172@01) n2@172@01))
      (= n1@172@01 n2@172@01))
    (= n1@172@01 n2@172@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@172@01 $Ref)) (!
  (=>
    (Set_in n@172@01 g0@158@01)
    (and (= (inv@173@01 n@172@01) n@172@01) (img@174@01 n@172@01)))
  :pattern ((Set_in n@172@01 g0@158@01))
  :pattern ((inv@173@01 n@172@01))
  :pattern ((img@174@01 n@172@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@174@01 r) (Set_in (inv@173@01 r) g0@158@01))
    (= (inv@173@01 r) r))
  :pattern ((inv@173@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@173@01 r) g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
  :pattern ((inv@173@01 r))
  :qid |quant-u-243|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@175@01 ((r $Ref) (n$1@171@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r) (= r (inv@173@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@175@01 r n$1@171@01))
    $Perm.No)
  
  :qid |quant-u-245|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@175@01 r n$1@171@01) $Perm.No)
  
  :qid |quant-u-246|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r) (= r (inv@173@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@175@01 r n$1@171@01)) $Perm.No))
  
  :qid |quant-u-247|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@176@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r)))
    (=>
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>))))
  :qid |qp.fvfDomDef111|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@176@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef110|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@172@01 $Ref)) (!
  (=>
    (Set_in n@172@01 g0@158@01)
    (and (= (inv@173@01 n@172@01) n@172@01) (img@174@01 n@172@01)))
  :pattern ((Set_in n@172@01 g0@158@01))
  :pattern ((inv@173@01 n@172@01))
  :pattern ((img@174@01 n@172@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@174@01 r) (Set_in (inv@173@01 r) g0@158@01))
    (= (inv@173@01 r) r))
  :pattern ((inv@173@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r)))
    (=>
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>))))
  :qid |qp.fvfDomDef111|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@176@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef110|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@173@01 r) g0@158@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
    :pattern ((inv@173@01 r))
    :qid |quant-u-243|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 33 | !(n$1@171@01 in g0@158@01)]
(assert (not (Set_in n$1@171@01 g0@158@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@172@01 $Ref)) (!
  (=>
    (Set_in n@172@01 g0@158@01)
    (and (= (inv@173@01 n@172@01) n@172@01) (img@174@01 n@172@01)))
  :pattern ((Set_in n@172@01 g0@158@01))
  :pattern ((inv@173@01 n@172@01))
  :pattern ((img@174@01 n@172@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@174@01 r) (Set_in (inv@173@01 r) g0@158@01))
    (= (inv@173@01 r) r))
  :pattern ((inv@173@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r)))
    (=>
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>))))
  :qid |qp.fvfDomDef111|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@176@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef110|)))
(assert (=>
  (Set_in n$1@171@01 g0@158@01)
  (and
    (Set_in n$1@171@01 g0@158@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@173@01 r) g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
      :pattern ((inv@173@01 r))
      :qid |quant-u-243|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01))))
; Joined path conditions
(assert (or (not (Set_in n$1@171@01 g0@158@01)) (Set_in n$1@171@01 g0@158@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@172@01 $Ref)) (!
  (=>
    (Set_in n@172@01 g0@158@01)
    (and (= (inv@173@01 n@172@01) n@172@01) (img@174@01 n@172@01)))
  :pattern ((Set_in n@172@01 g0@158@01))
  :pattern ((inv@173@01 n@172@01))
  :pattern ((img@174@01 n@172@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@174@01 r) (Set_in (inv@173@01 r) g0@158@01))
    (= (inv@173@01 r) r))
  :pattern ((inv@173@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r)))
    (=>
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@176@01  $FVF<next>))))
  :qid |qp.fvfDomDef111|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@173@01 r) g0@158@01) (img@174@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@176@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@176@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef110|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$1@171@01 $Ref)) (!
  (and
    (=>
      (Set_in n$1@171@01 g0@158@01)
      (and
        (Set_in n$1@171@01 g0@158@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@173@01 r) g0@158@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
          :pattern ((inv@173@01 r))
          :qid |quant-u-243|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01)))
    (or (not (Set_in n$1@171@01 g0@158@01)) (Set_in n$1@171@01 g0@158@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01) n$1@171@01 x0@160@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@328@14@328@35-aux|)))
(assert (forall ((n$1@171@01 $Ref)) (!
  (=>
    (Set_in n$1@171@01 g0@158@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01) n$1@171@01 x0@160@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@176@01  $FVF<next>)) g0@158@01) n$1@171@01 x0@160@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@328@14@328@35|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { exists_path($$(g1), x1, n$2) } (n$2 in g1) ==> exists_path($$(g1), x1, n$2))
(declare-const n$2@177@01 $Ref)
(push) ; 2
; [eval] (n$2 in g1) ==> exists_path($$(g1), x1, n$2)
; [eval] (n$2 in g1)
(push) ; 3
; [then-branch: 34 | n$2@177@01 in g1@159@01 | live]
; [else-branch: 34 | !(n$2@177@01 in g1@159@01) | live]
(push) ; 4
; [then-branch: 34 | n$2@177@01 in g1@159@01]
(assert (Set_in n$2@177@01 g1@159@01))
; [eval] exists_path($$(g1), x1, n$2)
; [eval] $$(g1)
(push) ; 5
(declare-const n@178@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@178@01 g1@159@01))
(pop) ; 6
(declare-fun inv@179@01 ($Ref) $Ref)
(declare-fun img@180@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@178@01 $Ref) (n2@178@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@178@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n1@178@01) n1@178@01))
      (and
        (Set_in n2@178@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n2@178@01) n2@178@01))
      (= n1@178@01 n2@178@01))
    (= n1@178@01 n2@178@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@178@01 $Ref)) (!
  (=>
    (Set_in n@178@01 g1@159@01)
    (and (= (inv@179@01 n@178@01) n@178@01) (img@180@01 n@178@01)))
  :pattern ((Set_in n@178@01 g1@159@01))
  :pattern ((inv@179@01 n@178@01))
  :pattern ((img@180@01 n@178@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@180@01 r) (Set_in (inv@179@01 r) g1@159@01))
    (= (inv@179@01 r) r))
  :pattern ((inv@179@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@179@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
  :pattern ((inv@179@01 r))
  :qid |quant-u-249|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@181@01 ((r $Ref) (n$2@177@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r) (= r (inv@179@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@181@01 r n$2@177@01))
    $Perm.No)
  
  :qid |quant-u-251|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@181@01 r n$2@177@01) $Perm.No)
  
  :qid |quant-u-252|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r) (= r (inv@179@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@181@01 r n$2@177@01)) $Perm.No))
  
  :qid |quant-u-253|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@182@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r)))
    (=>
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>))))
  :qid |qp.fvfDomDef114|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@182@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef113|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@178@01 $Ref)) (!
  (=>
    (Set_in n@178@01 g1@159@01)
    (and (= (inv@179@01 n@178@01) n@178@01) (img@180@01 n@178@01)))
  :pattern ((Set_in n@178@01 g1@159@01))
  :pattern ((inv@179@01 n@178@01))
  :pattern ((img@180@01 n@178@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@180@01 r) (Set_in (inv@179@01 r) g1@159@01))
    (= (inv@179@01 r) r))
  :pattern ((inv@179@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r)))
    (=>
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>))))
  :qid |qp.fvfDomDef114|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@182@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef113|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@179@01 r) g1@159@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
    :pattern ((inv@179@01 r))
    :qid |quant-u-249|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 34 | !(n$2@177@01 in g1@159@01)]
(assert (not (Set_in n$2@177@01 g1@159@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@178@01 $Ref)) (!
  (=>
    (Set_in n@178@01 g1@159@01)
    (and (= (inv@179@01 n@178@01) n@178@01) (img@180@01 n@178@01)))
  :pattern ((Set_in n@178@01 g1@159@01))
  :pattern ((inv@179@01 n@178@01))
  :pattern ((img@180@01 n@178@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@180@01 r) (Set_in (inv@179@01 r) g1@159@01))
    (= (inv@179@01 r) r))
  :pattern ((inv@179@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r)))
    (=>
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>))))
  :qid |qp.fvfDomDef114|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@182@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef113|)))
(assert (=>
  (Set_in n$2@177@01 g1@159@01)
  (and
    (Set_in n$2@177@01 g1@159@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@179@01 r) g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
      :pattern ((inv@179@01 r))
      :qid |quant-u-249|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01))))
; Joined path conditions
(assert (or (not (Set_in n$2@177@01 g1@159@01)) (Set_in n$2@177@01 g1@159@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@178@01 $Ref)) (!
  (=>
    (Set_in n@178@01 g1@159@01)
    (and (= (inv@179@01 n@178@01) n@178@01) (img@180@01 n@178@01)))
  :pattern ((Set_in n@178@01 g1@159@01))
  :pattern ((inv@179@01 n@178@01))
  :pattern ((img@180@01 n@178@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@180@01 r) (Set_in (inv@179@01 r) g1@159@01))
    (= (inv@179@01 r) r))
  :pattern ((inv@179@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r)))
    (=>
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@182@01  $FVF<next>))))
  :qid |qp.fvfDomDef114|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@179@01 r) g1@159@01) (img@180@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@182@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@182@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef113|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@177@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@177@01 g1@159@01)
      (and
        (Set_in n$2@177@01 g1@159@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@179@01 r) g1@159@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
          :pattern ((inv@179@01 r))
          :qid |quant-u-249|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01)))
    (or (not (Set_in n$2@177@01 g1@159@01)) (Set_in n$2@177@01 g1@159@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01) x1@161@01 n$2@177@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@329@14@329@35-aux|)))
(assert (forall ((n$2@177@01 $Ref)) (!
  (=>
    (Set_in n$2@177@01 g1@159@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01) x1@161@01 n$2@177@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@182@01  $FVF<next>)) g1@159@01) x1@161@01 n$2@177@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@329@14@329@35|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))
  $Snap.unit))
; [eval] (forall n: Ref, m: Ref :: { (n in g0), (m in g1) } (n in g0) && (m in g1) ==> edge($$((g0 union g1)), n, m) == (n == x0 && m == x1))
(declare-const n@183@01 $Ref)
(declare-const m@184@01 $Ref)
(push) ; 2
; [eval] (n in g0) && (m in g1) ==> edge($$((g0 union g1)), n, m) == (n == x0 && m == x1)
; [eval] (n in g0) && (m in g1)
; [eval] (n in g0)
(push) ; 3
; [then-branch: 35 | !(n@183@01 in g0@158@01) | live]
; [else-branch: 35 | n@183@01 in g0@158@01 | live]
(push) ; 4
; [then-branch: 35 | !(n@183@01 in g0@158@01)]
(assert (not (Set_in n@183@01 g0@158@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 35 | n@183@01 in g0@158@01]
(assert (Set_in n@183@01 g0@158@01))
; [eval] (m in g1)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (Set_in n@183@01 g0@158@01) (not (Set_in n@183@01 g0@158@01))))
(push) ; 3
; [then-branch: 36 | n@183@01 in g0@158@01 && m@184@01 in g1@159@01 | live]
; [else-branch: 36 | !(n@183@01 in g0@158@01 && m@184@01 in g1@159@01) | live]
(push) ; 4
; [then-branch: 36 | n@183@01 in g0@158@01 && m@184@01 in g1@159@01]
(assert (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01)))
; [eval] edge($$((g0 union g1)), n, m) == (n == x0 && m == x1)
; [eval] edge($$((g0 union g1)), n, m)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 5
(declare-const n@185@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@185@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 6
(declare-fun inv@186@01 ($Ref) $Ref)
(declare-fun img@187@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@185@01 $Ref) (n2@185@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@185@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n1@185@01) n1@185@01))
      (and
        (Set_in n2@185@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n2@185@01) n2@185@01))
      (= n1@185@01 n2@185@01))
    (= n1@185@01 n2@185@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@185@01 $Ref)) (!
  (=>
    (Set_in n@185@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@186@01 n@185@01) n@185@01) (img@187@01 n@185@01)))
  :pattern ((Set_in n@185@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@186@01 n@185@01))
  :pattern ((img@187@01 n@185@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@187@01 r) (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@186@01 r) r))
  :pattern ((inv@186@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
  :pattern ((inv@186@01 r))
  :qid |quant-u-255|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@188@01 ((r $Ref) (n@183@01 $Ref) (m@184@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
      (img@187@01 r)
      (= r (inv@186@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@188@01 r n@183@01 m@184@01))
    $Perm.No)
  
  :qid |quant-u-257|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@188@01 r n@183@01 m@184@01) $Perm.No)
  
  :qid |quant-u-258|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
      (img@187@01 r)
      (= r (inv@186@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@188@01 r n@183@01 m@184@01))
      $Perm.No))
  
  :qid |quant-u-259|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@189@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r)))
    (=>
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>))))
  :qid |qp.fvfDomDef117|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef116|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@189@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@185@01 $Ref)) (!
  (=>
    (Set_in n@185@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@186@01 n@185@01) n@185@01) (img@187@01 n@185@01)))
  :pattern ((Set_in n@185@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@186@01 n@185@01))
  :pattern ((img@187@01 n@185@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@187@01 r) (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@186@01 r) r))
  :pattern ((inv@186@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r)))
    (=>
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>))))
  :qid |qp.fvfDomDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef116|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
    :pattern ((inv@186@01 r))
    :qid |quant-u-255|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@189@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
; [eval] n == x0 && m == x1
; [eval] n == x0
(set-option :timeout 0)
(push) ; 5
; [then-branch: 37 | n@183@01 != x0@160@01 | live]
; [else-branch: 37 | n@183@01 == x0@160@01 | live]
(push) ; 6
; [then-branch: 37 | n@183@01 != x0@160@01]
(assert (not (= n@183@01 x0@160@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 37 | n@183@01 == x0@160@01]
(assert (= n@183@01 x0@160@01))
; [eval] m == x1
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (= n@183@01 x0@160@01) (not (= n@183@01 x0@160@01))))
(pop) ; 4
(push) ; 4
; [else-branch: 36 | !(n@183@01 in g0@158@01 && m@184@01 in g1@159@01)]
(assert (not (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@185@01 $Ref)) (!
  (=>
    (Set_in n@185@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@186@01 n@185@01) n@185@01) (img@187@01 n@185@01)))
  :pattern ((Set_in n@185@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@186@01 n@185@01))
  :pattern ((img@187@01 n@185@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@187@01 r) (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@186@01 r) r))
  :pattern ((inv@186@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r)))
    (=>
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>))))
  :qid |qp.fvfDomDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef116|)))
(assert (=>
  (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))
  (and
    (Set_in n@183@01 g0@158@01)
    (Set_in m@184@01 g1@159@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
      :pattern ((inv@186@01 r))
      :qid |quant-u-255|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@189@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
    (or (= n@183@01 x0@160@01) (not (= n@183@01 x0@160@01))))))
; Joined path conditions
(assert (or
  (not (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01)))
  (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@185@01 $Ref)) (!
  (=>
    (Set_in n@185@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@186@01 n@185@01) n@185@01) (img@187@01 n@185@01)))
  :pattern ((Set_in n@185@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@186@01 n@185@01))
  :pattern ((img@187@01 n@185@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@187@01 r) (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@186@01 r) r))
  :pattern ((inv@186@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r)))
    (=>
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@189@01  $FVF<next>))))
  :qid |qp.fvfDomDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
        (img@187@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@189@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@189@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef116|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@183@01 $Ref) (m@184@01 $Ref)) (!
  (and
    (or (Set_in n@183@01 g0@158@01) (not (Set_in n@183@01 g0@158@01)))
    (=>
      (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))
      (and
        (Set_in n@183@01 g0@158@01)
        (Set_in m@184@01 g1@159@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@186@01 r) (Set_union g0@158@01 g1@159@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
          :pattern ((inv@186@01 r))
          :qid |quant-u-255|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@189@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
        (or (= n@183@01 x0@160@01) (not (= n@183@01 x0@160@01)))))
    (or
      (not (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01)))
      (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))))
  :pattern ((Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@333@14@333@128-aux|)))
(assert (forall ((n@183@01 $Ref) (m@184@01 $Ref)) (!
  (=>
    (and (Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))
    (=
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@189@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) n@183@01 m@184@01)
      (and (= n@183@01 x0@160@01) (= m@184@01 x1@161@01))))
  :pattern ((Set_in n@183@01 g0@158@01) (Set_in m@184@01 g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@333@14@333@128|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))
  $Snap.unit))
; [eval] (forall n: Ref, m: Ref :: { (n in g1), (m in g0) } (n in g1) && (m in g0) ==> !edge($$((g0 union g1)), n, m))
(declare-const n@190@01 $Ref)
(declare-const m@191@01 $Ref)
(push) ; 2
; [eval] (n in g1) && (m in g0) ==> !edge($$((g0 union g1)), n, m)
; [eval] (n in g1) && (m in g0)
; [eval] (n in g1)
(push) ; 3
; [then-branch: 38 | !(n@190@01 in g1@159@01) | live]
; [else-branch: 38 | n@190@01 in g1@159@01 | live]
(push) ; 4
; [then-branch: 38 | !(n@190@01 in g1@159@01)]
(assert (not (Set_in n@190@01 g1@159@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 38 | n@190@01 in g1@159@01]
(assert (Set_in n@190@01 g1@159@01))
; [eval] (m in g0)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (Set_in n@190@01 g1@159@01) (not (Set_in n@190@01 g1@159@01))))
(push) ; 3
; [then-branch: 39 | n@190@01 in g1@159@01 && m@191@01 in g0@158@01 | live]
; [else-branch: 39 | !(n@190@01 in g1@159@01 && m@191@01 in g0@158@01) | live]
(push) ; 4
; [then-branch: 39 | n@190@01 in g1@159@01 && m@191@01 in g0@158@01]
(assert (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01)))
; [eval] !edge($$((g0 union g1)), n, m)
; [eval] edge($$((g0 union g1)), n, m)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 5
(declare-const n@192@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@192@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 6
(declare-fun inv@193@01 ($Ref) $Ref)
(declare-fun img@194@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@192@01 $Ref) (n2@192@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@192@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n1@192@01) n1@192@01))
      (and
        (Set_in n2@192@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n2@192@01) n2@192@01))
      (= n1@192@01 n2@192@01))
    (= n1@192@01 n2@192@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@192@01 $Ref)) (!
  (=>
    (Set_in n@192@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@193@01 n@192@01) n@192@01) (img@194@01 n@192@01)))
  :pattern ((Set_in n@192@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@193@01 n@192@01))
  :pattern ((img@194@01 n@192@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@194@01 r) (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@193@01 r) r))
  :pattern ((inv@193@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
  :pattern ((inv@193@01 r))
  :qid |quant-u-261|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@195@01 ((r $Ref) (n@190@01 $Ref) (m@191@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
      (img@194@01 r)
      (= r (inv@193@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@195@01 r n@190@01 m@191@01))
    $Perm.No)
  
  :qid |quant-u-263|))))
(check-sat)
; unknown
(pop) ; 6
; 0,34s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@195@01 r n@190@01 m@191@01) $Perm.No)
  
  :qid |quant-u-264|))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
      (img@194@01 r)
      (= r (inv@193@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@195@01 r n@190@01 m@191@01))
      $Perm.No))
  
  :qid |quant-u-265|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@196@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r)))
    (=>
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>))))
  :qid |qp.fvfDomDef120|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@196@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@196@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@192@01 $Ref)) (!
  (=>
    (Set_in n@192@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@193@01 n@192@01) n@192@01) (img@194@01 n@192@01)))
  :pattern ((Set_in n@192@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@193@01 n@192@01))
  :pattern ((img@194@01 n@192@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@194@01 r) (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@193@01 r) r))
  :pattern ((inv@193@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r)))
    (=>
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>))))
  :qid |qp.fvfDomDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@196@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
    :pattern ((inv@193@01 r))
    :qid |quant-u-261|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@196@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 39 | !(n@190@01 in g1@159@01 && m@191@01 in g0@158@01)]
(assert (not (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@192@01 $Ref)) (!
  (=>
    (Set_in n@192@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@193@01 n@192@01) n@192@01) (img@194@01 n@192@01)))
  :pattern ((Set_in n@192@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@193@01 n@192@01))
  :pattern ((img@194@01 n@192@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@194@01 r) (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@193@01 r) r))
  :pattern ((inv@193@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r)))
    (=>
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>))))
  :qid |qp.fvfDomDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@196@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert (=>
  (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))
  (and
    (Set_in n@190@01 g1@159@01)
    (Set_in m@191@01 g0@158@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
      :pattern ((inv@193@01 r))
      :qid |quant-u-261|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@196@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))))
; Joined path conditions
(assert (or
  (not (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01)))
  (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@192@01 $Ref)) (!
  (=>
    (Set_in n@192@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@193@01 n@192@01) n@192@01) (img@194@01 n@192@01)))
  :pattern ((Set_in n@192@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@193@01 n@192@01))
  :pattern ((img@194@01 n@192@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@194@01 r) (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@193@01 r) r))
  :pattern ((inv@193@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r)))
    (=>
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@196@01  $FVF<next>))))
  :qid |qp.fvfDomDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
        (img@194@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@196@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@196@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n@190@01 $Ref) (m@191@01 $Ref)) (!
  (and
    (or (Set_in n@190@01 g1@159@01) (not (Set_in n@190@01 g1@159@01)))
    (=>
      (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))
      (and
        (Set_in n@190@01 g1@159@01)
        (Set_in m@191@01 g0@158@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@193@01 r) (Set_union g0@158@01 g1@159@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
          :pattern ((inv@193@01 r))
          :qid |quant-u-261|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@196@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
    (or
      (not (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01)))
      (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))))
  :pattern ((Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@334@14@334@107-aux|)))
(assert (forall ((n@190@01 $Ref) (m@191@01 $Ref)) (!
  (=>
    (and (Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))
    (not
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@196@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) n@190@01 m@191@01)))
  :pattern ((Set_in n@190@01 g1@159@01) (Set_in m@191@01 g0@158@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@334@14@334@107|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))
  $Snap.unit))
; [eval] acyclic_graph($$((g0 union g1)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 2
(declare-const n@197@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@197@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 3
(declare-fun inv@198@01 ($Ref) $Ref)
(declare-fun img@199@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@197@01 $Ref) (n2@197@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@197@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n1@197@01) n1@197@01))
      (and
        (Set_in n2@197@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) n2@197@01) n2@197@01))
      (= n1@197@01 n2@197@01))
    (= n1@197@01 n2@197@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@197@01 $Ref)) (!
  (=>
    (Set_in n@197@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@198@01 n@197@01) n@197@01) (img@199@01 n@197@01)))
  :pattern ((Set_in n@197@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@198@01 n@197@01))
  :pattern ((img@199@01 n@197@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@199@01 r) (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@198@01 r) r))
  :pattern ((inv@198@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
  :pattern ((inv@198@01 r))
  :qid |quant-u-267|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@200@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
      (img@199@01 r)
      (= r (inv@198@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@200@01 r))
    $Perm.No)
  
  :qid |quant-u-269|))))
(check-sat)
; unknown
(pop) ; 3
; 0,27s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@200@01 r) $Perm.No)
  
  :qid |quant-u-270|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
      (img@199@01 r)
      (= r (inv@198@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@200@01 r)) $Perm.No))
  
  :qid |quant-u-271|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@201@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))
      (and
        (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
        (img@199@01 r)))
    (=>
      (and
        (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
        (img@199@01 r))
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
        (img@199@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@201@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@201@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@197@01 $Ref)) (!
  (=>
    (Set_in n@197@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@198@01 n@197@01) n@197@01) (img@199@01 n@197@01)))
  :pattern ((Set_in n@197@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@198@01 n@197@01))
  :pattern ((img@199@01 n@197@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@199@01 r) (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@198@01 r) r))
  :pattern ((inv@198@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))
      (and
        (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
        (img@199@01 r)))
    (=>
      (and
        (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
        (img@199@01 r))
      (Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@201@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
        (img@199@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@201@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@201@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@198@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@169@01  $FVF<next>) r) r))
    :pattern ((inv@198@01 r))
    :qid |quant-u-267|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@201@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@201@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))))
  $Snap.unit))
; [eval] func_graph($$((g0 union g1)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(set-option :timeout 0)
(push) ; 2
(declare-const n@202@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@202@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 3
(declare-fun inv@203@01 ($Ref) $Ref)
(declare-fun img@204@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@205@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@205@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@205@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@205@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef125|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@202@01 $Ref) (n2@202@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@202@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@205@01  $FVF<next>) n1@202@01) n1@202@01))
      (and
        (Set_in n2@202@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@205@01  $FVF<next>) n2@202@01) n2@202@01))
      (= n1@202@01 n2@202@01))
    (= n1@202@01 n2@202@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@202@01 $Ref)) (!
  (=>
    (Set_in n@202@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@203@01 n@202@01) n@202@01) (img@204@01 n@202@01)))
  :pattern ((Set_in n@202@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@203@01 n@202@01))
  :pattern ((img@204@01 n@202@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@204@01 r) (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@203@01 r) r))
  :pattern ((inv@203@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@205@01  $FVF<next>) r) r))
  :pattern ((inv@203@01 r))
  :qid |quant-u-273|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@206@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
      (img@204@01 r)
      (= r (inv@203@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@206@01 r))
    $Perm.No)
  
  :qid |quant-u-275|))))
(check-sat)
; unknown
(pop) ; 3
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@206@01 r) $Perm.No)
  
  :qid |quant-u-276|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
      (img@204@01 r)
      (= r (inv@203@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@206@01 r)) $Perm.No))
  
  :qid |quant-u-277|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@207@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@207@01  $FVF<next>)))
      (and
        (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
        (img@204@01 r)))
    (=>
      (and
        (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
        (img@204@01 r))
      (Set_in r ($FVF.domain_next (as sm@207@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@207@01  $FVF<next>))))
  :qid |qp.fvfDomDef128|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
        (img@204@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef127|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@207@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 2
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@205@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@205@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@205@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef125|)))
(assert (forall ((n@202@01 $Ref)) (!
  (=>
    (Set_in n@202@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@203@01 n@202@01) n@202@01) (img@204@01 n@202@01)))
  :pattern ((Set_in n@202@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@203@01 n@202@01))
  :pattern ((img@204@01 n@202@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@204@01 r) (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@203@01 r) r))
  :pattern ((inv@203@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@207@01  $FVF<next>)))
      (and
        (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
        (img@204@01 r)))
    (=>
      (and
        (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
        (img@204@01 r))
      (Set_in r ($FVF.domain_next (as sm@207@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@207@01  $FVF<next>))))
  :qid |qp.fvfDomDef128|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
        (img@204@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@207@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@207@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef127|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@203@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@205@01  $FVF<next>) r) r))
    :pattern ((inv@203@01 r))
    :qid |quant-u-273|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@207@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(assert (func_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@207@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))))
  $Snap.unit))
; [eval] unshared_graph($$((g0 union g1)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(set-option :timeout 0)
(push) ; 2
(declare-const n@208@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@208@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 3
(declare-fun inv@209@01 ($Ref) $Ref)
(declare-fun img@210@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@211@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@211@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@211@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@211@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef130|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@208@01 $Ref) (n2@208@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@208@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@211@01  $FVF<next>) n1@208@01) n1@208@01))
      (and
        (Set_in n2@208@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@211@01  $FVF<next>) n2@208@01) n2@208@01))
      (= n1@208@01 n2@208@01))
    (= n1@208@01 n2@208@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@208@01 $Ref)) (!
  (=>
    (Set_in n@208@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@209@01 n@208@01) n@208@01) (img@210@01 n@208@01)))
  :pattern ((Set_in n@208@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@209@01 n@208@01))
  :pattern ((img@210@01 n@208@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@210@01 r) (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@209@01 r) r))
  :pattern ((inv@209@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@211@01  $FVF<next>) r) r))
  :pattern ((inv@209@01 r))
  :qid |quant-u-279|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@212@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
      (img@210@01 r)
      (= r (inv@209@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@212@01 r))
    $Perm.No)
  
  :qid |quant-u-281|))))
(check-sat)
; unknown
(pop) ; 3
; 0,16s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@212@01 r) $Perm.No)
  
  :qid |quant-u-282|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
      (img@210@01 r)
      (= r (inv@209@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@212@01 r)) $Perm.No))
  
  :qid |quant-u-283|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@213@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))
      (and
        (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
        (img@210@01 r)))
    (=>
      (and
        (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
        (img@210@01 r))
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>))))
  :qid |qp.fvfDomDef133|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
        (img@210@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@213@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef132|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@213@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 2
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@211@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@211@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@211@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef130|)))
(assert (forall ((n@208@01 $Ref)) (!
  (=>
    (Set_in n@208@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@209@01 n@208@01) n@208@01) (img@210@01 n@208@01)))
  :pattern ((Set_in n@208@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@209@01 n@208@01))
  :pattern ((img@210@01 n@208@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@210@01 r) (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@209@01 r) r))
  :pattern ((inv@209@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))
      (and
        (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
        (img@210@01 r)))
    (=>
      (and
        (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
        (img@210@01 r))
      (Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@213@01  $FVF<next>))))
  :qid |qp.fvfDomDef133|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
        (img@210@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@213@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@213@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef132|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@209@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@211@01  $FVF<next>) r) r))
    :pattern ((inv@209@01 r))
    :qid |quant-u-279|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@213@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@213@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))))))))))
  $Snap.unit))
; [eval] x0.next == x1
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01) x0@160@01))
(set-option :timeout 0)
(push) ; 2
(assert (not (and
  (img@168@01 x0@160@01)
  (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
(assert (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
  x1@161@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@214@01 $Snap)
(assert (= $t@214@01 ($Snap.combine ($Snap.first $t@214@01) ($Snap.second $t@214@01))))
(assert (= ($Snap.first $t@214@01) $Snap.unit))
; [eval] !((null in g0))
; [eval] (null in g0)
(assert (not (Set_in $Ref.null g0@158@01)))
(assert (=
  ($Snap.second $t@214@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@214@01))
    ($Snap.second ($Snap.second $t@214@01)))))
(declare-const n$3@215@01 $Ref)
(push) ; 3
; [eval] (n$3 in g0)
(assert (Set_in n$3@215@01 g0@158@01))
(declare-const sm@216@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@217@01 ($Ref) $Ref)
(declare-fun img@218@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$31@215@01 $Ref) (n$32@215@01 $Ref)) (!
  (=>
    (and
      (Set_in n$31@215@01 g0@158@01)
      (Set_in n$32@215@01 g0@158@01)
      (= n$31@215@01 n$32@215@01))
    (= n$31@215@01 n$32@215@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$3@215@01 $Ref)) (!
  (=>
    (Set_in n$3@215@01 g0@158@01)
    (and (= (inv@217@01 n$3@215@01) n$3@215@01) (img@218@01 n$3@215@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) n$3@215@01) n$3@215@01))
  :qid |quant-u-285|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (= (inv@217@01 r) r))
  :pattern ((inv@217@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$3@215@01 $Ref)) (!
  (=> (Set_in n$3@215@01 g0@158@01) (not (= n$3@215@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) n$3@215@01) n$3@215@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@219@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@219@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@217@01 r) g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) r) r))
  :pattern ((inv@217@01 r))
  :qid |quant-u-286|)))
(assert (=
  ($Snap.second ($Snap.second $t@214@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@214@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@214@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@214@01))) $Snap.unit))
; [eval] (forall n$4: Ref :: { (n$4.next in g0) } { (n$4 in g0), n$4.next } (n$4 in g0) && n$4.next != null ==> (n$4.next in g0))
(declare-const n$4@220@01 $Ref)
(push) ; 3
; [eval] (n$4 in g0) && n$4.next != null ==> (n$4.next in g0)
; [eval] (n$4 in g0) && n$4.next != null
; [eval] (n$4 in g0)
(push) ; 4
; [then-branch: 40 | !(n$4@220@01 in g0@158@01) | live]
; [else-branch: 40 | n$4@220@01 in g0@158@01 | live]
(push) ; 5
; [then-branch: 40 | !(n$4@220@01 in g0@158@01)]
(assert (not (Set_in n$4@220@01 g0@158@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 40 | n$4@220@01 in g0@158@01]
(assert (Set_in n$4@220@01 g0@158@01))
; [eval] n$4.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
      (=
        ($FVF.lookup_next (as sm@219@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
    :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
    :qid |qp.fvfValDef135|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef136|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01))
(push) ; 6
(assert (not (and (img@218@01 n$4@220@01) (Set_in (inv@217@01 n$4@220@01) g0@158@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@219@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (=>
  (Set_in n$4@220@01 g0@158@01)
  (and
    (Set_in n$4@220@01 g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01))))
(assert (or (Set_in n$4@220@01 g0@158@01) (not (Set_in n$4@220@01 g0@158@01))))
(push) ; 4
; [then-branch: 41 | n$4@220@01 in g0@158@01 && Lookup(next, sm@219@01, n$4@220@01) != Null | live]
; [else-branch: 41 | !(n$4@220@01 in g0@158@01 && Lookup(next, sm@219@01, n$4@220@01) != Null) | live]
(push) ; 5
; [then-branch: 41 | n$4@220@01 in g0@158@01 && Lookup(next, sm@219@01, n$4@220@01) != Null]
(assert (and
  (Set_in n$4@220@01 g0@158@01)
  (not (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null))))
; [eval] (n$4.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
      (=
        ($FVF.lookup_next (as sm@219@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
    :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
    :qid |qp.fvfValDef135|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef136|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01))
(push) ; 6
(assert (not (and (img@218@01 n$4@220@01) (Set_in (inv@217@01 n$4@220@01) g0@158@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 41 | !(n$4@220@01 in g0@158@01 && Lookup(next, sm@219@01, n$4@220@01) != Null)]
(assert (not
  (and
    (Set_in n$4@220@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@219@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (=>
  (and
    (Set_in n$4@220@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))
  (and
    (Set_in n$4@220@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$4@220@01 g0@158@01)
      (not
        (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null))))
  (and
    (Set_in n$4@220@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@219@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@219@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@220@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@220@01 g0@158@01)
      (and
        (Set_in n$4@220@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01)))
    (or (Set_in n$4@220@01 g0@158@01) (not (Set_in n$4@220@01 g0@158@01)))
    (=>
      (and
        (Set_in n$4@220@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))
      (and
        (Set_in n$4@220@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01)))
    (or
      (not
        (and
          (Set_in n$4@220@01 g0@158@01)
          (not
            (=
              ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01)
              $Ref.null))))
      (and
        (Set_in n$4@220@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) g0@158@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22-aux|)))
(assert (forall ((n$4@220@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@220@01 g0@158@01)
      (and
        (Set_in n$4@220@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01)))
    (or (Set_in n$4@220@01 g0@158@01) (not (Set_in n$4@220@01 g0@158@01)))
    (=>
      (and
        (Set_in n$4@220@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))
      (and
        (Set_in n$4@220@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01)))
    (or
      (not
        (and
          (Set_in n$4@220@01 g0@158@01)
          (not
            (=
              ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01)
              $Ref.null))))
      (and
        (Set_in n$4@220@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))))
  :pattern ((Set_in n$4@220@01 g0@158@01) ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22-aux|)))
(assert (forall ((n$4@220@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@220@01 g0@158@01)
      (not
        (= ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) g0@158@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) g0@158@01))
  :pattern ((Set_in n$4@220@01 g0@158@01) ($FVF.loc_next ($FVF.lookup_next (as sm@219@01  $FVF<next>) n$4@220@01) n$4@220@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@214@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@214@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@214@01))))
  $Snap.unit))
; [eval] !((null in g1))
; [eval] (null in g1)
(assert (not (Set_in $Ref.null g1@159@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01))))))))
(declare-const n$5@221@01 $Ref)
(push) ; 3
; [eval] (n$5 in g1)
(assert (Set_in n$5@221@01 g1@159@01))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@222@01 ($Ref) $Ref)
(declare-fun img@223@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$51@221@01 $Ref) (n$52@221@01 $Ref)) (!
  (=>
    (and
      (Set_in n$51@221@01 g1@159@01)
      (Set_in n$52@221@01 g1@159@01)
      (= n$51@221@01 n$52@221@01))
    (= n$51@221@01 n$52@221@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$5@221@01 $Ref)) (!
  (=>
    (Set_in n$5@221@01 g1@159@01)
    (and (= (inv@222@01 n$5@221@01) n$5@221@01) (img@223@01 n$5@221@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) n$5@221@01) n$5@221@01))
  :qid |quant-u-288|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
    (= (inv@222@01 r) r))
  :pattern ((inv@222@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$5@221@01 $Ref)) (!
  (=> (Set_in n$5@221@01 g1@159@01) (not (= n$5@221@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) n$5@221@01) n$5@221@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$5@221@01 n$3@215@01)
    (=
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))))
  
  :qid |quant-u-289|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(declare-const sm@224@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@222@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
  :pattern ((inv@222@01 r))
  :qid |quant-u-290|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01))))))
  $Snap.unit))
; [eval] (forall n$6: Ref :: { (n$6.next in g1) } { (n$6 in g1), n$6.next } (n$6 in g1) && n$6.next != null ==> (n$6.next in g1))
(declare-const n$6@225@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$6 in g1) && n$6.next != null ==> (n$6.next in g1)
; [eval] (n$6 in g1) && n$6.next != null
; [eval] (n$6 in g1)
(push) ; 4
; [then-branch: 42 | !(n$6@225@01 in g1@159@01) | live]
; [else-branch: 42 | n$6@225@01 in g1@159@01 | live]
(push) ; 5
; [then-branch: 42 | !(n$6@225@01 in g1@159@01)]
(assert (not (Set_in n$6@225@01 g1@159@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 42 | n$6@225@01 in g1@159@01]
(assert (Set_in n$6@225@01 g1@159@01))
; [eval] n$6.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
      (=
        ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
    :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
    :qid |qp.fvfValDef137|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
      (=
        ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
    :qid |qp.fvfValDef138|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef139|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@218@01 n$6@225@01) (Set_in (inv@217@01 n$6@225@01) g0@158@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@223@01 n$6@225@01) (Set_in (inv@222@01 n$6@225@01) g1@159@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (=>
  (Set_in n$6@225@01 g1@159@01)
  (and
    (Set_in n$6@225@01 g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01))))
(assert (or (Set_in n$6@225@01 g1@159@01) (not (Set_in n$6@225@01 g1@159@01))))
(push) ; 4
; [then-branch: 43 | n$6@225@01 in g1@159@01 && Lookup(next, sm@224@01, n$6@225@01) != Null | live]
; [else-branch: 43 | !(n$6@225@01 in g1@159@01 && Lookup(next, sm@224@01, n$6@225@01) != Null) | live]
(push) ; 5
; [then-branch: 43 | n$6@225@01 in g1@159@01 && Lookup(next, sm@224@01, n$6@225@01) != Null]
(assert (and
  (Set_in n$6@225@01 g1@159@01)
  (not (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null))))
; [eval] (n$6.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
      (=
        ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
    :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
    :qid |qp.fvfValDef137|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
      (=
        ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
    :qid |qp.fvfValDef138|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef139|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@218@01 n$6@225@01) (Set_in (inv@217@01 n$6@225@01) g0@158@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@223@01 n$6@225@01) (Set_in (inv@222@01 n$6@225@01) g1@159@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 43 | !(n$6@225@01 in g1@159@01 && Lookup(next, sm@224@01, n$6@225@01) != Null)]
(assert (not
  (and
    (Set_in n$6@225@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (=>
  (and
    (Set_in n$6@225@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))
  (and
    (Set_in n$6@225@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$6@225@01 g1@159@01)
      (not
        (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null))))
  (and
    (Set_in n$6@225@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
    (=
      ($FVF.lookup_next (as sm@224@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@224@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef139|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$6@225@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@225@01 g1@159@01)
      (and
        (Set_in n$6@225@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01)))
    (or (Set_in n$6@225@01 g1@159@01) (not (Set_in n$6@225@01 g1@159@01)))
    (=>
      (and
        (Set_in n$6@225@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))
      (and
        (Set_in n$6@225@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01)))
    (or
      (not
        (and
          (Set_in n$6@225@01 g1@159@01)
          (not
            (=
              ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01)
              $Ref.null))))
      (and
        (Set_in n$6@225@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22-aux|)))
(assert (forall ((n$6@225@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@225@01 g1@159@01)
      (and
        (Set_in n$6@225@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01)))
    (or (Set_in n$6@225@01 g1@159@01) (not (Set_in n$6@225@01 g1@159@01)))
    (=>
      (and
        (Set_in n$6@225@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))
      (and
        (Set_in n$6@225@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01)))
    (or
      (not
        (and
          (Set_in n$6@225@01 g1@159@01)
          (not
            (=
              ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01)
              $Ref.null))))
      (and
        (Set_in n$6@225@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))))
  :pattern ((Set_in n$6@225@01 g1@159@01) ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22-aux|)))
(assert (forall ((n$6@225@01 $Ref)) (!
  (=>
    (and
      (Set_in n$6@225@01 g1@159@01)
      (not
        (= ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) g1@159@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) g1@159@01))
  :pattern ((Set_in n$6@225@01 g1@159@01) ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n$6@225@01) n$6@225@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01))))))
  $Snap.unit))
; [eval] (forall n$7: Ref :: { exists_path($$(g1), x1, n$7) } (n$7 in g1) ==> exists_path($$(g1), x1, n$7))
(declare-const n$7@226@01 $Ref)
(push) ; 3
; [eval] (n$7 in g1) ==> exists_path($$(g1), x1, n$7)
; [eval] (n$7 in g1)
(push) ; 4
; [then-branch: 44 | n$7@226@01 in g1@159@01 | live]
; [else-branch: 44 | !(n$7@226@01 in g1@159@01) | live]
(push) ; 5
; [then-branch: 44 | n$7@226@01 in g1@159@01]
(assert (Set_in n$7@226@01 g1@159@01))
; [eval] exists_path($$(g1), x1, n$7)
; [eval] $$(g1)
(push) ; 6
(declare-const n@227@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@227@01 g1@159@01))
(pop) ; 7
(declare-fun inv@228@01 ($Ref) $Ref)
(declare-fun img@229@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@227@01 $Ref) (n2@227@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@227@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n1@227@01) n1@227@01))
      (and
        (Set_in n2@227@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) n2@227@01) n2@227@01))
      (= n1@227@01 n2@227@01))
    (= n1@227@01 n2@227@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@227@01 $Ref)) (!
  (=>
    (Set_in n@227@01 g1@159@01)
    (and (= (inv@228@01 n@227@01) n@227@01) (img@229@01 n@227@01)))
  :pattern ((Set_in n@227@01 g1@159@01))
  :pattern ((inv@228@01 n@227@01))
  :pattern ((img@229@01 n@227@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@229@01 r) (Set_in (inv@228@01 r) g1@159@01))
    (= (inv@228@01 r) r))
  :pattern ((inv@228@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@228@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
  :pattern ((inv@228@01 r))
  :qid |quant-u-292|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@230@01 ((r $Ref) (n$7@226@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r) (= r (inv@228@01 r)))
    ($Perm.min
      (ite
        (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@231@01 ((r $Ref) (n$7@226@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r) (= r (inv@228@01 r)))
    ($Perm.min
      (ite
        (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@230@01 r n$7@226@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01))
        $Perm.Write
        $Perm.No)
      (pTaken@230@01 r n$7@226@01))
    $Perm.No)
  
  :qid |quant-u-294|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@230@01 r n$7@226@01) $Perm.No)
  
  :qid |quant-u-295|))))
(check-sat)
; unsat
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r) (= r (inv@228@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@230@01 r n$7@226@01)) $Perm.No))
  
  :qid |quant-u-296|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01))
        $Perm.Write
        $Perm.No)
      (pTaken@231@01 r n$7@226@01))
    $Perm.No)
  
  :qid |quant-u-297|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@231@01 r n$7@226@01) $Perm.No)
  
  :qid |quant-u-298|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r) (= r (inv@228@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@230@01 r n$7@226@01))
        (pTaken@231@01 r n$7@226@01))
      $Perm.No))
  
  :qid |quant-u-299|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@232@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r)))
    (=>
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>))))
  :qid |qp.fvfDomDef143|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef142|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@227@01 $Ref)) (!
  (=>
    (Set_in n@227@01 g1@159@01)
    (and (= (inv@228@01 n@227@01) n@227@01) (img@229@01 n@227@01)))
  :pattern ((Set_in n@227@01 g1@159@01))
  :pattern ((inv@228@01 n@227@01))
  :pattern ((img@229@01 n@227@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@229@01 r) (Set_in (inv@228@01 r) g1@159@01))
    (= (inv@228@01 r) r))
  :pattern ((inv@228@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r)))
    (=>
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>))))
  :qid |qp.fvfDomDef143|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef142|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@228@01 r) g1@159@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
    :pattern ((inv@228@01 r))
    :qid |quant-u-292|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01)))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 44 | !(n$7@226@01 in g1@159@01)]
(assert (not (Set_in n$7@226@01 g1@159@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((n@227@01 $Ref)) (!
  (=>
    (Set_in n@227@01 g1@159@01)
    (and (= (inv@228@01 n@227@01) n@227@01) (img@229@01 n@227@01)))
  :pattern ((Set_in n@227@01 g1@159@01))
  :pattern ((inv@228@01 n@227@01))
  :pattern ((img@229@01 n@227@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@229@01 r) (Set_in (inv@228@01 r) g1@159@01))
    (= (inv@228@01 r) r))
  :pattern ((inv@228@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r)))
    (=>
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>))))
  :qid |qp.fvfDomDef143|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef142|)))
(assert (=>
  (Set_in n$7@226@01 g1@159@01)
  (and
    (Set_in n$7@226@01 g1@159@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@228@01 r) g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
      :pattern ((inv@228@01 r))
      :qid |quant-u-292|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01))))
; Joined path conditions
(assert (or (not (Set_in n$7@226@01 g1@159@01)) (Set_in n$7@226@01 g1@159@01)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@227@01 $Ref)) (!
  (=>
    (Set_in n@227@01 g1@159@01)
    (and (= (inv@228@01 n@227@01) n@227@01) (img@229@01 n@227@01)))
  :pattern ((Set_in n@227@01 g1@159@01))
  :pattern ((inv@228@01 n@227@01))
  :pattern ((img@229@01 n@227@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@229@01 r) (Set_in (inv@228@01 r) g1@159@01))
    (= (inv@228@01 r) r))
  :pattern ((inv@228@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r)))
    (=>
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@232@01  $FVF<next>))))
  :qid |qp.fvfDomDef143|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@218@01 r) (Set_in (inv@217@01 r) g0@158@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@228@01 r) g1@159@01) (img@229@01 r))
      (and (img@223@01 r) (Set_in (inv@222@01 r) g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@232@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@214@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@214@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@232@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef142|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$7@226@01 $Ref)) (!
  (and
    (=>
      (Set_in n$7@226@01 g1@159@01)
      (and
        (Set_in n$7@226@01 g1@159@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@228@01 r) g1@159@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@224@01  $FVF<next>) r) r))
          :pattern ((inv@228@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01)))
    (or (not (Set_in n$7@226@01 g1@159@01)) (Set_in n$7@226@01 g1@159@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@226@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@347@13@347@34-aux|)))
(assert (forall ((n$7@226@01 $Ref)) (!
  (=>
    (Set_in n$7@226@01 g1@159@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@226@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@232@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@226@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@347@13@347@34|)))
(pop) ; 2
(push) ; 2
; [exec]
; inhale apply_TCFraming(g0, g1)
(declare-const $t@233@01 $Snap)
(assert (= $t@233@01 $Snap.unit))
; [eval] apply_TCFraming(g0, g1)
(push) ; 3
(declare-const n@234@01 $Ref)
(push) ; 4
; [eval] (n in g0)
(assert (Set_in n@234@01 g0@158@01))
(pop) ; 4
(declare-fun inv@235@01 ($Ref) $Ref)
(declare-fun img@236@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@237@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@237@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@234@01 $Ref) (n2@234@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@234@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) n1@234@01) n1@234@01))
      (and
        (Set_in n2@234@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) n2@234@01) n2@234@01))
      (= n1@234@01 n2@234@01))
    (= n1@234@01 n2@234@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@234@01 $Ref)) (!
  (=>
    (Set_in n@234@01 g0@158@01)
    (and (= (inv@235@01 n@234@01) n@234@01) (img@236@01 n@234@01)))
  :pattern ((Set_in n@234@01 g0@158@01))
  :pattern ((inv@235@01 n@234@01))
  :pattern ((img@236@01 n@234@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@236@01 r) (Set_in (inv@235@01 r) g0@158@01))
    (= (inv@235@01 r) r))
  :pattern ((inv@235@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@235@01 r) g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) r) r))
  :pattern ((inv@235@01 r))
  :qid |quant-u-301|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@238@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r) (= r (inv@235@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@238@01 r))
    $Perm.No)
  
  :qid |quant-u-303|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@238@01 r) $Perm.No)
  
  :qid |quant-u-304|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r) (= r (inv@235@01 r)))
    (= (- $Perm.Write (pTaken@238@01 r)) $Perm.No))
  
  :qid |quant-u-305|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@239@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))
      (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r)))
    (=>
      (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r))
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>))))
  :qid |qp.fvfDomDef148|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@239@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef146|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef147|)))
(declare-const n@240@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n in g1)
(assert (Set_in n@240@01 g1@159@01))
(pop) ; 4
(declare-fun inv@241@01 ($Ref) $Ref)
(declare-fun img@242@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@243@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- $Perm.Write (pTaken@238@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@243@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef150|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@240@01 $Ref) (n2@240@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@240@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@243@01  $FVF<next>) n1@240@01) n1@240@01))
      (and
        (Set_in n2@240@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@243@01  $FVF<next>) n2@240@01) n2@240@01))
      (= n1@240@01 n2@240@01))
    (= n1@240@01 n2@240@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@240@01 $Ref)) (!
  (=>
    (Set_in n@240@01 g1@159@01)
    (and (= (inv@241@01 n@240@01) n@240@01) (img@242@01 n@240@01)))
  :pattern ((Set_in n@240@01 g1@159@01))
  :pattern ((inv@241@01 n@240@01))
  :pattern ((img@242@01 n@240@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@242@01 r) (Set_in (inv@241@01 r) g1@159@01))
    (= (inv@241@01 r) r))
  :pattern ((inv@241@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@241@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@243@01  $FVF<next>) r) r))
  :pattern ((inv@241@01 r))
  :qid |quant-u-307|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@244@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r) (= r (inv@241@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- $Perm.Write (pTaken@238@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- $Perm.Write (pTaken@238@01 r))
        $Perm.No)
      (pTaken@244@01 r))
    $Perm.No)
  
  :qid |quant-u-309|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r) (= r (inv@241@01 r)))
    (= (- $Perm.Write (pTaken@244@01 r)) $Perm.No))
  
  :qid |quant-u-310|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@245@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@245@01  $FVF<next>)))
      (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r)))
    (=>
      (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r))
      (Set_in r ($FVF.domain_next (as sm@245@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@245@01  $FVF<next>))))
  :qid |qp.fvfDomDef153|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- $Perm.Write (pTaken@238@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@245@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@245@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef151|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@245@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef152|)))
; [eval] (g1 intersection g0) == Set[Ref]()
; [eval] (g1 intersection g0)
; [eval] Set[Ref]()
(set-option :timeout 0)
(push) ; 4
(assert (not (Set_equal (Set_intersection g1@159@01 g0@158@01) (as Set_empty  Set<$Ref>))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (Set_equal (Set_intersection g1@159@01 g0@158@01) (as Set_empty  Set<$Ref>)))
(assert (apply_TCFraming%precondition ($Snap.combine
  ($SortWrappers.$FVF<next>To$Snap (as sm@239@01  $FVF<next>))
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@245@01  $FVF<next>))
    $Snap.unit)) g0@158@01 g1@159@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@237@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@237@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef145|)))
(assert (forall ((n@234@01 $Ref)) (!
  (=>
    (Set_in n@234@01 g0@158@01)
    (and (= (inv@235@01 n@234@01) n@234@01) (img@236@01 n@234@01)))
  :pattern ((Set_in n@234@01 g0@158@01))
  :pattern ((inv@235@01 n@234@01))
  :pattern ((img@236@01 n@234@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@236@01 r) (Set_in (inv@235@01 r) g0@158@01))
    (= (inv@235@01 r) r))
  :pattern ((inv@235@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))
      (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r)))
    (=>
      (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r))
      (Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@239@01  $FVF<next>))))
  :qid |qp.fvfDomDef148|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@235@01 r) g0@158@01) (img@236@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@239@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef146|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@239@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef147|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- $Perm.Write (pTaken@238@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@243@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef150|)))
(assert (forall ((n@240@01 $Ref)) (!
  (=>
    (Set_in n@240@01 g1@159@01)
    (and (= (inv@241@01 n@240@01) n@240@01) (img@242@01 n@240@01)))
  :pattern ((Set_in n@240@01 g1@159@01))
  :pattern ((inv@241@01 n@240@01))
  :pattern ((img@242@01 n@240@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@242@01 r) (Set_in (inv@241@01 r) g1@159@01))
    (= (inv@241@01 r) r))
  :pattern ((inv@241@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@245@01  $FVF<next>)))
      (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r)))
    (=>
      (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r))
      (Set_in r ($FVF.domain_next (as sm@245@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@245@01  $FVF<next>))))
  :qid |qp.fvfDomDef153|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@241@01 r) g1@159@01) (img@242@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- $Perm.Write (pTaken@238@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@245@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@245@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef151|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@245@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef152|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@235@01 r) g0@158@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@237@01  $FVF<next>) r) r))
    :pattern ((inv@235@01 r))
    :qid |quant-u-301|))
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@241@01 r) g1@159@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@243@01  $FVF<next>) r) r))
    :pattern ((inv@241@01 r))
    :qid |quant-u-307|))
  (Set_equal (Set_intersection g1@159@01 g0@158@01) (as Set_empty  Set<$Ref>))
  (apply_TCFraming%precondition ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@239@01  $FVF<next>))
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@245@01  $FVF<next>))
      $Snap.unit)) g0@158@01 g1@159@01)))
(assert (apply_TCFraming ($Snap.combine
  ($SortWrappers.$FVF<next>To$Snap (as sm@239@01  $FVF<next>))
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@245@01  $FVF<next>))
    $Snap.unit)) g0@158@01 g1@159@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unlink((g0 union g1), x0)
; [eval] (g0 union g1)
; [eval] (x in g)
(set-option :timeout 0)
(push) ; 3
(assert (not (Set_in x0@160@01 (Set_union g0@158@01 g1@159@01))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (Set_in x0@160@01 (Set_union g0@158@01 g1@159@01)))
; [eval] !((null in g))
; [eval] (null in g)
; [eval] (x in g)
(declare-const sm@246@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef155|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) x0@160@01))
; Precomputing data for removing quantified permissions
(define-fun pTaken@247@01 ((r $Ref)) $Perm
  (ite
    (= r x0@160@01)
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@247@01 r))
    $Perm.No)
  
  :qid |quant-u-312|))))
(check-sat)
; unknown
(pop) ; 3
; 0,47s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@247@01 r) $Perm.No)
  
  :qid |quant-u-313|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=> (= r x0@160@01) (= (- $Perm.Write (pTaken@247@01 r)) $Perm.No))
  
  :qid |quant-u-314|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (img@168@01 x0@160@01)
    (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))
  (=
    ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01)
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01))))
(declare-const n@248@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n in g) && n != x
; [eval] (n in g)
(push) ; 4
; [then-branch: 45 | !(n@248@01 in g0@158@01 ∪ g1@159@01) | live]
; [else-branch: 45 | n@248@01 in g0@158@01 ∪ g1@159@01 | live]
(push) ; 5
; [then-branch: 45 | !(n@248@01 in g0@158@01 ∪ g1@159@01)]
(assert (not (Set_in n@248@01 (Set_union g0@158@01 g1@159@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 45 | n@248@01 in g0@158@01 ∪ g1@159@01]
(assert (Set_in n@248@01 (Set_union g0@158@01 g1@159@01)))
; [eval] n != x
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (Set_in n@248@01 (Set_union g0@158@01 g1@159@01))
  (not (Set_in n@248@01 (Set_union g0@158@01 g1@159@01)))))
(assert (and
  (Set_in n@248@01 (Set_union g0@158@01 g1@159@01))
  (not (= n@248@01 x0@160@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@249@01 ($Ref) $Ref)
(declare-fun img@250@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((n@248@01 $Ref)) (!
  (=>
    (and
      (Set_in n@248@01 (Set_union g0@158@01 g1@159@01))
      (not (= n@248@01 x0@160@01)))
    (or
      (Set_in n@248@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n@248@01 (Set_union g0@158@01 g1@159@01)))))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n@248@01) n@248@01))
  :qid |next-aux|)))
(declare-const sm@251@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- $Perm.Write (pTaken@247@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@251@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@251@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@251@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef157|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@248@01 $Ref) (n2@248@01 $Ref)) (!
  (=>
    (and
      (and
        (and
          (Set_in n1@248@01 (Set_union g0@158@01 g1@159@01))
          (not (= n1@248@01 x0@160@01)))
        ($FVF.loc_next ($FVF.lookup_next (as sm@251@01  $FVF<next>) n1@248@01) n1@248@01))
      (and
        (and
          (Set_in n2@248@01 (Set_union g0@158@01 g1@159@01))
          (not (= n2@248@01 x0@160@01)))
        ($FVF.loc_next ($FVF.lookup_next (as sm@251@01  $FVF<next>) n2@248@01) n2@248@01))
      (= n1@248@01 n2@248@01))
    (= n1@248@01 n2@248@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@248@01 $Ref)) (!
  (=>
    (and
      (Set_in n@248@01 (Set_union g0@158@01 g1@159@01))
      (not (= n@248@01 x0@160@01)))
    (and (= (inv@249@01 n@248@01) n@248@01) (img@250@01 n@248@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n@248@01) n@248@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@250@01 r)
      (and
        (Set_in (inv@249@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@249@01 r) x0@160@01))))
    (= (inv@249@01 r) r))
  :pattern ((inv@249@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@249@01 r) (Set_union g0@158@01 g1@159@01))
      (not (= (inv@249@01 r) x0@160@01)))
    ($FVF.loc_next ($FVF.lookup_next (as sm@251@01  $FVF<next>) r) r))
  :pattern ((inv@249@01 r))
  :qid |quant-u-316|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@252@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (Set_in (inv@249@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@249@01 r) x0@160@01)))
      (img@250@01 r)
      (= r (inv@249@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- $Perm.Write (pTaken@247@01 r))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- $Perm.Write (pTaken@247@01 r))
        $Perm.No)
      (pTaken@252@01 r))
    $Perm.No)
  
  :qid |quant-u-318|))))
(check-sat)
; unknown
(pop) ; 3
; 0,27s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@252@01 r) $Perm.No)
  
  :qid |quant-u-319|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@249@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@249@01 r) x0@160@01)))
      (img@250@01 r)
      (= r (inv@249@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@252@01 r)) $Perm.No))
  
  :qid |quant-u-320|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$0: Ref :: { (n$0.next in g) } { (n$0 in g), n$0.next } (n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@253@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 4
; [then-branch: 46 | !(n$0@253@01 in g0@158@01 ∪ g1@159@01) | live]
; [else-branch: 46 | n$0@253@01 in g0@158@01 ∪ g1@159@01 | live]
(push) ; 5
; [then-branch: 46 | !(n$0@253@01 in g0@158@01 ∪ g1@159@01)]
(assert (not (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 46 | n$0@253@01 in g0@158@01 ∪ g1@159@01]
(assert (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01)))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (=
        ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef154|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef155|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))
(push) ; 6
(assert (not (and
  (img@168@01 n$0@253@01)
  (Set_in (inv@167@01 n$0@253@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef155|)))
(assert (=>
  (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
  (and
    (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))))
(assert (or
  (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
  (not (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01)))))
(push) ; 4
; [then-branch: 47 | n$0@253@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@246@01, n$0@253@01) != Null | live]
; [else-branch: 47 | !(n$0@253@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@246@01, n$0@253@01) != Null) | live]
(push) ; 5
; [then-branch: 47 | n$0@253@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@246@01, n$0@253@01) != Null]
(assert (and
  (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
  (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (=
        ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef154|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef155|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))
(push) ; 6
(assert (not (and
  (img@168@01 n$0@253@01)
  (Set_in (inv@167@01 n$0@253@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 47 | !(n$0@253@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@246@01, n$0@253@01) != Null)]
(assert (not
  (and
    (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef155|)))
(assert (=>
  (and
    (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))
  (and
    (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null))))
  (and
    (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef155|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@253@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01)))
    (or
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))))
    (=>
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01)))
    (or
      (not
        (and
          (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
          (not
            (=
              ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01)
              $Ref.null))))
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) (Set_union g0@158@01 g1@159@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34-aux|)))
(assert (forall ((n$0@253@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01)))
    (or
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))))
    (=>
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01)))
    (or
      (not
        (and
          (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
          (not
            (=
              ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01)
              $Ref.null))))
      (and
        (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))))
  :pattern ((Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34-aux|)))
(push) ; 3
(assert (not (forall ((n$0@253@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@253@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in n$0@253@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n$0@253@01) n$0@253@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@309@14@309@34|)))
(declare-const $t@254@01 $Snap)
(assert (= $t@254@01 ($Snap.combine ($Snap.first $t@254@01) ($Snap.second $t@254@01))))
(assert (= ($Snap.first $t@254@01) $Snap.unit))
; [eval] !((null in g))
; [eval] (null in g)
(assert (=
  ($Snap.second $t@254@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@254@01))
    ($Snap.second ($Snap.second $t@254@01)))))
(assert (= ($Snap.first ($Snap.second $t@254@01)) $Snap.unit))
; [eval] (x in g)
(assert (=
  ($Snap.second ($Snap.second $t@254@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@254@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))
(declare-const sm@255@01 $FVF<next>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($FVF.lookup_next (as sm@255@01  $FVF<next>) x0@160@01)
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@254@01))))))
(assert (not (= x0@160@01 $Ref.null)))
(declare-const sm@256@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@256@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@256@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@256@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@256@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef159|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r))
  :pattern (($FVF.lookup_next (as sm@256@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef160|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@256@01  $FVF<next>) x0@160@01) x0@160@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@254@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))))
(declare-const n$1@257@01 $Ref)
(push) ; 3
; [eval] (n$1 in g) && n$1 != x
; [eval] (n$1 in g)
(push) ; 4
; [then-branch: 48 | !(n$1@257@01 in g0@158@01 ∪ g1@159@01) | live]
; [else-branch: 48 | n$1@257@01 in g0@158@01 ∪ g1@159@01 | live]
(push) ; 5
; [then-branch: 48 | !(n$1@257@01 in g0@158@01 ∪ g1@159@01)]
(assert (not (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 48 | n$1@257@01 in g0@158@01 ∪ g1@159@01]
(assert (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01)))
; [eval] n$1 != x
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))
  (not (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01)))))
(assert (and
  (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))
  (not (= n$1@257@01 x0@160@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@258@01 ($Ref) $Ref)
(declare-fun img@259@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((n$1@257@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))
      (not (= n$1@257@01 x0@160@01)))
    (or
      (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01)))))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) n$1@257@01) n$1@257@01))
  :qid |next-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$11@257@01 $Ref) (n$12@257@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@257@01 (Set_union g0@158@01 g1@159@01))
        (not (= n$11@257@01 x0@160@01)))
      (and
        (Set_in n$12@257@01 (Set_union g0@158@01 g1@159@01))
        (not (= n$12@257@01 x0@160@01)))
      (= n$11@257@01 n$12@257@01))
    (= n$11@257@01 n$12@257@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@257@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))
      (not (= n$1@257@01 x0@160@01)))
    (and (= (inv@258@01 n$1@257@01) n$1@257@01) (img@259@01 n$1@257@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) n$1@257@01) n$1@257@01))
  :qid |quant-u-322|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (= (inv@258@01 r) r))
  :pattern ((inv@258@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@257@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@257@01 (Set_union g0@158@01 g1@159@01))
      (not (= n$1@257@01 x0@160@01)))
    (not (= n$1@257@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) n$1@257@01) n$1@257@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$1@257@01 n@165@01)
    (=
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))))
  
  :qid |quant-u-323|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(declare-const sm@260@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
      (not (= (inv@258@01 r) x0@160@01)))
    ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) r) r))
  :pattern ((inv@258@01 r))
  :qid |quant-u-324|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g) } { (n$2 in g), n$2.next } (n$2 in g) && n$2.next != null ==> (n$2.next in g))
(declare-const n$2@261@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$2 in g) && n$2.next != null ==> (n$2.next in g)
; [eval] (n$2 in g) && n$2.next != null
; [eval] (n$2 in g)
(push) ; 4
; [then-branch: 49 | !(n$2@261@01 in g0@158@01 ∪ g1@159@01) | live]
; [else-branch: 49 | n$2@261@01 in g0@158@01 ∪ g1@159@01 | live]
(push) ; 5
; [then-branch: 49 | !(n$2@261@01 in g0@158@01 ∪ g1@159@01)]
(assert (not (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 49 | n$2@261@01 in g0@158@01 ∪ g1@159@01]
(assert (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01)))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef161|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef162|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef163|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef164|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 n$2@261@01)
          (Set_in (inv@167@01 n$2@261@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 n$2@261@01)) (pTaken@252@01 n$2@261@01))
        $Perm.No)
      (ite (= n$2@261@01 x0@160@01) $Perm.Write $Perm.No))
    (ite
      (and
        (img@259@01 n$2@261@01)
        (and
          (Set_in (inv@258@01 n$2@261@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 n$2@261@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
(assert (=>
  (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
  (and
    (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01))))
(assert (or
  (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
  (not (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01)))))
(push) ; 4
; [then-branch: 50 | n$2@261@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@260@01, n$2@261@01) != Null | live]
; [else-branch: 50 | !(n$2@261@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@260@01, n$2@261@01) != Null) | live]
(push) ; 5
; [then-branch: 50 | n$2@261@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@260@01, n$2@261@01) != Null]
(assert (and
  (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
  (not (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null))))
; [eval] (n$2.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef161|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef162|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef163|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef164|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 n$2@261@01)
          (Set_in (inv@167@01 n$2@261@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 n$2@261@01)) (pTaken@252@01 n$2@261@01))
        $Perm.No)
      (ite (= n$2@261@01 x0@160@01) $Perm.Write $Perm.No))
    (ite
      (and
        (img@259@01 n$2@261@01)
        (and
          (Set_in (inv@258@01 n$2@261@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 n$2@261@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 50 | !(n$2@261@01 in g0@158@01 ∪ g1@159@01 && Lookup(next, sm@260@01, n$2@261@01) != Null)]
(assert (not
  (and
    (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
(assert (=>
  (and
    (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))
  (and
    (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null))))
  (and
    (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
    (not (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@261@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01)))
    (or
      (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))))
    (=>
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01)))
    (or
      (not
        (and
          (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
          (not
            (=
              ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01)
              $Ref.null))))
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) (Set_union g0@158@01 g1@159@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@310@13@310@33-aux|)))
(assert (forall ((n$2@261@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01)))
    (or
      (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
      (not (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))))
    (=>
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01)))
    (or
      (not
        (and
          (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
          (not
            (=
              ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01)
              $Ref.null))))
      (and
        (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
        (not
          (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))))
  :pattern ((Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@310@13@310@33-aux|)))
(assert (forall ((n$2@261@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01))
      (not
        (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) (Set_union g0@158@01 g1@159@01)))
  :pattern ((Set_in n$2@261@01 (Set_union g0@158@01 g1@159@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n$2@261@01) n$2@261@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@310@13@310@33|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))
  $Snap.unit))
; [eval] x.next == null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef161|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef162|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@260@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef163|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@260@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef164|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) x0@160@01) x0@160@01))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 x0@160@01)
          (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 x0@160@01)) (pTaken@252@01 x0@160@01))
        $Perm.No)
      $Perm.Write)
    (ite
      (and
        (img@259@01 x0@160@01)
        (and
          (Set_in (inv@258@01 x0@160@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 x0@160@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (= ($FVF.lookup_next (as sm@260@01  $FVF<next>) x0@160@01) $Ref.null))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))))
  $Snap.unit))
; [eval] old(x.next) == null ==> $$(g) == old($$(g))
; [eval] old(x.next) == null
; [eval] old(x.next)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (=
        ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef154|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef155|))))
(push) ; 3
(assert (not (and
  (img@168@01 x0@160@01)
  (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) $Ref.null))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 51 | Lookup(next, sm@246@01, x0@160@01) == Null | dead]
; [else-branch: 51 | Lookup(next, sm@246@01, x0@160@01) != Null | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 51 | Lookup(next, sm@246@01, x0@160@01) != Null]
(assert (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))))
  $Snap.unit))
; [eval] old(x.next) != null ==> (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next))))
; [eval] old(x.next) != null
; [eval] old(x.next)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (=
        ($FVF.lookup_next (as sm@246@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef154|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    :pattern (($FVF.lookup_next (as sm@246@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef155|))))
(push) ; 3
(assert (not (and
  (img@168@01 x0@160@01)
  (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; [then-branch: 52 | Lookup(next, sm@246@01, x0@160@01) != Null | live]
; [else-branch: 52 | Lookup(next, sm@246@01, x0@160@01) == Null | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 52 | Lookup(next, sm@246@01, x0@160@01) != Null]
; [eval] (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next))))
(declare-const v1@262@01 $Ref)
(declare-const v2@263@01 $Ref)
(push) ; 5
; [eval] edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next)))
; [eval] edge($$(g), v1, v2)
; [eval] $$(g)
(push) ; 6
(declare-const n@264@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@264@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 7
(declare-fun inv@265@01 ($Ref) $Ref)
(declare-fun img@266@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@264@01 $Ref) (n2@264@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@264@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n1@264@01) n1@264@01))
      (and
        (Set_in n2@264@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) n2@264@01) n2@264@01))
      (= n1@264@01 n2@264@01))
    (= n1@264@01 n2@264@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@264@01 $Ref)) (!
  (=>
    (Set_in n@264@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@265@01 n@264@01) n@264@01) (img@266@01 n@264@01)))
  :pattern ((Set_in n@264@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@265@01 n@264@01))
  :pattern ((img@266@01 n@264@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@265@01 r) r))
  :pattern ((inv@265@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) r) r))
  :pattern ((inv@265@01 r))
  :qid |quant-u-326|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@267@01 ((r $Ref) (v1@262@01 $Ref) (v2@263@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      (img@266@01 r)
      (= r (inv@265@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@268@01 ((r $Ref) (v1@262@01 $Ref) (v2@263@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      (img@266@01 r)
      (= r (inv@265@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@267@01 r v1@262@01 v2@263@01)))
    $Perm.No))
(define-fun pTaken@269@01 ((r $Ref) (v1@262@01 $Ref) (v2@263@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      (img@266@01 r)
      (= r (inv@265@01 r)))
    ($Perm.min
      (ite (= r x0@160@01) $Perm.Write $Perm.No)
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@267@01 r v1@262@01 v2@263@01))
        (pTaken@268@01 r v1@262@01 v2@263@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (pTaken@267@01 r v1@262@01 v2@263@01))
    $Perm.No)
  
  :qid |quant-u-328|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      (img@266@01 r)
      (= r (inv@265@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@267@01 r v1@262@01 v2@263@01))
      $Perm.No))
  
  :qid |quant-u-329|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@268@01 r v1@262@01 v2@263@01))
    $Perm.No)
  
  :qid |quant-u-330|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@268@01 r v1@262@01 v2@263@01) $Perm.No)
  
  :qid |quant-u-331|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      (img@266@01 r)
      (= r (inv@265@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@267@01 r v1@262@01 v2@263@01))
        (pTaken@268@01 r v1@262@01 v2@263@01))
      $Perm.No))
  
  :qid |quant-u-332|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@269@01 x0@160@01 v1@262@01 v2@263@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0,51s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@269@01 r v1@262@01 v2@263@01) $Perm.No)
  
  :qid |quant-u-334|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      (img@266@01 r)
      (= r (inv@265@01 r)))
    (=
      (-
        (-
          (- (/ (to_real 1) (to_real 2)) (pTaken@267@01 r v1@262@01 v2@263@01))
          (pTaken@268@01 r v1@262@01 v2@263@01))
        (pTaken@269@01 r v1@262@01 v2@263@01))
      $Perm.No))
  
  :qid |quant-u-335|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@270@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r)))
    (=>
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>))))
  :qid |qp.fvfDomDef169|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@264@01 $Ref)) (!
  (=>
    (Set_in n@264@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@265@01 n@264@01) n@264@01) (img@266@01 n@264@01)))
  :pattern ((Set_in n@264@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@265@01 n@264@01))
  :pattern ((img@266@01 n@264@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@265@01 r) r))
  :pattern ((inv@265@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r)))
    (=>
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>))))
  :qid |qp.fvfDomDef169|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) r) r))
    :pattern ((inv@265@01 r))
    :qid |quant-u-326|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
; [eval] edge(old($$(g)), v1, v2) && !(v1 == x && v2 == old(x.next))
; [eval] edge(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 6
(declare-const n@271@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@271@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 7
(declare-fun inv@272@01 ($Ref) $Ref)
(declare-fun img@273@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@271@01 $Ref) (n2@271@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@271@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n1@271@01) n1@271@01))
      (and
        (Set_in n2@271@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) n2@271@01) n2@271@01))
      (= n1@271@01 n2@271@01))
    (= n1@271@01 n2@271@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@271@01 $Ref)) (!
  (=>
    (Set_in n@271@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@272@01 n@271@01) n@271@01) (img@273@01 n@271@01)))
  :pattern ((Set_in n@271@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@272@01 n@271@01))
  :pattern ((img@273@01 n@271@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@273@01 r) (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@272@01 r) r))
  :pattern ((inv@272@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) r) r))
  :pattern ((inv@272@01 r))
  :qid |quant-u-337|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@274@01 ((r $Ref) (v1@262@01 $Ref) (v2@263@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
      (img@273@01 r)
      (= r (inv@272@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@274@01 r v1@262@01 v2@263@01))
    $Perm.No)
  
  :qid |quant-u-339|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@274@01 r v1@262@01 v2@263@01) $Perm.No)
  
  :qid |quant-u-340|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
      (img@273@01 r)
      (= r (inv@272@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@274@01 r v1@262@01 v2@263@01))
      $Perm.No))
  
  :qid |quant-u-341|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@275@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r)))
    (=>
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>))))
  :qid |qp.fvfDomDef172|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@275@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@271@01 $Ref)) (!
  (=>
    (Set_in n@271@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@272@01 n@271@01) n@271@01) (img@273@01 n@271@01)))
  :pattern ((Set_in n@271@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@272@01 n@271@01))
  :pattern ((img@273@01 n@271@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@273@01 r) (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@272@01 r) r))
  :pattern ((inv@272@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r)))
    (=>
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>))))
  :qid |qp.fvfDomDef172|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@275@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) r) r))
    :pattern ((inv@272@01 r))
    :qid |quant-u-337|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 53 | !(edge[Bool]($$(sm@275@01, g0@158@01 ∪ g1@159@01), v1@262@01, v2@263@01)) | live]
; [else-branch: 53 | edge[Bool]($$(sm@275@01, g0@158@01 ∪ g1@159@01), v1@262@01, v2@263@01) | live]
(push) ; 7
; [then-branch: 53 | !(edge[Bool]($$(sm@275@01, g0@158@01 ∪ g1@159@01), v1@262@01, v2@263@01))]
(assert (not
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 53 | edge[Bool]($$(sm@275@01, g0@158@01 ∪ g1@159@01), v1@262@01, v2@263@01)]
(assert (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))
; [eval] !(v1 == x && v2 == old(x.next))
; [eval] v1 == x && v2 == old(x.next)
; [eval] v1 == x
(push) ; 8
; [then-branch: 54 | v1@262@01 != x0@160@01 | live]
; [else-branch: 54 | v1@262@01 == x0@160@01 | live]
(push) ; 9
; [then-branch: 54 | v1@262@01 != x0@160@01]
(assert (not (= v1@262@01 x0@160@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 54 | v1@262@01 == x0@160@01]
(assert (= v1@262@01 x0@160@01))
; [eval] v2 == old(x.next)
; [eval] old(x.next)
(push) ; 10
(assert (not (and
  (img@168@01 x0@160@01)
  (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0,00s
; (get-info :all-statistics)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or (= v1@262@01 x0@160@01) (not (= v1@262@01 x0@160@01))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (=>
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
  (and
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
    (or (= v1@262@01 x0@160@01) (not (= v1@262@01 x0@160@01))))))
(assert (or
  (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
  (not
    (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@264@01 $Ref)) (!
  (=>
    (Set_in n@264@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@265@01 n@264@01) n@264@01) (img@266@01 n@264@01)))
  :pattern ((Set_in n@264@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@265@01 n@264@01))
  :pattern ((img@266@01 n@264@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@265@01 r) r))
  :pattern ((inv@265@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r)))
    (=>
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>))))
  :qid |qp.fvfDomDef169|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (forall ((n@271@01 $Ref)) (!
  (=>
    (Set_in n@271@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@272@01 n@271@01) n@271@01) (img@273@01 n@271@01)))
  :pattern ((Set_in n@271@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@272@01 n@271@01))
  :pattern ((img@273@01 n@271@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@273@01 r) (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@272@01 r) r))
  :pattern ((inv@272@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r)))
    (=>
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>))))
  :qid |qp.fvfDomDef172|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@275@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) r) r))
  :pattern ((inv@265@01 r))
  :qid |quant-u-326|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) r) r))
  :pattern ((inv@272@01 r))
  :qid |quant-u-337|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@262@01 $Ref) (v2@263@01 $Ref)) (!
  (and
    (=>
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
        (or (= v1@262@01 x0@160@01) (not (= v1@262@01 x0@160@01)))))
    (or
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
      (not
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))))
  :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@313@37@315@89-aux|)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@264@01 $Ref)) (!
  (=>
    (Set_in n@264@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@265@01 n@264@01) n@264@01) (img@266@01 n@264@01)))
  :pattern ((Set_in n@264@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@265@01 n@264@01))
  :pattern ((img@266@01 n@264@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@266@01 r) (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@265@01 r) r))
  :pattern ((inv@265@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r)))
    (=>
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@270@01  $FVF<next>))))
  :qid |qp.fvfDomDef169|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        (img@266@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@270@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@270@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (forall ((n@271@01 $Ref)) (!
  (=>
    (Set_in n@271@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@272@01 n@271@01) n@271@01) (img@273@01 n@271@01)))
  :pattern ((Set_in n@271@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@272@01 n@271@01))
  :pattern ((img@273@01 n@271@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@273@01 r) (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@272@01 r) r))
  :pattern ((inv@272@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r)))
    (=>
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@275@01  $FVF<next>))))
  :qid |qp.fvfDomDef172|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        (img@273@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@275@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@275@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef171|)))
(assert (=>
  (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) $Ref.null))
  (and
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@265@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@260@01  $FVF<next>) r) r))
      :pattern ((inv@265@01 r))
      :qid |quant-u-326|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@272@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@246@01  $FVF<next>) r) r))
      :pattern ((inv@272@01 r))
      :qid |quant-u-337|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
    (forall ((v1@262@01 $Ref) (v2@263@01 $Ref)) (!
      (and
        (=>
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
          (and
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
            (or (= v1@262@01 x0@160@01) (not (= v1@262@01 x0@160@01)))))
        (or
          (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
          (not
            (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))))
      :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@313@37@315@89-aux|)))))
(assert (=>
  (not (= ($FVF.lookup_next (as sm@246@01  $FVF<next>) x0@160@01) $Ref.null))
  (forall ((v1@262@01 $Ref) (v2@263@01 $Ref)) (!
    (=
      (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
      (and
        (edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@275@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01)
        (not
          (and
            (= v1@262@01 x0@160@01)
            (=
              v2@263@01
              ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01))))))
    :pattern ((edge<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@270@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@262@01 v2@263@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@313@37@315@89|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@254@01))))))))
  $Snap.unit))
; [eval] old(x.next) != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))))
; [eval] old(x.next) != null
; [eval] old(x.next)
(push) ; 3
(assert (not (and
  (img@168@01 x0@160@01)
  (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
  $Ref.null)))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
    $Ref.null))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; [then-branch: 55 | Lookup(next, First:(Second:(Second:(Second:($t@162@01)))), x0@160@01) != Null | live]
; [else-branch: 55 | Lookup(next, First:(Second:(Second:(Second:($t@162@01)))), x0@160@01) == Null | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 55 | Lookup(next, First:(Second:(Second:(Second:($t@162@01)))), x0@160@01) != Null]
(assert (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
    $Ref.null)))
; [eval] (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))))
(declare-const v1@276@01 $Ref)
(declare-const v2@277@01 $Ref)
(push) ; 5
; [eval] v1 != v2 ==> exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2)))
; [eval] v1 != v2
(push) ; 6
; [then-branch: 56 | v1@276@01 != v2@277@01 | live]
; [else-branch: 56 | v1@276@01 == v2@277@01 | live]
(push) ; 7
; [then-branch: 56 | v1@276@01 != v2@277@01]
(assert (not (= v1@276@01 v2@277@01)))
; [eval] exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2)))
; [eval] exists_path($$(g), v1, v2)
; [eval] $$(g)
(push) ; 8
(declare-const n@278@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@278@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 9
(declare-fun inv@279@01 ($Ref) $Ref)
(declare-fun img@280@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@281@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef175|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef176|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@278@01 $Ref) (n2@278@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@278@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) n1@278@01) n1@278@01))
      (and
        (Set_in n2@278@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) n2@278@01) n2@278@01))
      (= n1@278@01 n2@278@01))
    (= n1@278@01 n2@278@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@278@01 $Ref)) (!
  (=>
    (Set_in n@278@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@279@01 n@278@01) n@278@01) (img@280@01 n@278@01)))
  :pattern ((Set_in n@278@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@279@01 n@278@01))
  :pattern ((img@280@01 n@278@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@280@01 r) (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@279@01 r) r))
  :pattern ((inv@279@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) r) r))
  :pattern ((inv@279@01 r))
  :qid |quant-u-343|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@282@01 ((r $Ref) (v1@276@01 $Ref) (v2@277@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      (img@280@01 r)
      (= r (inv@279@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@283@01 ((r $Ref) (v1@276@01 $Ref) (v2@277@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      (img@280@01 r)
      (= r (inv@279@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@282@01 r v1@276@01 v2@277@01)))
    $Perm.No))
(define-fun pTaken@284@01 ((r $Ref) (v1@276@01 $Ref) (v2@277@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      (img@280@01 r)
      (= r (inv@279@01 r)))
    ($Perm.min
      (ite (= r x0@160@01) $Perm.Write $Perm.No)
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@282@01 r v1@276@01 v2@277@01))
        (pTaken@283@01 r v1@276@01 v2@277@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (pTaken@282@01 r v1@276@01 v2@277@01))
    $Perm.No)
  
  :qid |quant-u-345|))))
(check-sat)
; unsat
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      (img@280@01 r)
      (= r (inv@279@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@282@01 r v1@276@01 v2@277@01))
      $Perm.No))
  
  :qid |quant-u-346|))))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@283@01 r v1@276@01 v2@277@01))
    $Perm.No)
  
  :qid |quant-u-347|))))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@283@01 r v1@276@01 v2@277@01) $Perm.No)
  
  :qid |quant-u-348|))))
(check-sat)
; unsat
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      (img@280@01 r)
      (= r (inv@279@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@282@01 r v1@276@01 v2@277@01))
        (pTaken@283@01 r v1@276@01 v2@277@01))
      $Perm.No))
  
  :qid |quant-u-349|))))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@284@01 x0@160@01 v1@276@01 v2@277@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 9
; 0,51s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@284@01 r v1@276@01 v2@277@01) $Perm.No)
  
  :qid |quant-u-351|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      (img@280@01 r)
      (= r (inv@279@01 r)))
    (=
      (-
        (-
          (- (/ (to_real 1) (to_real 2)) (pTaken@282@01 r v1@276@01 v2@277@01))
          (pTaken@283@01 r v1@276@01 v2@277@01))
        (pTaken@284@01 r v1@276@01 v2@277@01))
      $Perm.No))
  
  :qid |quant-u-352|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@285@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r)))
    (=>
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>))))
  :qid |qp.fvfDomDef181|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef175|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef176|)))
(assert (forall ((n@278@01 $Ref)) (!
  (=>
    (Set_in n@278@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@279@01 n@278@01) n@278@01) (img@280@01 n@278@01)))
  :pattern ((Set_in n@278@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@279@01 n@278@01))
  :pattern ((img@280@01 n@278@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@280@01 r) (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@279@01 r) r))
  :pattern ((inv@279@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r)))
    (=>
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>))))
  :qid |qp.fvfDomDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) r) r))
    :pattern ((inv@279@01 r))
    :qid |quant-u-343|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
; [eval] exists_path(old($$(g)), v1, v2) && !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))
; [eval] exists_path(old($$(g)), v1, v2)
; [eval] old($$(g))
; [eval] $$(g)
(set-option :timeout 0)
(push) ; 8
(declare-const n@286@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@286@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 9
(declare-fun inv@287@01 ($Ref) $Ref)
(declare-fun img@288@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@289@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@289@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef183|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@286@01 $Ref) (n2@286@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@286@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) n1@286@01) n1@286@01))
      (and
        (Set_in n2@286@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) n2@286@01) n2@286@01))
      (= n1@286@01 n2@286@01))
    (= n1@286@01 n2@286@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) r) r))
  :pattern ((inv@287@01 r))
  :qid |quant-u-354|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@290@01 ((r $Ref) (v1@276@01 $Ref) (v2@277@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
      (img@288@01 r)
      (= r (inv@287@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@290@01 r v1@276@01 v2@277@01))
    $Perm.No)
  
  :qid |quant-u-356|))))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@290@01 r v1@276@01 v2@277@01) $Perm.No)
  
  :qid |quant-u-357|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
      (img@288@01 r)
      (= r (inv@287@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@290@01 r v1@276@01 v2@277@01))
      $Perm.No))
  
  :qid |quant-u-358|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@291@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@289@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) r) r))
    :pattern ((inv@287@01 r))
    :qid |quant-u-354|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 57 | !(exists_path[Bool]($$(sm@291@01, g0@158@01 ∪ g1@159@01), v1@276@01, v2@277@01)) | live]
; [else-branch: 57 | exists_path[Bool]($$(sm@291@01, g0@158@01 ∪ g1@159@01), v1@276@01, v2@277@01) | live]
(push) ; 9
; [then-branch: 57 | !(exists_path[Bool]($$(sm@291@01, g0@158@01 ∪ g1@159@01), v1@276@01, v2@277@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 57 | exists_path[Bool]($$(sm@291@01, g0@158@01 ∪ g1@159@01), v1@276@01, v2@277@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01))
; [eval] !(exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2))
; [eval] exists_path(old($$(g)), v1, x) && exists_path(old($$(g)), old(x.next), v2)
; [eval] exists_path(old($$(g)), v1, x)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 10
(declare-const n@292@01 $Ref)
(push) ; 11
; [eval] (n in refs)
(assert (Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 11
(declare-fun inv@293@01 ($Ref) $Ref)
(declare-fun img@294@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@295@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((n1@292@01 $Ref) (n2@292@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@292@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) n1@292@01) n1@292@01))
      (and
        (Set_in n2@292@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) n2@292@01) n2@292@01))
      (= n1@292@01 n2@292@01))
    (= n1@292@01 n2@292@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
  :pattern ((inv@293@01 r))
  :qid |quant-u-360|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@296@01 ((r $Ref) (v1@276@01 $Ref) (v2@277@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
      (img@294@01 r)
      (= r (inv@293@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@296@01 r v1@276@01 v2@277@01))
    $Perm.No)
  
  :qid |quant-u-362|))))
(check-sat)
; unknown
(pop) ; 11
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@296@01 r v1@276@01 v2@277@01) $Perm.No)
  
  :qid |quant-u-363|))))
(check-sat)
; unknown
(pop) ; 11
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
      (img@294@01 r)
      (= r (inv@293@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@296@01 r v1@276@01 v2@277@01))
      $Perm.No))
  
  :qid |quant-u-364|))))
(check-sat)
; unsat
(pop) ; 11
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@297@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 10
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
    :pattern ((inv@293@01 r))
    :qid |quant-u-360|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
(set-option :timeout 0)
(push) ; 10
; [then-branch: 58 | !(exists_path[Bool]($$(sm@297@01, g0@158@01 ∪ g1@159@01), v1@276@01, x0@160@01)) | live]
; [else-branch: 58 | exists_path[Bool]($$(sm@297@01, g0@158@01 ∪ g1@159@01), v1@276@01, x0@160@01) | live]
(push) ; 11
; [then-branch: 58 | !(exists_path[Bool]($$(sm@297@01, g0@158@01 ∪ g1@159@01), v1@276@01, x0@160@01))]
(assert (not
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)))
(pop) ; 11
(push) ; 11
; [else-branch: 58 | exists_path[Bool]($$(sm@297@01, g0@158@01 ∪ g1@159@01), v1@276@01, x0@160@01)]
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01))
; [eval] exists_path(old($$(g)), old(x.next), v2)
; [eval] old($$(g))
; [eval] $$(g)
(push) ; 12
(declare-const n@298@01 $Ref)
(push) ; 13
; [eval] (n in refs)
(assert (Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
(pop) ; 13
(declare-fun inv@299@01 ($Ref) $Ref)
(declare-fun img@300@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@301@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((n1@298@01 $Ref) (n2@298@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@298@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) n1@298@01) n1@298@01))
      (and
        (Set_in n2@298@01 (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) n2@298@01) n2@298@01))
      (= n1@298@01 n2@298@01))
    (= n1@298@01 n2@298@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
  :pattern ((inv@299@01 r))
  :qid |quant-u-366|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@302@01 ((r $Ref) (v1@276@01 $Ref) (v2@277@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
      (img@300@01 r)
      (= r (inv@299@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@302@01 r v1@276@01 v2@277@01))
    $Perm.No)
  
  :qid |quant-u-368|))))
(check-sat)
; unknown
(pop) ; 13
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@302@01 r v1@276@01 v2@277@01) $Perm.No)
  
  :qid |quant-u-369|))))
(check-sat)
; unknown
(pop) ; 13
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
      (img@300@01 r)
      (= r (inv@299@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@302@01 r v1@276@01 v2@277@01))
      $Perm.No))
  
  :qid |quant-u-370|))))
(check-sat)
; unsat
(pop) ; 13
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@303@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))
(pop) ; 12
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
    :pattern ((inv@299@01 r))
    :qid |quant-u-366|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
; [eval] old(x.next)
(set-option :timeout 0)
(push) ; 12
(assert (not (and
  (img@168@01 x0@160@01)
  (Set_in (inv@167@01 x0@160@01) (Set_union g0@158@01 g1@159@01)))))
(check-sat)
; unsat
(pop) ; 12
; 0,00s
; (get-info :all-statistics)
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
      :pattern ((inv@299@01 r))
      :qid |quant-u-366|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (=>
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
  (and
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
      :pattern ((inv@293@01 r))
      :qid |quant-u-360|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
          :pattern ((inv@299@01 r))
          :qid |quant-u-366|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01))))))
(assert (or
  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
  (not
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01))))
(pop) ; 7
(push) ; 7
; [else-branch: 56 | v1@276@01 == v2@277@01]
(assert (= v1@276@01 v2@277@01))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef175|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef176|)))
(assert (forall ((n@278@01 $Ref)) (!
  (=>
    (Set_in n@278@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@279@01 n@278@01) n@278@01) (img@280@01 n@278@01)))
  :pattern ((Set_in n@278@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@279@01 n@278@01))
  :pattern ((img@280@01 n@278@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@280@01 r) (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@279@01 r) r))
  :pattern ((inv@279@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r)))
    (=>
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>))))
  :qid |qp.fvfDomDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@289@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (=>
  (not (= v1@276@01 v2@277@01))
  (and
    (not (= v1@276@01 v2@277@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) r) r))
      :pattern ((inv@279@01 r))
      :qid |quant-u-343|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) r) r))
      :pattern ((inv@287@01 r))
      :qid |quant-u-354|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
    (=>
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
      (and
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
          :pattern ((inv@293@01 r))
          :qid |quant-u-360|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
                ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
              :pattern ((inv@299@01 r))
              :qid |quant-u-366|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)))))
    (or
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
      (not
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01))))))
; Joined path conditions
(assert (or (= v1@276@01 v2@277@01) (not (= v1@276@01 v2@277@01))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef175|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef176|)))
(assert (forall ((n@278@01 $Ref)) (!
  (=>
    (Set_in n@278@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@279@01 n@278@01) n@278@01) (img@280@01 n@278@01)))
  :pattern ((Set_in n@278@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@279@01 n@278@01))
  :pattern ((img@280@01 n@278@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@280@01 r) (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@279@01 r) r))
  :pattern ((inv@279@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r)))
    (=>
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>))))
  :qid |qp.fvfDomDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@289@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((v1@276@01 $Ref) (v2@277@01 $Ref)) (!
  (and
    (=>
      (not (= v1@276@01 v2@277@01))
      (and
        (not (= v1@276@01 v2@277@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) r) r))
          :pattern ((inv@279@01 r))
          :qid |quant-u-343|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) r) r))
          :pattern ((inv@287@01 r))
          :qid |quant-u-354|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
        (=>
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
          (and
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
                ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
              :pattern ((inv@293@01 r))
              :qid |quant-u-360|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
                    ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
                  :pattern ((inv@299@01 r))
                  :qid |quant-u-366|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)))))
        (or
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
          (not
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)))))
    (or (= v1@276@01 v2@277@01) (not (= v1@276@01 v2@277@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@316@38@320@128-aux|)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@281@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef175|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@281@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef176|)))
(assert (forall ((n@278@01 $Ref)) (!
  (=>
    (Set_in n@278@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@279@01 n@278@01) n@278@01) (img@280@01 n@278@01)))
  :pattern ((Set_in n@278@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@279@01 n@278@01))
  :pattern ((img@280@01 n@278@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@280@01 r) (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@279@01 r) r))
  :pattern ((inv@279@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r)))
    (=>
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@285@01  $FVF<next>))))
  :qid |qp.fvfDomDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
        (img@280@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@285@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@285@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@289@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@289@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef183|)))
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
        (img@288@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef187|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef188|)))
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@297@01  $FVF<next>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
        (img@294@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@297@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef189|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@297@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
    (=
      ($FVF.lookup_next (as sm@301@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@301@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef193|)))
(assert (forall ((n@298@01 $Ref)) (!
  (=>
    (Set_in n@298@01 (Set_union g0@158@01 g1@159@01))
    (and (= (inv@299@01 n@298@01) n@298@01) (img@300@01 n@298@01)))
  :pattern ((Set_in n@298@01 (Set_union g0@158@01 g1@159@01)))
  :pattern ((inv@299@01 n@298@01))
  :pattern ((img@300@01 n@298@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@300@01 r) (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01)))
    (= (inv@299@01 r) r))
  :pattern ((inv@299@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r)))
    (=>
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@303@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
        (img@300@01 r))
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01))))
    (=
      ($FVF.lookup_next (as sm@303@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
  :pattern (($FVF.lookup_next (as sm@303@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
      $Ref.null))
  (and
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
        $Ref.null))
    (forall ((v1@276@01 $Ref) (v2@277@01 $Ref)) (!
      (and
        (=>
          (not (= v1@276@01 v2@277@01))
          (and
            (not (= v1@276@01 v2@277@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@279@01 r) (Set_union g0@158@01 g1@159@01))
                ($FVF.loc_next ($FVF.lookup_next (as sm@281@01  $FVF<next>) r) r))
              :pattern ((inv@279@01 r))
              :qid |quant-u-343|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@287@01 r) (Set_union g0@158@01 g1@159@01))
                ($FVF.loc_next ($FVF.lookup_next (as sm@289@01  $FVF<next>) r) r))
              :pattern ((inv@287@01 r))
              :qid |quant-u-354|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
            (=>
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
              (and
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
                (forall ((r $Ref)) (!
                  (=>
                    (Set_in (inv@293@01 r) (Set_union g0@158@01 g1@159@01))
                    ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
                  :pattern ((inv@293@01 r))
                  :qid |quant-u-360|))
                ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))
                (=>
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
                  (and
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
                    (forall ((r $Ref)) (!
                      (=>
                        (Set_in (inv@299@01 r) (Set_union g0@158@01 g1@159@01))
                        ($FVF.loc_next ($FVF.lookup_next (as sm@301@01  $FVF<next>) r) r))
                      :pattern ((inv@299@01 r))
                      :qid |quant-u-366|))
                    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01))))
                (or
                  (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
                  (not
                    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)))))
            (or
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
              (not
                (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)))))
        (or (= v1@276@01 v2@277@01) (not (= v1@276@01 v2@277@01))))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01))
      :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@316@38@320@128-aux|)))))
(assert (not
  (=
    ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
    $Ref.null)))
(assert (=>
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01)
      $Ref.null))
  (forall ((v1@276@01 $Ref) (v2@277@01 $Ref)) (!
    (=>
      (not (= v1@276@01 v2@277@01))
      (=
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
        (and
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01)
          (not
            (and
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@297@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 x0@160@01)
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@303@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) x0@160@01) v2@277@01))))))
    :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@285@01  $FVF<next>)) (Set_union g0@158@01 g1@159@01)) v1@276@01 v2@277@01))
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@316@38@320@128|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale apply_TCFraming(g0, g1)
(declare-const $t@304@01 $Snap)
(assert (= $t@304@01 $Snap.unit))
; [eval] apply_TCFraming(g0, g1)
(set-option :timeout 0)
(push) ; 3
(declare-const n@305@01 $Ref)
(push) ; 4
; [eval] (n in g0)
(assert (Set_in n@305@01 g0@158@01))
(pop) ; 4
(declare-fun inv@306@01 ($Ref) $Ref)
(declare-fun img@307@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@308@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@308@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@308@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@308@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef199|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef200|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@305@01 $Ref) (n2@305@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@305@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@308@01  $FVF<next>) n1@305@01) n1@305@01))
      (and
        (Set_in n2@305@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@308@01  $FVF<next>) n2@305@01) n2@305@01))
      (= n1@305@01 n2@305@01))
    (= n1@305@01 n2@305@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@305@01 $Ref)) (!
  (=>
    (Set_in n@305@01 g0@158@01)
    (and (= (inv@306@01 n@305@01) n@305@01) (img@307@01 n@305@01)))
  :pattern ((Set_in n@305@01 g0@158@01))
  :pattern ((inv@306@01 n@305@01))
  :pattern ((img@307@01 n@305@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@307@01 r) (Set_in (inv@306@01 r) g0@158@01))
    (= (inv@306@01 r) r))
  :pattern ((inv@306@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@306@01 r) g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@308@01  $FVF<next>) r) r))
  :pattern ((inv@306@01 r))
  :qid |quant-u-372|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@309@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r) (= r (inv@306@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@310@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r) (= r (inv@306@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (- $Perm.Write (pTaken@309@01 r)))
    $Perm.No))
(define-fun pTaken@311@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r) (= r (inv@306@01 r)))
    ($Perm.min
      (ite (= r x0@160@01) $Perm.Write $Perm.No)
      (- (- $Perm.Write (pTaken@309@01 r)) (pTaken@310@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (pTaken@309@01 r))
    $Perm.No)
  
  :qid |quant-u-374|))))
(check-sat)
; unknown
(pop) ; 4
; 0,51s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@309@01 r) $Perm.No)
  
  :qid |quant-u-375|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r) (= r (inv@306@01 r)))
    (= (- $Perm.Write (pTaken@309@01 r)) $Perm.No))
  
  :qid |quant-u-376|))))
(check-sat)
; unknown
(pop) ; 4
; 0,51s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@310@01 r))
    $Perm.No)
  
  :qid |quant-u-377|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@310@01 r) $Perm.No)
  
  :qid |quant-u-378|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r) (= r (inv@306@01 r)))
    (= (- (- $Perm.Write (pTaken@309@01 r)) (pTaken@310@01 r)) $Perm.No))
  
  :qid |quant-u-379|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@311@01 x0@160@01)) $Perm.No)))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r) (= r (inv@306@01 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@309@01 r)) (pTaken@310@01 r))
        (pTaken@311@01 r))
      $Perm.No))
  
  :qid |quant-u-381|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@312@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@312@01  $FVF<next>)))
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r)))
    (=>
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r))
      (Set_in r ($FVF.domain_next (as sm@312@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@312@01  $FVF<next>))))
  :qid |qp.fvfDomDef205|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@312@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r)) (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@312@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@312@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef203|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef204|)))
(declare-const n@313@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n in g1)
(assert (Set_in n@313@01 g1@159@01))
(pop) ; 4
(declare-fun inv@314@01 ($Ref) $Ref)
(declare-fun img@315@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@316@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (< $Perm.No (- (/ (to_real 1) (to_real 2)) (pTaken@310@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@316@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (<
        $Perm.No
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@309@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@316@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef208|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@313@01 $Ref) (n2@313@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@313@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@316@01  $FVF<next>) n1@313@01) n1@313@01))
      (and
        (Set_in n2@313@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@316@01  $FVF<next>) n2@313@01) n2@313@01))
      (= n1@313@01 n2@313@01))
    (= n1@313@01 n2@313@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@313@01 $Ref)) (!
  (=>
    (Set_in n@313@01 g1@159@01)
    (and (= (inv@314@01 n@313@01) n@313@01) (img@315@01 n@313@01)))
  :pattern ((Set_in n@313@01 g1@159@01))
  :pattern ((inv@314@01 n@313@01))
  :pattern ((img@315@01 n@313@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@315@01 r) (Set_in (inv@314@01 r) g1@159@01))
    (= (inv@314@01 r) r))
  :pattern ((inv@314@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@314@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@316@01  $FVF<next>) r) r))
  :pattern ((inv@314@01 r))
  :qid |quant-u-383|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@317@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r) (= r (inv@314@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (- (/ (to_real 1) (to_real 2)) (pTaken@310@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@318@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r) (= r (inv@314@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@309@01 r))
        $Perm.No)
      (- $Perm.Write (pTaken@317@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (- (/ (to_real 1) (to_real 2)) (pTaken@310@01 r))
        $Perm.No)
      (pTaken@317@01 r))
    $Perm.No)
  
  :qid |quant-u-385|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r) (= r (inv@314@01 r)))
    (= (- $Perm.Write (pTaken@317@01 r)) $Perm.No))
  
  :qid |quant-u-386|))))
(check-sat)
; unknown
(pop) ; 4
; 0,51s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@309@01 r))
        $Perm.No)
      (pTaken@318@01 r))
    $Perm.No)
  
  :qid |quant-u-387|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r) (= r (inv@314@01 r)))
    (= (- (- $Perm.Write (pTaken@317@01 r)) (pTaken@318@01 r)) $Perm.No))
  
  :qid |quant-u-388|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@319@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@319@01  $FVF<next>)))
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r)))
    (=>
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r))
      (Set_in r ($FVF.domain_next (as sm@319@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@319@01  $FVF<next>))))
  :qid |qp.fvfDomDef212|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r))
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (< $Perm.No (- (/ (to_real 1) (to_real 2)) (pTaken@310@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef209|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (<
          $Perm.No
          (-
            (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
            (pTaken@309@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef211|)))
; [eval] (g1 intersection g0) == Set[Ref]()
; [eval] (g1 intersection g0)
; [eval] Set[Ref]()
(assert (apply_TCFraming%precondition ($Snap.combine
  ($SortWrappers.$FVF<next>To$Snap (as sm@312@01  $FVF<next>))
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@319@01  $FVF<next>))
    $Snap.unit)) g0@158@01 g1@159@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@308@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@308@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@308@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef199|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@308@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef200|)))
(assert (forall ((n@305@01 $Ref)) (!
  (=>
    (Set_in n@305@01 g0@158@01)
    (and (= (inv@306@01 n@305@01) n@305@01) (img@307@01 n@305@01)))
  :pattern ((Set_in n@305@01 g0@158@01))
  :pattern ((inv@306@01 n@305@01))
  :pattern ((img@307@01 n@305@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@307@01 r) (Set_in (inv@306@01 r) g0@158@01))
    (= (inv@306@01 r) r))
  :pattern ((inv@306@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@312@01  $FVF<next>)))
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r)))
    (=>
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r))
      (Set_in r ($FVF.domain_next (as sm@312@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@312@01  $FVF<next>))))
  :qid |qp.fvfDomDef205|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@312@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r)) (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@312@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@306@01 r) g0@158@01) (img@307@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@312@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef203|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@312@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef204|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (< $Perm.No (- (/ (to_real 1) (to_real 2)) (pTaken@310@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@316@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (<
        $Perm.No
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@309@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@316@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef207|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@316@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef208|)))
(assert (forall ((n@313@01 $Ref)) (!
  (=>
    (Set_in n@313@01 g1@159@01)
    (and (= (inv@314@01 n@313@01) n@313@01) (img@315@01 n@313@01)))
  :pattern ((Set_in n@313@01 g1@159@01))
  :pattern ((inv@314@01 n@313@01))
  :pattern ((img@315@01 n@313@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@315@01 r) (Set_in (inv@314@01 r) g1@159@01))
    (= (inv@314@01 r) r))
  :pattern ((inv@314@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@319@01  $FVF<next>)))
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r)))
    (=>
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r))
      (Set_in r ($FVF.domain_next (as sm@319@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@319@01  $FVF<next>))))
  :qid |qp.fvfDomDef212|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r))
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (< $Perm.No (- (/ (to_real 1) (to_real 2)) (pTaken@310@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef209|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@314@01 r) g1@159@01) (img@315@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (<
          $Perm.No
          (-
            (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
            (pTaken@309@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef211|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@306@01 r) g0@158@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@308@01  $FVF<next>) r) r))
    :pattern ((inv@306@01 r))
    :qid |quant-u-372|))
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@314@01 r) g1@159@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@316@01  $FVF<next>) r) r))
    :pattern ((inv@314@01 r))
    :qid |quant-u-383|))
  (apply_TCFraming%precondition ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@312@01  $FVF<next>))
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@319@01  $FVF<next>))
      $Snap.unit)) g0@158@01 g1@159@01)))
(assert (apply_TCFraming ($Snap.combine
  ($SortWrappers.$FVF<next>To$Snap (as sm@312@01  $FVF<next>))
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@319@01  $FVF<next>))
    $Snap.unit)) g0@158@01 g1@159@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] !((null in g0))
; [eval] (null in g0)
(set-option :timeout 0)
(push) ; 3
(assert (not (not (Set_in $Ref.null g0@158@01))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (not (Set_in $Ref.null g0@158@01)))
(declare-const n$3@320@01 $Ref)
(push) ; 3
; [eval] (n$3 in g0)
(assert (Set_in n$3@320@01 g0@158@01))
(declare-const sm@321@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@321@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@321@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@321@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(pop) ; 3
(declare-fun inv@322@01 ($Ref) $Ref)
(declare-fun img@323@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@321@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@321@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@321@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@321@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
; Nested auxiliary terms: non-globals
(declare-const sm@324@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$31@320@01 $Ref) (n$32@320@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$31@320@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$31@320@01) n$31@320@01))
      (and
        (Set_in n$32@320@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$32@320@01) n$32@320@01))
      (= n$31@320@01 n$32@320@01))
    (= n$31@320@01 n$32@320@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$3@320@01 $Ref)) (!
  (=>
    (Set_in n$3@320@01 g0@158@01)
    (and (= (inv@322@01 n$3@320@01) n$3@320@01) (img@323@01 n$3@320@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@321@01  $FVF<next>) n$3@320@01) n$3@320@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@323@01 r) (Set_in (inv@322@01 r) g0@158@01))
    (= (inv@322@01 r) r))
  :pattern ((inv@322@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@322@01 r) g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@322@01 r))
  :qid |quant-u-390|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@325@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@322@01 r) g0@158@01) (img@323@01 r) (= r (inv@322@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@326@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@322@01 r) g0@158@01) (img@323@01 r) (= r (inv@322@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (- $Perm.Write (pTaken@325@01 r)))
    $Perm.No))
(define-fun pTaken@327@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@322@01 r) g0@158@01) (img@323@01 r) (= r (inv@322@01 r)))
    ($Perm.min
      (ite (= r x0@160@01) $Perm.Write $Perm.No)
      (- (- $Perm.Write (pTaken@325@01 r)) (pTaken@326@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (pTaken@325@01 r))
    $Perm.No)
  
  :qid |quant-u-392|))))
(check-sat)
; unknown
(pop) ; 3
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@325@01 r) $Perm.No)
  
  :qid |quant-u-393|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@322@01 r) g0@158@01) (img@323@01 r) (= r (inv@322@01 r)))
    (= (- $Perm.Write (pTaken@325@01 r)) $Perm.No))
  
  :qid |quant-u-394|))))
(check-sat)
; unknown
(pop) ; 3
; 0,51s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (pTaken@326@01 r))
    $Perm.No)
  
  :qid |quant-u-395|))))
(check-sat)
; unknown
(pop) ; 3
; 0,51s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@326@01 r) $Perm.No)
  
  :qid |quant-u-396|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@322@01 r) g0@158@01) (img@323@01 r) (= r (inv@322@01 r)))
    (= (- (- $Perm.Write (pTaken@325@01 r)) (pTaken@326@01 r)) $Perm.No))
  
  :qid |quant-u-397|))))
(check-sat)
; unknown
(pop) ; 3
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@327@01 x0@160@01)) $Perm.No)))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@322@01 r) g0@158@01) (img@323@01 r) (= r (inv@322@01 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@325@01 r)) (pTaken@326@01 r))
        (pTaken@327@01 r))
      $Perm.No))
  
  :qid |quant-u-399|))))
(check-sat)
; unsat
(pop) ; 3
; 0,02s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$4: Ref :: { (n$4.next in g0) } { (n$4 in g0), n$4.next } (n$4 in g0) && n$4.next != null ==> (n$4.next in g0))
(declare-const n$4@328@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$4 in g0) && n$4.next != null ==> (n$4.next in g0)
; [eval] (n$4 in g0) && n$4.next != null
; [eval] (n$4 in g0)
(push) ; 4
; [then-branch: 59 | !(n$4@328@01 in g0@158@01) | live]
; [else-branch: 59 | n$4@328@01 in g0@158@01 | live]
(push) ; 5
; [then-branch: 59 | !(n$4@328@01 in g0@158@01)]
(assert (not (Set_in n$4@328@01 g0@158@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 59 | n$4@328@01 in g0@158@01]
(assert (Set_in n$4@328@01 g0@158@01))
; [eval] n$4.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef217|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef218|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef219|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef220|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 n$4@328@01)
          (Set_in (inv@167@01 n$4@328@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 n$4@328@01)) (pTaken@252@01 n$4@328@01))
        $Perm.No)
      (ite (= n$4@328@01 x0@160@01) $Perm.Write $Perm.No))
    (ite
      (and
        (img@259@01 n$4@328@01)
        (and
          (Set_in (inv@258@01 n$4@328@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 n$4@328@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
(assert (=>
  (Set_in n$4@328@01 g0@158@01)
  (and
    (Set_in n$4@328@01 g0@158@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))))
(assert (or (Set_in n$4@328@01 g0@158@01) (not (Set_in n$4@328@01 g0@158@01))))
(push) ; 4
; [then-branch: 60 | n$4@328@01 in g0@158@01 && Lookup(next, sm@324@01, n$4@328@01) != Null | live]
; [else-branch: 60 | !(n$4@328@01 in g0@158@01 && Lookup(next, sm@324@01, n$4@328@01) != Null) | live]
(push) ; 5
; [then-branch: 60 | n$4@328@01 in g0@158@01 && Lookup(next, sm@324@01, n$4@328@01) != Null]
(assert (and
  (Set_in n$4@328@01 g0@158@01)
  (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null))))
; [eval] (n$4.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef217|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef218|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef219|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef220|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 n$4@328@01)
          (Set_in (inv@167@01 n$4@328@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 n$4@328@01)) (pTaken@252@01 n$4@328@01))
        $Perm.No)
      (ite (= n$4@328@01 x0@160@01) $Perm.Write $Perm.No))
    (ite
      (and
        (img@259@01 n$4@328@01)
        (and
          (Set_in (inv@258@01 n$4@328@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 n$4@328@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 60 | !(n$4@328@01 in g0@158@01 && Lookup(next, sm@324@01, n$4@328@01) != Null)]
(assert (not
  (and
    (Set_in n$4@328@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
(assert (=>
  (and
    (Set_in n$4@328@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))
  (and
    (Set_in n$4@328@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$4@328@01 g0@158@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null))))
  (and
    (Set_in n$4@328@01 g0@158@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@328@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@328@01 g0@158@01)
      (and
        (Set_in n$4@328@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01)))
    (or (Set_in n$4@328@01 g0@158@01) (not (Set_in n$4@328@01 g0@158@01)))
    (=>
      (and
        (Set_in n$4@328@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))
      (and
        (Set_in n$4@328@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01)))
    (or
      (not
        (and
          (Set_in n$4@328@01 g0@158@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01)
              $Ref.null))))
      (and
        (Set_in n$4@328@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) g0@158@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22-aux|)))
(assert (forall ((n$4@328@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@328@01 g0@158@01)
      (and
        (Set_in n$4@328@01 g0@158@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01)))
    (or (Set_in n$4@328@01 g0@158@01) (not (Set_in n$4@328@01 g0@158@01)))
    (=>
      (and
        (Set_in n$4@328@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))
      (and
        (Set_in n$4@328@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01)))
    (or
      (not
        (and
          (Set_in n$4@328@01 g0@158@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01)
              $Ref.null))))
      (and
        (Set_in n$4@328@01 g0@158@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))))
  :pattern ((Set_in n$4@328@01 g0@158@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22-aux|)))
(push) ; 3
(assert (not (forall ((n$4@328@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@328@01 g0@158@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) g0@158@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) g0@158@01))
  :pattern ((Set_in n$4@328@01 g0@158@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22|))))
(check-sat)
; unsat
(pop) ; 3
; 0,02s
; (get-info :all-statistics)
(assert (forall ((n$4@328@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@328@01 g0@158@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) g0@158@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) g0@158@01))
  :pattern ((Set_in n$4@328@01 g0@158@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$4@328@01) n$4@328@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@344@13@344@22|)))
; [eval] !((null in g1))
; [eval] (null in g1)
(push) ; 3
(assert (not (not (Set_in $Ref.null g1@159@01))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (not (Set_in $Ref.null g1@159@01)))
(declare-const n$5@329@01 $Ref)
(push) ; 3
; [eval] (n$5 in g1)
(assert (Set_in n$5@329@01 g1@159@01))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@330@01 ($Ref) $Ref)
(declare-fun img@331@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@332@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (< $Perm.No (- (/ (to_real 1) (to_real 2)) (pTaken@326@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@332@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@332@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef221|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (<
        $Perm.No
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@325@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@332@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@332@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@332@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$51@329@01 $Ref) (n$52@329@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$51@329@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@332@01  $FVF<next>) n$51@329@01) n$51@329@01))
      (and
        (Set_in n$52@329@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@332@01  $FVF<next>) n$52@329@01) n$52@329@01))
      (= n$51@329@01 n$52@329@01))
    (= n$51@329@01 n$52@329@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$5@329@01 $Ref)) (!
  (=>
    (Set_in n$5@329@01 g1@159@01)
    (and (= (inv@330@01 n$5@329@01) n$5@329@01) (img@331@01 n$5@329@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$5@329@01) n$5@329@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@331@01 r) (Set_in (inv@330@01 r) g1@159@01))
    (= (inv@330@01 r) r))
  :pattern ((inv@330@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@330@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@332@01  $FVF<next>) r) r))
  :pattern ((inv@330@01 r))
  :qid |quant-u-401|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@333@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@330@01 r) g1@159@01) (img@331@01 r) (= r (inv@330@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (- (/ (to_real 1) (to_real 2)) (pTaken@326@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@334@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@330@01 r) g1@159@01) (img@331@01 r) (= r (inv@330@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@325@01 r))
        $Perm.No)
      (- $Perm.Write (pTaken@333@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (- (/ (to_real 1) (to_real 2)) (pTaken@326@01 r))
        $Perm.No)
      (pTaken@333@01 r))
    $Perm.No)
  
  :qid |quant-u-403|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@330@01 r) g1@159@01) (img@331@01 r) (= r (inv@330@01 r)))
    (= (- $Perm.Write (pTaken@333@01 r)) $Perm.No))
  
  :qid |quant-u-404|))))
(check-sat)
; unknown
(pop) ; 3
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (-
          (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
          (pTaken@325@01 r))
        $Perm.No)
      (pTaken@334@01 r))
    $Perm.No)
  
  :qid |quant-u-405|))))
(check-sat)
; unsat
(pop) ; 3
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@330@01 r) g1@159@01) (img@331@01 r) (= r (inv@330@01 r)))
    (= (- (- $Perm.Write (pTaken@333@01 r)) (pTaken@334@01 r)) $Perm.No))
  
  :qid |quant-u-406|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$6: Ref :: { (n$6.next in g1) } { (n$6 in g1), n$6.next } (n$6 in g1) && n$6.next != null ==> (n$6.next in g1))
(declare-const n$6@335@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$6 in g1) && n$6.next != null ==> (n$6.next in g1)
; [eval] (n$6 in g1) && n$6.next != null
; [eval] (n$6 in g1)
(push) ; 4
; [then-branch: 61 | !(n$6@335@01 in g1@159@01) | live]
; [else-branch: 61 | n$6@335@01 in g1@159@01 | live]
(push) ; 5
; [then-branch: 61 | !(n$6@335@01 in g1@159@01)]
(assert (not (Set_in n$6@335@01 g1@159@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 61 | n$6@335@01 in g1@159@01]
(assert (Set_in n$6@335@01 g1@159@01))
; [eval] n$6.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef217|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef218|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef219|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef220|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 n$6@335@01)
          (Set_in (inv@167@01 n$6@335@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 n$6@335@01)) (pTaken@252@01 n$6@335@01))
        $Perm.No)
      (ite (= n$6@335@01 x0@160@01) $Perm.Write $Perm.No))
    (ite
      (and
        (img@259@01 n$6@335@01)
        (and
          (Set_in (inv@258@01 n$6@335@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 n$6@335@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
(assert (=>
  (Set_in n$6@335@01 g1@159@01)
  (and
    (Set_in n$6@335@01 g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))))
(assert (or (Set_in n$6@335@01 g1@159@01) (not (Set_in n$6@335@01 g1@159@01))))
(push) ; 4
; [then-branch: 62 | n$6@335@01 in g1@159@01 && Lookup(next, sm@324@01, n$6@335@01) != Null | live]
; [else-branch: 62 | !(n$6@335@01 in g1@159@01 && Lookup(next, sm@324@01, n$6@335@01) != Null) | live]
(push) ; 5
; [then-branch: 62 | n$6@335@01 in g1@159@01 && Lookup(next, sm@324@01, n$6@335@01) != Null]
(assert (and
  (Set_in n$6@335@01 g1@159@01)
  (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null))))
; [eval] (n$6.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
    :qid |qp.fvfValDef217|))
  (forall ((r $Ref)) (!
    (=>
      (= r x0@160@01)
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
    :qid |qp.fvfValDef218|))
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01))))
      (=
        ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
    :qid |qp.fvfValDef219|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
      ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
    :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef220|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (img@168@01 n$6@335@01)
          (Set_in (inv@167@01 n$6@335@01) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 n$6@335@01)) (pTaken@252@01 n$6@335@01))
        $Perm.No)
      (ite (= n$6@335@01 x0@160@01) $Perm.Write $Perm.No))
    (ite
      (and
        (img@259@01 n$6@335@01)
        (and
          (Set_in (inv@258@01 n$6@335@01) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 n$6@335@01) x0@160@01))))
      (/ (to_real 1) (to_real 2))
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 62 | !(n$6@335@01 in g1@159@01 && Lookup(next, sm@324@01, n$6@335@01) != Null)]
(assert (not
  (and
    (Set_in n$6@335@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
(assert (=>
  (and
    (Set_in n$6@335@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))
  (and
    (Set_in n$6@335@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$6@335@01 g1@159@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null))))
  (and
    (Set_in n$6@335@01 g1@159@01)
    (not (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@168@01 r)
        (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
      (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
      false)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef217|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r x0@160@01)
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@259@01 r)
      (and
        (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
        (not (= (inv@258@01 r) x0@160@01))))
    (=
      ($FVF.lookup_next (as sm@324@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@324@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef220|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$6@335@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@335@01 g1@159@01)
      (and
        (Set_in n$6@335@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01)))
    (or (Set_in n$6@335@01 g1@159@01) (not (Set_in n$6@335@01 g1@159@01)))
    (=>
      (and
        (Set_in n$6@335@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))
      (and
        (Set_in n$6@335@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01)))
    (or
      (not
        (and
          (Set_in n$6@335@01 g1@159@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01)
              $Ref.null))))
      (and
        (Set_in n$6@335@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) g1@159@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22-aux|)))
(assert (forall ((n$6@335@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@335@01 g1@159@01)
      (and
        (Set_in n$6@335@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01)))
    (or (Set_in n$6@335@01 g1@159@01) (not (Set_in n$6@335@01 g1@159@01)))
    (=>
      (and
        (Set_in n$6@335@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))
      (and
        (Set_in n$6@335@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01)))
    (or
      (not
        (and
          (Set_in n$6@335@01 g1@159@01)
          (not
            (=
              ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01)
              $Ref.null))))
      (and
        (Set_in n$6@335@01 g1@159@01)
        (not
          (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))))
  :pattern ((Set_in n$6@335@01 g1@159@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22-aux|)))
(push) ; 3
(assert (not (forall ((n$6@335@01 $Ref)) (!
  (=>
    (and
      (Set_in n$6@335@01 g1@159@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) g1@159@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) g1@159@01))
  :pattern ((Set_in n$6@335@01 g1@159@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22|))))
(check-sat)
; unsat
(pop) ; 3
; 0,03s
; (get-info :all-statistics)
(assert (forall ((n$6@335@01 $Ref)) (!
  (=>
    (and
      (Set_in n$6@335@01 g1@159@01)
      (not
        (= ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) g1@159@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) g1@159@01))
  :pattern ((Set_in n$6@335@01 g1@159@01) ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n$6@335@01) n$6@335@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@345@13@345@22|)))
; [eval] (forall n$7: Ref :: { exists_path($$(g1), x1, n$7) } (n$7 in g1) ==> exists_path($$(g1), x1, n$7))
(declare-const n$7@336@01 $Ref)
(push) ; 3
; [eval] (n$7 in g1) ==> exists_path($$(g1), x1, n$7)
; [eval] (n$7 in g1)
(push) ; 4
; [then-branch: 63 | n$7@336@01 in g1@159@01 | live]
; [else-branch: 63 | !(n$7@336@01 in g1@159@01) | live]
(push) ; 5
; [then-branch: 63 | n$7@336@01 in g1@159@01]
(assert (Set_in n$7@336@01 g1@159@01))
; [eval] exists_path($$(g1), x1, n$7)
; [eval] $$(g1)
(push) ; 6
(declare-const n@337@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@337@01 g1@159@01))
(pop) ; 7
(declare-fun inv@338@01 ($Ref) $Ref)
(declare-fun img@339@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@337@01 $Ref) (n2@337@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@337@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n1@337@01) n1@337@01))
      (and
        (Set_in n2@337@01 g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) n2@337@01) n2@337@01))
      (= n1@337@01 n2@337@01))
    (= n1@337@01 n2@337@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@337@01 $Ref)) (!
  (=>
    (Set_in n@337@01 g1@159@01)
    (and (= (inv@338@01 n@337@01) n@337@01) (img@339@01 n@337@01)))
  :pattern ((Set_in n@337@01 g1@159@01))
  :pattern ((inv@338@01 n@337@01))
  :pattern ((img@339@01 n@337@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@339@01 r) (Set_in (inv@338@01 r) g1@159@01))
    (= (inv@338@01 r) r))
  :pattern ((inv@338@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@338@01 r) g1@159@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
  :pattern ((inv@338@01 r))
  :qid |quant-u-408|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@340@01 ((r $Ref) (n$7@336@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r) (= r (inv@338@01 r)))
    ($Perm.min
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@341@01 ((r $Ref) (n$7@336@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r) (= r (inv@338@01 r)))
    ($Perm.min
      (ite
        (and
          (img@259@01 r)
          (and
            (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
            (not (= (inv@258@01 r) x0@160@01))))
        (/ (to_real 1) (to_real 2))
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@340@01 r n$7@336@01)))
    $Perm.No))
(define-fun pTaken@342@01 ((r $Ref) (n$7@336@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r) (= r (inv@338@01 r)))
    ($Perm.min
      (ite (= r x0@160@01) $Perm.Write $Perm.No)
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@340@01 r n$7@336@01))
        (pTaken@341@01 r n$7@336@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r))
        $Perm.No)
      (pTaken@340@01 r n$7@336@01))
    $Perm.No)
  
  :qid |quant-u-410|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@340@01 r n$7@336@01) $Perm.No)
  
  :qid |quant-u-411|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r) (= r (inv@338@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@340@01 r n$7@336@01)) $Perm.No))
  
  :qid |quant-u-412|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@343@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)))
    (=>
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef228|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)) (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef226|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef227|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@337@01 $Ref)) (!
  (=>
    (Set_in n@337@01 g1@159@01)
    (and (= (inv@338@01 n@337@01) n@337@01) (img@339@01 n@337@01)))
  :pattern ((Set_in n@337@01 g1@159@01))
  :pattern ((inv@338@01 n@337@01))
  :pattern ((img@339@01 n@337@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@339@01 r) (Set_in (inv@338@01 r) g1@159@01))
    (= (inv@338@01 r) r))
  :pattern ((inv@338@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)))
    (=>
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)) (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef226|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef227|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@338@01 r) g1@159@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
    :pattern ((inv@338@01 r))
    :qid |quant-u-408|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01)))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 63 | !(n$7@336@01 in g1@159@01)]
(assert (not (Set_in n$7@336@01 g1@159@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((n@337@01 $Ref)) (!
  (=>
    (Set_in n@337@01 g1@159@01)
    (and (= (inv@338@01 n@337@01) n@337@01) (img@339@01 n@337@01)))
  :pattern ((Set_in n@337@01 g1@159@01))
  :pattern ((inv@338@01 n@337@01))
  :pattern ((img@339@01 n@337@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@339@01 r) (Set_in (inv@338@01 r) g1@159@01))
    (= (inv@338@01 r) r))
  :pattern ((inv@338@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)))
    (=>
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)) (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef226|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef227|)))
(assert (=>
  (Set_in n$7@336@01 g1@159@01)
  (and
    (Set_in n$7@336@01 g1@159@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@338@01 r) g1@159@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
      :pattern ((inv@338@01 r))
      :qid |quant-u-408|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01))))
; Joined path conditions
(assert (or (not (Set_in n$7@336@01 g1@159@01)) (Set_in n$7@336@01 g1@159@01)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@337@01 $Ref)) (!
  (=>
    (Set_in n@337@01 g1@159@01)
    (and (= (inv@338@01 n@337@01) n@337@01) (img@339@01 n@337@01)))
  :pattern ((Set_in n@337@01 g1@159@01))
  :pattern ((inv@338@01 n@337@01))
  :pattern ((img@339@01 n@337@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@339@01 r) (Set_in (inv@338@01 r) g1@159@01))
    (= (inv@338@01 r) r))
  :pattern ((inv@338@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)))
    (=>
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@343@01  $FVF<next>))))
  :qid |qp.fvfDomDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (ite
        (and
          (img@168@01 r)
          (Set_in (inv@167@01 r) (Set_union g0@158@01 g1@159@01)))
        (< $Perm.No (- (- $Perm.Write (pTaken@247@01 r)) (pTaken@252@01 r)))
        false))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r)) (= r x0@160@01))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g1@159@01) (img@339@01 r))
      (and
        (img@259@01 r)
        (and
          (Set_in (inv@258@01 r) (Set_union g0@158@01 g1@159@01))
          (not (= (inv@258@01 r) x0@160@01)))))
    (=
      ($FVF.lookup_next (as sm@343@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r)))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r))
  :qid |qp.fvfValDef226|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@162@01))))) r) r)
    ($FVF.loc_next ($FVF.lookup_next (as sm@255@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@254@01))))) r) r))
  :pattern (($FVF.lookup_next (as sm@343@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef227|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$7@336@01 $Ref)) (!
  (and
    (=>
      (Set_in n$7@336@01 g1@159@01)
      (and
        (Set_in n$7@336@01 g1@159@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@338@01 r) g1@159@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@324@01  $FVF<next>) r) r))
          :pattern ((inv@338@01 r))
          :qid |quant-u-408|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01)))
    (or (not (Set_in n$7@336@01 g1@159@01)) (Set_in n$7@336@01 g1@159@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@336@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@347@13@347@34-aux|)))
(assert (forall ((n$7@336@01 $Ref)) (!
  (=>
    (Set_in n$7@336@01 g1@159@01)
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@336@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@347@13@347@34_precondition|)))
(push) ; 3
(assert (not (forall ((n$7@336@01 $Ref)) (!
  (=>
    (and
      (=>
        (Set_in n$7@336@01 g1@159@01)
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01))
      (Set_in n$7@336@01 g1@159@01))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@336@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@343@01  $FVF<next>)) g1@159@01) x1@161@01 n$7@336@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/delete_edge1.vpr@347@13@347@34|))))
(check-sat)
; ---------- unlink_dags ----------
(declare-const g@344@01 Set<$Ref>)
; ---------- unjoin_dags ----------
(declare-const g0@345@01 Set<$Ref>)
