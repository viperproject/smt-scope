(get-info :version)
; (:version "4.8.7")
; Started: 2024-11-17 20:14:38
; Silicon.version: 1.1-SNAPSHOT (4d756c79+)
; Input file: /silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Set<$Ref> 0)
(declare-sort Set<Edge> 0)
(declare-sort Set<$Snap> 0)
(declare-sort FramingWisdoms 0)
(declare-sort Edge 0)
(declare-sort TrClo 0)
(declare-sort $FVF<next> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<Edge>To$Snap (Set<Edge>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Edge> ($Snap) Set<Edge>)
(assert (forall ((x Set<Edge>)) (!
    (= x ($SortWrappers.$SnapToSet<Edge>($SortWrappers.Set<Edge>To$Snap x)))
    :pattern (($SortWrappers.Set<Edge>To$Snap x))
    :qid |$Snap.$SnapToSet<Edge>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Edge>To$Snap($SortWrappers.$SnapToSet<Edge> x)))
    :pattern (($SortWrappers.$SnapToSet<Edge> x))
    :qid |$Snap.Set<Edge>To$SnapToSet<Edge>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.FramingWisdomsTo$Snap (FramingWisdoms) $Snap)
(declare-fun $SortWrappers.$SnapToFramingWisdoms ($Snap) FramingWisdoms)
(assert (forall ((x FramingWisdoms)) (!
    (= x ($SortWrappers.$SnapToFramingWisdoms($SortWrappers.FramingWisdomsTo$Snap x)))
    :pattern (($SortWrappers.FramingWisdomsTo$Snap x))
    :qid |$Snap.$SnapToFramingWisdomsTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.FramingWisdomsTo$Snap($SortWrappers.$SnapToFramingWisdoms x)))
    :pattern (($SortWrappers.$SnapToFramingWisdoms x))
    :qid |$Snap.FramingWisdomsTo$SnapToFramingWisdoms|
    )))
(declare-fun $SortWrappers.EdgeTo$Snap (Edge) $Snap)
(declare-fun $SortWrappers.$SnapToEdge ($Snap) Edge)
(assert (forall ((x Edge)) (!
    (= x ($SortWrappers.$SnapToEdge($SortWrappers.EdgeTo$Snap x)))
    :pattern (($SortWrappers.EdgeTo$Snap x))
    :qid |$Snap.$SnapToEdgeTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.EdgeTo$Snap($SortWrappers.$SnapToEdge x)))
    :pattern (($SortWrappers.$SnapToEdge x))
    :qid |$Snap.EdgeTo$SnapToEdge|
    )))
(declare-fun $SortWrappers.TrCloTo$Snap (TrClo) $Snap)
(declare-fun $SortWrappers.$SnapToTrClo ($Snap) TrClo)
(assert (forall ((x TrClo)) (!
    (= x ($SortWrappers.$SnapToTrClo($SortWrappers.TrCloTo$Snap x)))
    :pattern (($SortWrappers.TrCloTo$Snap x))
    :qid |$Snap.$SnapToTrCloTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.TrCloTo$Snap($SortWrappers.$SnapToTrClo x)))
    :pattern (($SortWrappers.$SnapToTrClo x))
    :qid |$Snap.TrCloTo$SnapToTrClo|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<next>To$Snap ($FVF<next>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<next> ($Snap) $FVF<next>)
(assert (forall ((x $FVF<next>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<next>($SortWrappers.$FVF<next>To$Snap x)))
    :pattern (($SortWrappers.$FVF<next>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<next>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<next>To$Snap($SortWrappers.$SnapTo$FVF<next> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<next> x))
    :qid |$Snap.$FVF<next>To$SnapTo$FVF<next>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<Edge>) Int)
(declare-const Set_empty Set<Edge>)
(declare-fun Set_in (Edge Set<Edge>) Bool)
(declare-fun Set_singleton (Edge) Set<Edge>)
(declare-fun Set_unionone (Set<Edge> Edge) Set<Edge>)
(declare-fun Set_union (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_intersection (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_difference (Set<Edge> Set<Edge>) Set<Edge>)
(declare-fun Set_subset (Set<Edge> Set<Edge>) Bool)
(declare-fun Set_equal (Set<Edge> Set<Edge>) Bool)
(declare-fun Set_skolem_diff (Set<Edge> Set<Edge>) Edge)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
(declare-fun exists_path<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_path_<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun exists_spath<Bool> (Set<Edge> Set<$Ref> $Ref) Bool)
(declare-fun apply_noExit<Bool> (Set<Edge> Set<$Ref> Set<$Ref>) Bool)
(declare-fun inst_uReach<Set<Ref>> (Set<Edge> $Ref) Set<$Ref>)
(declare-fun acyclic_graph<Bool> (Set<Edge>) Bool)
(declare-fun unshared_graph<Bool> (Set<Edge>) Bool)
(declare-fun func_graph<Bool> (Set<Edge>) Bool)
(declare-fun edge<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun edge_<Bool> (Set<Edge> $Ref $Ref) Bool)
(declare-fun edge_pred<Ref> (Edge) $Ref)
(declare-fun edge_succ<Ref> (Edge) $Ref)
(declare-fun create_edge<Edge> ($Ref $Ref) Edge)
(declare-fun create_edge_<Edge> ($Ref $Ref) Edge)
; /field_value_functions_declarations.smt2 [next: Ref]
(declare-fun $FVF.domain_next ($FVF<next>) Set<$Ref>)
(declare-fun $FVF.lookup_next ($FVF<next> $Ref) $Ref)
(declare-fun $FVF.after_next ($FVF<next> $FVF<next>) Bool)
(declare-fun $FVF.loc_next ($Ref $Ref) Bool)
(declare-fun $FVF.perm_next ($FPM $Ref) $Perm)
(declare-const $fvfTOP_next $FVF<next>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun $$ ($Snap Set<$Ref>) Set<Edge>)
(declare-fun $$%limited ($Snap Set<$Ref>) Set<Edge>)
(declare-fun $$%stateless (Set<$Ref>) Bool)
(declare-fun $$%precondition ($Snap Set<$Ref>) Bool)
(declare-fun apply_TCFraming ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_TCFraming%limited ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_TCFraming%stateless (Set<$Ref> Set<$Ref>) Bool)
(declare-fun apply_TCFraming%precondition ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun is_global_sroot ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun is_global_sroot%limited ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun is_global_sroot%stateless (Set<$Ref> Set<$Ref>) Bool)
(declare-fun is_global_sroot%precondition ($Snap Set<$Ref> Set<$Ref>) Bool)
(declare-fun acyclic_list_segment ($Snap Set<$Ref>) Bool)
(declare-fun acyclic_list_segment%limited ($Snap Set<$Ref>) Bool)
(declare-fun acyclic_list_segment%stateless (Set<$Ref>) Bool)
(declare-fun acyclic_list_segment%precondition ($Snap Set<$Ref>) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Edge>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Edge)) (!
  (not (Set_in o (as Set_empty  Set<Edge>)))
  :pattern ((Set_in o (as Set_empty  Set<Edge>)))
  )))
(assert (forall ((s Set<Edge>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Edge>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Edge))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Edge)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Edge) (o Edge)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Edge)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Edge>) (x Edge) (o Edge)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Edge>) (x Edge) (y Edge)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (x Edge)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (o Edge)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>) (y Edge)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=
    (Set_subset a b)
    (forall ((o Edge)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Edge>) (b Set<Edge>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((EG Set<Edge>) (p $Ref) (s $Ref)) (!
  (= (edge<Bool> EG p s) (edge_<Bool> EG p s))
  :pattern ((edge<Bool> EG p s))
  :qid |prog.ax_EdgeSynonim|)))
(assert (forall ((EG Set<Edge>) (p $Ref) (s $Ref)) (!
  (= (edge_<Bool> EG p s) (Set_in (create_edge<Edge> p s) EG))
  :pattern ((Set_in (create_edge<Edge> p s) EG))
  :pattern ((edge<Bool> EG p s))
  :qid |prog.ax_Edge|)))
(assert (forall ((EG Set<Edge>) (U Set<$Ref>) (M Set<$Ref>)) (!
  (=>
    (and
      (apply_noExit<Bool> EG U M)
      (forall ((u $Ref) (v $Ref)) (!
        (=>
          (and (Set_in u M) (and (Set_in v U) (not (Set_in v M))))
          (not (edge<Bool> EG u v)))
        :pattern ((edge<Bool> EG u v))
        :pattern ((Set_in u M) (Set_in v M))
        )))
    (forall ((u $Ref) (v $Ref)) (!
      (=>
        (and (Set_in u M) (and (Set_in v U) (not (Set_in v M))))
        (not (exists_path<Bool> EG u v)))
      :pattern ((exists_path<Bool> EG u v))
      :pattern ((Set_in u M) (Set_in v M))
      )))
  :pattern ((apply_noExit<Bool> EG U M))
  :qid |prog.ax_NoExit|)))
(assert (forall ((EG Set<Edge>) (x $Ref) (v $Ref)) (!
  (= (Set_in v (inst_uReach<Set<Ref>> EG x)) (exists_path<Bool> EG x v))
  :pattern ((Set_in v (inst_uReach<Set<Ref>> EG x)))
  :pattern ((exists_path<Bool> EG x v))
  :qid |prog.ax_instantiation_uReach|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (= (exists_path<Bool> EG start end) (exists_path_<Bool> EG start end))
  :pattern ((exists_path<Bool> EG start end))
  :qid |prog.ax_Alias|)))
(assert (forall ((EG Set<Edge>) (start $Ref) (end $Ref)) (!
  (=
    (exists_path_<Bool> EG start end)
    (or
      (= start end)
      (exists ((w $Ref)) (!
        (and (edge<Bool> EG start w) (exists_path_<Bool> EG w end))
        :pattern ((edge<Bool> EG start w))
        :pattern ((exists_path_<Bool> EG w end))
        ))))
  :pattern ((exists_path<Bool> EG start end))
  :pattern ((edge<Bool> EG start end))
  :qid |prog.ax_ExistsPath|)))
(assert (forall ((EG Set<Edge>) (u $Ref) (v $Ref) (w $Ref)) (!
  (=>
    (and (exists_path_<Bool> EG u w) (exists_path_<Bool> EG w v))
    (exists_path_<Bool> EG u v))
  :pattern ((exists_path<Bool> EG u w) (exists_path<Bool> EG w v))
  :qid |prog.ax_ExistsPathTrans|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (acyclic_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref)) (!
      (or (not (edge<Bool> EG v1 v2)) (not (exists_path<Bool> EG v2 v1)))
      :pattern ((edge<Bool> EG v1 v2))
      :pattern ((exists_path<Bool> EG v2 v1))
      )))
  :pattern ((acyclic_graph<Bool> EG))
  :qid |prog.ax_AcyclicGraph|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (unshared_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref) (v $Ref)) (!
      (=> (and (edge<Bool> EG v1 v) (edge<Bool> EG v2 v)) (= v1 v2))
      :pattern ((edge<Bool> EG v1 v) (edge<Bool> EG v2 v))
      )))
  :pattern ((unshared_graph<Bool> EG))
  :qid |prog.ax_UnsharedGraph|)))
(assert (forall ((EG Set<Edge>)) (!
  (=
    (func_graph<Bool> EG)
    (forall ((v1 $Ref) (v2 $Ref) (v $Ref)) (!
      (=> (and (edge<Bool> EG v v1) (edge<Bool> EG v v2)) (= v1 v2))
      :pattern ((edge<Bool> EG v v1) (edge<Bool> EG v v2))
      )))
  :pattern ((func_graph<Bool> EG))
  :qid |prog.ax_FuncGraph|)))
(assert (forall ((EG Set<Edge>) (from Set<$Ref>) (to $Ref)) (!
  (=
    (exists_spath<Bool> EG from to)
    (exists ((f $Ref)) (!
      (and (Set_in f from) (exists_path<Bool> EG f to))
      :pattern ((Set_in f from))
      :pattern ((exists_path<Bool> EG f to))
      )))
  :pattern ((exists_spath<Bool> EG from to))
  :qid |prog.ax_ExistsSetPath|)))
(assert (forall ((g0 Set<$Ref>) (g1 Set<$Ref>)) (!
  (=>
    (Set_equal (Set_intersection g0 g1) (as Set_empty  Set<$Ref>))
    (forall ((r $Ref)) (!
      (=> (and (Set_in r g0) (Set_in r g1)) (Set_in r (as Set_empty  Set<$Ref>)))
      :pattern ((Set_in r g0) (Set_in r g1))
      )))
  :pattern ((Set_intersection g0 g1))
  :qid |prog.ax_SetIntersection|)))
(assert (forall ((g Set<Edge>) (e Edge)) (!
  (=>
    (Set_in e g)
    (= (create_edge<Edge> (edge_pred<Ref> e) (edge_succ<Ref> e)) e))
  :pattern ((Set_in e g))
  :qid |prog.ax_EdgeReverse|)))
(assert (forall ((p $Ref) (s $Ref)) (!
  (and
    (= (edge_pred<Ref> (create_edge<Edge> p s)) p)
    (= (edge_succ<Ref> (create_edge<Edge> p s)) s))
  :pattern ((create_edge<Edge> p s))
  :qid |prog.edge_injectivity|)))
; /field_value_functions_axioms.smt2 [next: Ref]
(assert (forall ((vs $FVF<next>) (ws $FVF<next>)) (!
    (=>
      (and
        (Set_equal ($FVF.domain_next vs) ($FVF.domain_next ws))
        (forall ((x $Ref)) (!
          (=>
            (Set_in x ($FVF.domain_next vs))
            (= ($FVF.lookup_next vs x) ($FVF.lookup_next ws x)))
          :pattern (($FVF.lookup_next vs x) ($FVF.lookup_next ws x))
          :qid |qp.$FVF<next>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<next>To$Snap vs)
              ($SortWrappers.$FVF<next>To$Snap ws)
              )
    :qid |qp.$FVF<next>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_next pm r))
    :pattern (($FVF.perm_next pm r)))))
(assert (forall ((r $Ref) (f $Ref)) (!
    (= ($FVF.loc_next f r) true)
    :pattern (($FVF.loc_next f r)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun inv@12@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@13@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun sm@11@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun sm@14@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun inv@20@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@21@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@25@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@26@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@33@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@34@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@37@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@38@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@56@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@57@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun inv@60@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@61@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun sm@19@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@22@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@27@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@35@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@40@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@58@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@63@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun inv@78@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@79@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun sm@77@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun sm@80@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun inv@84@00 ($Snap Set<$Ref> Set<$Ref> $Ref) $Ref)
(declare-fun img@85@00 ($Snap Set<$Ref> Set<$Ref> $Ref) Bool)
(declare-fun sm@86@00 ($Snap Set<$Ref> Set<$Ref>) $FVF<next>)
(declare-fun inv@89@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@90@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun sm@88@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun sm@91@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun inv@94@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@95@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun inv@98@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@99@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun inv@103@00 ($Snap Set<$Ref> $Ref) $Ref)
(declare-fun img@104@00 ($Snap Set<$Ref> $Ref) Bool)
(declare-fun sm@96@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun sm@101@00 ($Snap Set<$Ref>) $FVF<next>)
(declare-fun sm@106@00 ($Snap Set<$Ref>) $FVF<next>)
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (= ($$%limited s@$ refs@0@00) ($$ s@$ refs@0@00))
  :pattern (($$ s@$ refs@0@00))
  :qid |quant-u-0|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  ($$%stateless refs@0@00)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-1|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) (and
    (forall ((n@10@00 $Ref)) (!
      (=>
        (Set_in n@10@00 refs@0@00)
        (and
          (= (inv@12@00 s@$ refs@0@00 n@10@00) n@10@00)
          (img@13@00 s@$ refs@0@00 n@10@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) n@10@00) n@10@00))
      :qid |quant-u-9|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@13@00 s@$ refs@0@00 r)
          (Set_in (inv@12@00 s@$ refs@0@00 r) refs@0@00))
        (= (inv@12@00 s@$ refs@0@00 r) r))
      :pattern ((inv@12@00 s@$ refs@0@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@11@00 s@$ refs@0@00) r))
      :qid |qp.fvfResTrgDef0|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@13@00 s@$ refs@0@00 r)
          (Set_in (inv@12@00 s@$ refs@0@00 r) refs@0@00))
        (=
          ($FVF.lookup_next (sm@14@00 s@$ refs@0@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r)))
      :pattern (($FVF.lookup_next (sm@14@00 s@$ refs@0@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r))
      :qid |qp.fvfValDef1|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> s@$) r) r)
      :pattern (($FVF.lookup_next (sm@14@00 s@$ refs@0@00) r))
      :qid |qp.fvfResTrgDef2|))
    (=>
      ($$%precondition s@$ refs@0@00)
      (forall ((p $Ref) (s $Ref)) (!
        (=
          (and
            (Set_in p refs@0@00)
            (and
              (Set_in s refs@0@00)
              (= ($FVF.lookup_next (sm@14@00 s@$ refs@0@00) p) s)))
          (Set_in (create_edge<Edge> p s) result@1@00))
        :pattern ((create_edge<Edge> p s))
        )))))
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-11|)))
(assert (forall ((s@$ $Snap) (refs@0@00 Set<$Ref>)) (!
  (let ((result@1@00 ($$%limited s@$ refs@0@00))) true)
  :pattern (($$%limited s@$ refs@0@00))
  :qid |quant-u-12|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (=
    (apply_TCFraming%limited s@$ g0@2@00 g1@3@00)
    (apply_TCFraming s@$ g0@2@00 g1@3@00))
  :pattern ((apply_TCFraming s@$ g0@2@00 g1@3@00))
  :qid |quant-u-2|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (apply_TCFraming%stateless g0@2@00 g1@3@00)
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-3|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (and
    (forall ((n@18@00 $Ref)) (!
      (=>
        (Set_in n@18@00 g0@2@00)
        (and
          (= (inv@20@00 s@$ g0@2@00 g1@3@00 n@18@00) n@18@00)
          (img@21@00 s@$ g0@2@00 g1@3@00 n@18@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) n@18@00) n@18@00))
      :qid |quant-u-14|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@21@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (= (inv@20@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@20@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n$1@24@00 $Ref)) (!
      (=>
        (Set_in n$1@24@00 g1@3@00)
        (and
          (= (inv@25@00 s@$ g0@2@00 g1@3@00 n$1@24@00) n$1@24@00)
          (img@26@00 s@$ g0@2@00 g1@3@00 n$1@24@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) n$1@24@00) n$1@24@00))
      :qid |quant-u-17|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@26@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@25@00 s@$ g0@2@00 g1@3@00 r) g1@3@00))
        (= (inv@25@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@25@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@32@00 $Ref)) (!
      (=>
        (Set_in n@32@00 g0@2@00)
        (and
          (= (inv@33@00 s@$ g0@2@00 g1@3@00 n@32@00) n@32@00)
          (img@34@00 s@$ g0@2@00 g1@3@00 n@32@00)))
      :pattern ((Set_in n@32@00 g0@2@00))
      :pattern ((inv@33@00 s@$ g0@2@00 g1@3@00 n@32@00))
      :pattern ((img@34@00 s@$ g0@2@00 g1@3@00 n@32@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@34@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@33@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (= (inv@33@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@33@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@36@00 $Ref)) (!
      (=>
        (Set_in n@36@00 (Set_union g0@2@00 g1@3@00))
        (and
          (= (inv@37@00 s@$ g0@2@00 g1@3@00 n@36@00) n@36@00)
          (img@38@00 s@$ g0@2@00 g1@3@00 n@36@00)))
      :pattern ((Set_in n@36@00 (Set_union g0@2@00 g1@3@00)))
      :pattern ((inv@37@00 s@$ g0@2@00 g1@3@00 n@36@00))
      :pattern ((img@38@00 s@$ g0@2@00 g1@3@00 n@36@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@38@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@37@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00)))
        (= (inv@37@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@37@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@55@00 $Ref)) (!
      (=>
        (Set_in n@55@00 g1@3@00)
        (and
          (= (inv@56@00 s@$ g0@2@00 g1@3@00 n@55@00) n@55@00)
          (img@57@00 s@$ g0@2@00 g1@3@00 n@55@00)))
      :pattern ((Set_in n@55@00 g1@3@00))
      :pattern ((inv@56@00 s@$ g0@2@00 g1@3@00 n@55@00))
      :pattern ((img@57@00 s@$ g0@2@00 g1@3@00 n@55@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@57@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@56@00 s@$ g0@2@00 g1@3@00 r) g1@3@00))
        (= (inv@56@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@56@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@59@00 $Ref)) (!
      (=>
        (Set_in n@59@00 (Set_union g1@3@00 g0@2@00))
        (and
          (= (inv@60@00 s@$ g0@2@00 g1@3@00 n@59@00) n@59@00)
          (img@61@00 s@$ g0@2@00 g1@3@00 n@59@00)))
      :pattern ((Set_in n@59@00 (Set_union g1@3@00 g0@2@00)))
      :pattern ((inv@60@00 s@$ g0@2@00 g1@3@00 n@59@00))
      :pattern ((img@61@00 s@$ g0@2@00 g1@3@00 n@59@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@61@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@60@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00)))
        (= (inv@60@00 s@$ g0@2@00 g1@3@00 r) r))
      :pattern ((inv@60@00 s@$ g0@2@00 g1@3@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@19@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef3|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@21@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (=
          ($FVF.lookup_next (sm@22@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@22@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef4|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@22@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef5|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@21@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00))
        (=
          ($FVF.lookup_next (sm@27@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@27@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef6|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@26@00 s@$ g0@2@00 g1@3@00 r)
          (Set_in (inv@25@00 s@$ g0@2@00 g1@3@00 r) g1@3@00))
        (=
          ($FVF.lookup_next (sm@27@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r)))
      :pattern (($FVF.lookup_next (sm@27@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r))
      :qid |qp.fvfValDef7|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r) r))
      :pattern (($FVF.lookup_next (sm@27@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef8|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@35@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@33@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@34@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@33@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@34@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@35@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@35@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef12|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@33@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@34@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@21@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@35@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@35@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef9|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@33@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)
            (img@34@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@26@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@25@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@35@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r)))
      :pattern (($FVF.lookup_next (sm@35@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r))
      :qid |qp.fvfValDef10|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r) r))
      :pattern (($FVF.lookup_next (sm@35@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef11|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@40@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@37@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@38@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@37@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@38@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@40@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@40@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef19|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@37@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@38@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@21@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@40@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@40@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef16|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@37@00 s@$ g0@2@00 g1@3@00 r) (Set_union g0@2@00 g1@3@00))
            (img@38@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@26@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@25@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@40@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r)))
      :pattern (($FVF.lookup_next (sm@40@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r))
      :qid |qp.fvfValDef17|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r) r))
      :pattern (($FVF.lookup_next (sm@40@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef18|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@58@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@56@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@57@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@56@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@57@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@58@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@58@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef35|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@56@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@57@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@21@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@58@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@58@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef32|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@56@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)
            (img@57@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@26@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@25@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@58@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r)))
      :pattern (($FVF.lookup_next (sm@58@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r))
      :qid |qp.fvfValDef33|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r) r))
      :pattern (($FVF.lookup_next (sm@58@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef34|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@63@00 s@$ g0@2@00 g1@3@00)))
          (and
            (Set_in (inv@60@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@61@00 s@$ g0@2@00 g1@3@00 r)))
        (=>
          (and
            (Set_in (inv@60@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@61@00 s@$ g0@2@00 g1@3@00 r))
          (Set_in r ($FVF.domain_next (sm@63@00 s@$ g0@2@00 g1@3@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@63@00 s@$ g0@2@00 g1@3@00))))
      :qid |qp.fvfDomDef42|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@60@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@61@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@21@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@20@00 s@$ g0@2@00 g1@3@00 r) g0@2@00)))
        (=
          ($FVF.lookup_next (sm@63@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@63@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef39|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@60@00 s@$ g0@2@00 g1@3@00 r) (Set_union g1@3@00 g0@2@00))
            (img@61@00 s@$ g0@2@00 g1@3@00 r))
          (and
            (img@26@00 s@$ g0@2@00 g1@3@00 r)
            (Set_in (inv@25@00 s@$ g0@2@00 g1@3@00 r) g1@3@00)))
        (=
          ($FVF.lookup_next (sm@63@00 s@$ g0@2@00 g1@3@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r)))
      :pattern (($FVF.lookup_next (sm@63@00 s@$ g0@2@00 g1@3@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r))
      :qid |qp.fvfValDef40|))
    (forall ((r $Ref)) (!
      (and
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
        ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second s@$)))))) r) r))
      :pattern (($FVF.lookup_next (sm@63@00 s@$ g0@2@00 g1@3@00) r))
      :qid |qp.fvfResTrgDef41|))
    (=>
      (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
      (and
        (Set_equal (Set_union g0@2@00 g1@3@00) (Set_union g1@3@00 g0@2@00))
        (forall ((u $Ref) (v $Ref)) (!
          (=>
            (and (Set_in u g0@2@00) (Set_in v g0@2@00))
            (=
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v)
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v)))
          :pattern ((Set_in u g0@2@00) (Set_in v g0@2@00))
          :pattern ((Set_in u g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v))
          :pattern ((Set_in u g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v))
          :pattern ((Set_in v g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v))
          :pattern ((Set_in v g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v))
          :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v))
          :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v))
          ))
        (forall ((u $Ref) (v $Ref)) (!
          (=>
            (and (Set_in u g1@3@00) (Set_in v g1@3@00))
            (=
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v)
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v)))
          :pattern ((Set_in u g1@3@00) (Set_in v g1@3@00))
          :pattern ((Set_in u g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v))
          :pattern ((Set_in u g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v))
          :pattern ((Set_in v g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v))
          :pattern ((Set_in v g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v))
          :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v))
          :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v))
          ))))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-98|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) true)
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-99|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (=>
    (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
    (forall ((u $Ref) (v $Ref)) (!
      (=>
        (and (Set_in u g0@2@00) (Set_in v g0@2@00))
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00)
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00))))
      :pattern ((Set_in u g0@2@00) (Set_in v g0@2@00))
      :pattern ((Set_in u g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v))
      :pattern ((Set_in u g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v))
      :pattern ((Set_in v g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v))
      :pattern ((Set_in v g0@2@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@35@00 s@$ g0@2@00 g1@3@00)) g0@2@00) u v))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@40@00 s@$ g0@2@00 g1@3@00)) (Set_union g0@2@00 g1@3@00)) u v))
      ))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-100|)))
(assert (forall ((s@$ $Snap) (g0@2@00 Set<$Ref>) (g1@3@00 Set<$Ref>)) (!
  (let ((result@4@00 (apply_TCFraming%limited s@$ g0@2@00 g1@3@00))) (=>
    (apply_TCFraming%precondition s@$ g0@2@00 g1@3@00)
    (forall ((u $Ref) (v $Ref)) (!
      (=>
        (and (Set_in u g1@3@00) (Set_in v g1@3@00))
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00)
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00))))
      :pattern ((Set_in u g1@3@00) (Set_in v g1@3@00))
      :pattern ((Set_in u g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v))
      :pattern ((Set_in u g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v))
      :pattern ((Set_in v g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v))
      :pattern ((Set_in v g1@3@00) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@58@00 s@$ g0@2@00 g1@3@00)) g1@3@00) u v))
      :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@63@00 s@$ g0@2@00 g1@3@00)) (Set_union g1@3@00 g0@2@00)) u v))
      ))))
  :pattern ((apply_TCFraming%limited s@$ g0@2@00 g1@3@00))
  :qid |quant-u-101|)))
(assert (forall ((s@$ $Snap) (g@5@00 Set<$Ref>) (roots@6@00 Set<$Ref>)) (!
  (=
    (is_global_sroot%limited s@$ g@5@00 roots@6@00)
    (is_global_sroot s@$ g@5@00 roots@6@00))
  :pattern ((is_global_sroot s@$ g@5@00 roots@6@00))
  :qid |quant-u-4|)))
(assert (forall ((s@$ $Snap) (g@5@00 Set<$Ref>) (roots@6@00 Set<$Ref>)) (!
  (is_global_sroot%stateless g@5@00 roots@6@00)
  :pattern ((is_global_sroot%limited s@$ g@5@00 roots@6@00))
  :qid |quant-u-5|)))
(assert (forall ((s@$ $Snap) (g@5@00 Set<$Ref>) (roots@6@00 Set<$Ref>)) (!
  (and
    (forall ((n$0@76@00 $Ref)) (!
      (=>
        (Set_in n$0@76@00 g@5@00)
        (and
          (= (inv@78@00 s@$ g@5@00 roots@6@00 n$0@76@00) n$0@76@00)
          (img@79@00 s@$ g@5@00 roots@6@00 n$0@76@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) n$0@76@00) n$0@76@00))
      :qid |quant-u-103|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@79@00 s@$ g@5@00 roots@6@00 r)
          (Set_in (inv@78@00 s@$ g@5@00 roots@6@00 r) g@5@00))
        (= (inv@78@00 s@$ g@5@00 roots@6@00 r) r))
      :pattern ((inv@78@00 s@$ g@5@00 roots@6@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@83@00 $Ref)) (!
      (=>
        (Set_in n@83@00 g@5@00)
        (and
          (= (inv@84@00 s@$ g@5@00 roots@6@00 n@83@00) n@83@00)
          (img@85@00 s@$ g@5@00 roots@6@00 n@83@00)))
      :pattern ((Set_in n@83@00 g@5@00))
      :pattern ((inv@84@00 s@$ g@5@00 roots@6@00 n@83@00))
      :pattern ((img@85@00 s@$ g@5@00 roots@6@00 n@83@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@85@00 s@$ g@5@00 roots@6@00 r)
          (Set_in (inv@84@00 s@$ g@5@00 roots@6@00 r) g@5@00))
        (= (inv@84@00 s@$ g@5@00 roots@6@00 r) r))
      :pattern ((inv@84@00 s@$ g@5@00 roots@6@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@77@00 s@$ g@5@00 roots@6@00) r))
      :qid |qp.fvfResTrgDef55|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (img@79@00 s@$ g@5@00 roots@6@00 r)
          (Set_in (inv@78@00 s@$ g@5@00 roots@6@00 r) g@5@00))
        (=
          ($FVF.lookup_next (sm@80@00 s@$ g@5@00 roots@6@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@80@00 s@$ g@5@00 roots@6@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef56|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@80@00 s@$ g@5@00 roots@6@00) r))
      :qid |qp.fvfResTrgDef57|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@86@00 s@$ g@5@00 roots@6@00)))
          (and
            (Set_in (inv@84@00 s@$ g@5@00 roots@6@00 r) g@5@00)
            (img@85@00 s@$ g@5@00 roots@6@00 r)))
        (=>
          (and
            (Set_in (inv@84@00 s@$ g@5@00 roots@6@00 r) g@5@00)
            (img@85@00 s@$ g@5@00 roots@6@00 r))
          (Set_in r ($FVF.domain_next (sm@86@00 s@$ g@5@00 roots@6@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@86@00 s@$ g@5@00 roots@6@00))))
      :qid |qp.fvfDomDef60|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@84@00 s@$ g@5@00 roots@6@00 r) g@5@00)
            (img@85@00 s@$ g@5@00 roots@6@00 r))
          (and
            (img@79@00 s@$ g@5@00 roots@6@00 r)
            (Set_in (inv@78@00 s@$ g@5@00 roots@6@00 r) g@5@00)))
        (=
          ($FVF.lookup_next (sm@86@00 s@$ g@5@00 roots@6@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@86@00 s@$ g@5@00 roots@6@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef58|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@86@00 s@$ g@5@00 roots@6@00) r))
      :qid |qp.fvfResTrgDef59|))
    (=>
      (is_global_sroot%precondition s@$ g@5@00 roots@6@00)
      (=
        (is_global_sroot s@$ g@5@00 roots@6@00)
        (forall ((n $Ref)) (!
          (=>
            (Set_in n g@5@00)
            (exists_spath<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@86@00 s@$ g@5@00 roots@6@00)) g@5@00) roots@6@00 n))
          :pattern ((Set_in n g@5@00))
          :pattern ((exists_spath<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@86@00 s@$ g@5@00 roots@6@00)) g@5@00) roots@6@00 n))
          )))))
  :pattern ((is_global_sroot s@$ g@5@00 roots@6@00))
  :qid |quant-u-111|)))
(assert (forall ((s@$ $Snap) (g@5@00 Set<$Ref>) (roots@6@00 Set<$Ref>)) (!
  (=>
    (is_global_sroot%precondition s@$ g@5@00 roots@6@00)
    (forall ((n $Ref)) (!
      (=>
        (Set_in n g@5@00)
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@86@00 s@$ g@5@00 roots@6@00)) g@5@00))
      :pattern ((Set_in n g@5@00))
      :pattern ((exists_spath<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@86@00 s@$ g@5@00 roots@6@00)) g@5@00) roots@6@00 n))
      )))
  :pattern ((is_global_sroot s@$ g@5@00 roots@6@00))
  :qid |quant-u-112|)))
(assert (forall ((s@$ $Snap) (g@8@00 Set<$Ref>)) (!
  (= (acyclic_list_segment%limited s@$ g@8@00) (acyclic_list_segment s@$ g@8@00))
  :pattern ((acyclic_list_segment s@$ g@8@00))
  :qid |quant-u-6|)))
(assert (forall ((s@$ $Snap) (g@8@00 Set<$Ref>)) (!
  (acyclic_list_segment%stateless g@8@00)
  :pattern ((acyclic_list_segment%limited s@$ g@8@00))
  :qid |quant-u-7|)))
(assert (forall ((s@$ $Snap) (g@8@00 Set<$Ref>)) (!
  (and
    (forall ((n@87@00 $Ref)) (!
      (=>
        (Set_in n@87@00 g@8@00)
        (and
          (= (inv@89@00 s@$ g@8@00 n@87@00) n@87@00)
          (img@90@00 s@$ g@8@00 n@87@00)))
      :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) n@87@00) n@87@00))
      :qid |quant-u-114|))
    (forall ((r $Ref)) (!
      (=>
        (and (img@90@00 s@$ g@8@00 r) (Set_in (inv@89@00 s@$ g@8@00 r) g@8@00))
        (= (inv@89@00 s@$ g@8@00 r) r))
      :pattern ((inv@89@00 s@$ g@8@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@93@00 $Ref)) (!
      (=>
        (Set_in n@93@00 g@8@00)
        (and
          (= (inv@94@00 s@$ g@8@00 n@93@00) n@93@00)
          (img@95@00 s@$ g@8@00 n@93@00)))
      :pattern ((Set_in n@93@00 g@8@00))
      :pattern ((inv@94@00 s@$ g@8@00 n@93@00))
      :pattern ((img@95@00 s@$ g@8@00 n@93@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and (img@95@00 s@$ g@8@00 r) (Set_in (inv@94@00 s@$ g@8@00 r) g@8@00))
        (= (inv@94@00 s@$ g@8@00 r) r))
      :pattern ((inv@94@00 s@$ g@8@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@97@00 $Ref)) (!
      (=>
        (Set_in n@97@00 g@8@00)
        (and
          (= (inv@98@00 s@$ g@8@00 n@97@00) n@97@00)
          (img@99@00 s@$ g@8@00 n@97@00)))
      :pattern ((Set_in n@97@00 g@8@00))
      :pattern ((inv@98@00 s@$ g@8@00 n@97@00))
      :pattern ((img@99@00 s@$ g@8@00 n@97@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and (img@99@00 s@$ g@8@00 r) (Set_in (inv@98@00 s@$ g@8@00 r) g@8@00))
        (= (inv@98@00 s@$ g@8@00 r) r))
      :pattern ((inv@98@00 s@$ g@8@00 r))
      :qid |next-fctOfInv|))
    (forall ((n@102@00 $Ref)) (!
      (=>
        (Set_in n@102@00 g@8@00)
        (and
          (= (inv@103@00 s@$ g@8@00 n@102@00) n@102@00)
          (img@104@00 s@$ g@8@00 n@102@00)))
      :pattern ((Set_in n@102@00 g@8@00))
      :pattern ((inv@103@00 s@$ g@8@00 n@102@00))
      :pattern ((img@104@00 s@$ g@8@00 n@102@00))
      :qid |next-invOfFct|))
    (forall ((r $Ref)) (!
      (=>
        (and (img@104@00 s@$ g@8@00 r) (Set_in (inv@103@00 s@$ g@8@00 r) g@8@00))
        (= (inv@103@00 s@$ g@8@00 r) r))
      :pattern ((inv@103@00 s@$ g@8@00 r))
      :qid |next-fctOfInv|))
    (forall ((r $Ref)) (!
      true
      :pattern (($FVF.lookup_next (sm@88@00 s@$ g@8@00) r))
      :qid |qp.fvfResTrgDef61|))
    (forall ((r $Ref)) (!
      (=>
        (and (img@90@00 s@$ g@8@00 r) (Set_in (inv@89@00 s@$ g@8@00 r) g@8@00))
        (=
          ($FVF.lookup_next (sm@91@00 s@$ g@8@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@91@00 s@$ g@8@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef62|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@91@00 s@$ g@8@00) r))
      :qid |qp.fvfResTrgDef63|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@96@00 s@$ g@8@00)))
          (and (Set_in (inv@94@00 s@$ g@8@00 r) g@8@00) (img@95@00 s@$ g@8@00 r)))
        (=>
          (and (Set_in (inv@94@00 s@$ g@8@00 r) g@8@00) (img@95@00 s@$ g@8@00 r))
          (Set_in r ($FVF.domain_next (sm@96@00 s@$ g@8@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@96@00 s@$ g@8@00))))
      :qid |qp.fvfDomDef66|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and (Set_in (inv@94@00 s@$ g@8@00 r) g@8@00) (img@95@00 s@$ g@8@00 r))
          (and (img@90@00 s@$ g@8@00 r) (Set_in (inv@89@00 s@$ g@8@00 r) g@8@00)))
        (=
          ($FVF.lookup_next (sm@96@00 s@$ g@8@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@96@00 s@$ g@8@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef64|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@96@00 s@$ g@8@00) r))
      :qid |qp.fvfResTrgDef65|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@101@00 s@$ g@8@00)))
          (and (Set_in (inv@98@00 s@$ g@8@00 r) g@8@00) (img@99@00 s@$ g@8@00 r)))
        (=>
          (and (Set_in (inv@98@00 s@$ g@8@00 r) g@8@00) (img@99@00 s@$ g@8@00 r))
          (Set_in r ($FVF.domain_next (sm@101@00 s@$ g@8@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@101@00 s@$ g@8@00))))
      :qid |qp.fvfDomDef71|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and (Set_in (inv@98@00 s@$ g@8@00 r) g@8@00) (img@99@00 s@$ g@8@00 r))
          (and (img@90@00 s@$ g@8@00 r) (Set_in (inv@89@00 s@$ g@8@00 r) g@8@00)))
        (=
          ($FVF.lookup_next (sm@101@00 s@$ g@8@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@101@00 s@$ g@8@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef69|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@101@00 s@$ g@8@00) r))
      :qid |qp.fvfResTrgDef70|))
    (forall ((r $Ref)) (!
      (and
        (=>
          (Set_in r ($FVF.domain_next (sm@106@00 s@$ g@8@00)))
          (and
            (Set_in (inv@103@00 s@$ g@8@00 r) g@8@00)
            (img@104@00 s@$ g@8@00 r)))
        (=>
          (and
            (Set_in (inv@103@00 s@$ g@8@00 r) g@8@00)
            (img@104@00 s@$ g@8@00 r))
          (Set_in r ($FVF.domain_next (sm@106@00 s@$ g@8@00)))))
      :pattern ((Set_in r ($FVF.domain_next (sm@106@00 s@$ g@8@00))))
      :qid |qp.fvfDomDef76|))
    (forall ((r $Ref)) (!
      (=>
        (and
          (and
            (Set_in (inv@103@00 s@$ g@8@00 r) g@8@00)
            (img@104@00 s@$ g@8@00 r))
          (and (img@90@00 s@$ g@8@00 r) (Set_in (inv@89@00 s@$ g@8@00 r) g@8@00)))
        (=
          ($FVF.lookup_next (sm@106@00 s@$ g@8@00) r)
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r)))
      :pattern (($FVF.lookup_next (sm@106@00 s@$ g@8@00) r))
      :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r))
      :qid |qp.fvfValDef74|))
    (forall ((r $Ref)) (!
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second s@$))) r) r)
      :pattern (($FVF.lookup_next (sm@106@00 s@$ g@8@00) r))
      :qid |qp.fvfResTrgDef75|))
    (=>
      (acyclic_list_segment%precondition s@$ g@8@00)
      (=
        (acyclic_list_segment s@$ g@8@00)
        (and
          (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00))
          (and
            (func_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00))
            (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00)))))))
  :pattern ((acyclic_list_segment s@$ g@8@00))
  :qid |quant-u-134|)))
(assert (forall ((s@$ $Snap) (g@8@00 Set<$Ref>)) (!
  (=>
    (acyclic_list_segment%precondition s@$ g@8@00)
    (and
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00)
      (=>
        (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00))
        (and
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00)
          (=>
            (func_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (sm@96@00 s@$ g@8@00)) g@8@00))))))
  :pattern ((acyclic_list_segment s@$ g@8@00))
  :qid |quant-u-135|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- test_graph ----------
(declare-const g0@0@01 Set<$Ref>)
(declare-const g1@1@01 Set<$Ref>)
(declare-const g0@2@01 Set<$Ref>)
(declare-const g1@3@01 Set<$Ref>)
(set-option :timeout 0)
(push) ; 1
(declare-const $t@4@01 $Snap)
(assert (= $t@4@01 ($Snap.combine ($Snap.first $t@4@01) ($Snap.second $t@4@01))))
(assert (= ($Snap.first $t@4@01) $Snap.unit))
; [eval] !((null in g0))
; [eval] (null in g0)
(assert (not (Set_in $Ref.null g0@2@01)))
(assert (=
  ($Snap.second $t@4@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@4@01))
    ($Snap.second ($Snap.second $t@4@01)))))
(declare-const n@5@01 $Ref)
(push) ; 2
; [eval] (n in g0)
(assert (Set_in n@5@01 g0@2@01))
(declare-const sm@6@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@7@01 ($Ref) $Ref)
(declare-fun img@8@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@5@01 $Ref) (n2@5@01 $Ref)) (!
  (=>
    (and (Set_in n1@5@01 g0@2@01) (Set_in n2@5@01 g0@2@01) (= n1@5@01 n2@5@01))
    (= n1@5@01 n2@5@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@5@01 $Ref)) (!
  (=>
    (Set_in n@5@01 g0@2@01)
    (and (= (inv@7@01 n@5@01) n@5@01) (img@8@01 n@5@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) n@5@01) n@5@01))
  :qid |quant-u-137|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) (= (inv@7@01 r) r))
  :pattern ((inv@7@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@5@01 $Ref)) (!
  (=> (Set_in n@5@01 g0@2@01) (not (= n@5@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) n@5@01) n@5@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@9@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@9@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@7@01 r) g0@2@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) r) r))
  :pattern ((inv@7@01 r))
  :qid |quant-u-138|)))
(assert (=
  ($Snap.second ($Snap.second $t@4@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@4@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@4@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@4@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g0) } { (n$0 in g0), n$0.next } (n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@10@01 $Ref)
(push) ; 2
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 3
; [then-branch: 0 | !(n$0@10@01 in g0@2@01) | live]
; [else-branch: 0 | n$0@10@01 in g0@2@01 | live]
(push) ; 4
; [then-branch: 0 | !(n$0@10@01 in g0@2@01)]
(assert (not (Set_in n$0@10@01 g0@2@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 0 | n$0@10@01 in g0@2@01]
(assert (Set_in n$0@10@01 g0@2@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
      (=
        ($FVF.lookup_next (as sm@9@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
    :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
    :qid |qp.fvfValDef1|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef2|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01))
(push) ; 5
(assert (not (and (img@8@01 n$0@10@01) (Set_in (inv@7@01 n$0@10@01) g0@2@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@9@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (=>
  (Set_in n$0@10@01 g0@2@01)
  (and
    (Set_in n$0@10@01 g0@2@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01))))
(assert (or (Set_in n$0@10@01 g0@2@01) (not (Set_in n$0@10@01 g0@2@01))))
(push) ; 3
; [then-branch: 1 | n$0@10@01 in g0@2@01 && Lookup(next, sm@9@01, n$0@10@01) != Null | live]
; [else-branch: 1 | !(n$0@10@01 in g0@2@01 && Lookup(next, sm@9@01, n$0@10@01) != Null) | live]
(push) ; 4
; [then-branch: 1 | n$0@10@01 in g0@2@01 && Lookup(next, sm@9@01, n$0@10@01) != Null]
(assert (and
  (Set_in n$0@10@01 g0@2@01)
  (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
      (=
        ($FVF.lookup_next (as sm@9@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
    :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
    :qid |qp.fvfValDef1|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef2|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01))
(push) ; 5
(assert (not (and (img@8@01 n$0@10@01) (Set_in (inv@7@01 n$0@10@01) g0@2@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 1 | !(n$0@10@01 in g0@2@01 && Lookup(next, sm@9@01, n$0@10@01) != Null)]
(assert (not
  (and
    (Set_in n$0@10@01 g0@2@01)
    (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@9@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (=>
  (and
    (Set_in n$0@10@01 g0@2@01)
    (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))
  (and
    (Set_in n$0@10@01 g0@2@01)
    (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@10@01 g0@2@01)
      (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))))
  (and
    (Set_in n$0@10@01 g0@2@01)
    (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@9@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@9@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef2|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@10@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@10@01 g0@2@01)
      (and
        (Set_in n$0@10@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01)))
    (or (Set_in n$0@10@01 g0@2@01) (not (Set_in n$0@10@01 g0@2@01)))
    (=>
      (and
        (Set_in n$0@10@01 g0@2@01)
        (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))
      (and
        (Set_in n$0@10@01 g0@2@01)
        (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01)))
    (or
      (not
        (and
          (Set_in n$0@10@01 g0@2@01)
          (not
            (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))))
      (and
        (Set_in n$0@10@01 g0@2@01)
        (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) g0@2@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@338@14@338@23-aux|)))
(assert (forall ((n$0@10@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@10@01 g0@2@01)
      (and
        (Set_in n$0@10@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01)))
    (or (Set_in n$0@10@01 g0@2@01) (not (Set_in n$0@10@01 g0@2@01)))
    (=>
      (and
        (Set_in n$0@10@01 g0@2@01)
        (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))
      (and
        (Set_in n$0@10@01 g0@2@01)
        (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01)))
    (or
      (not
        (and
          (Set_in n$0@10@01 g0@2@01)
          (not
            (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null))))
      (and
        (Set_in n$0@10@01 g0@2@01)
        (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))))
  :pattern ((Set_in n$0@10@01 g0@2@01) ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@338@14@338@23-aux|)))
(assert (forall ((n$0@10@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@10@01 g0@2@01)
      (not (= ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) g0@2@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) g0@2@01))
  :pattern ((Set_in n$0@10@01 g0@2@01) ($FVF.loc_next ($FVF.lookup_next (as sm@9@01  $FVF<next>) n$0@10@01) n$0@10@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@338@14@338@23|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@4@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@4@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@4@01)))) $Snap.unit))
; [eval] !((null in g1))
; [eval] (null in g1)
(assert (not (Set_in $Ref.null g1@3@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01))))))))
(declare-const n$1@11@01 $Ref)
(push) ; 2
; [eval] (n$1 in g1)
(assert (Set_in n$1@11@01 g1@3@01))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@12@01 ($Ref) $Ref)
(declare-fun img@13@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n$11@11@01 $Ref) (n$12@11@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@11@01 g1@3@01)
      (Set_in n$12@11@01 g1@3@01)
      (= n$11@11@01 n$12@11@01))
    (= n$11@11@01 n$12@11@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@11@01 $Ref)) (!
  (=>
    (Set_in n$1@11@01 g1@3@01)
    (and (= (inv@12@01 n$1@11@01) n$1@11@01) (img@13@01 n$1@11@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) n$1@11@01) n$1@11@01))
  :qid |quant-u-140|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)) (= (inv@12@01 r) r))
  :pattern ((inv@12@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@11@01 $Ref)) (!
  (=> (Set_in n$1@11@01 g1@3@01) (not (= n$1@11@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) n$1@11@01) n$1@11@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 2
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$1@11@01 n@5@01)
    (=
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))))
  
  :qid |quant-u-141|))))
(check-sat)
; unknown
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
(declare-const sm@14@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@12@01 r) g1@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) r) r))
  :pattern ((inv@12@01 r))
  :qid |quant-u-142|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g1) } { (n$2 in g1), n$2.next } (n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@15@01 $Ref)
(set-option :timeout 0)
(push) ; 2
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 3
; [then-branch: 2 | !(n$2@15@01 in g1@3@01) | live]
; [else-branch: 2 | n$2@15@01 in g1@3@01 | live]
(push) ; 4
; [then-branch: 2 | !(n$2@15@01 in g1@3@01)]
(assert (not (Set_in n$2@15@01 g1@3@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 2 | n$2@15@01 in g1@3@01]
(assert (Set_in n$2@15@01 g1@3@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
      (=
        ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
    :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
    :qid |qp.fvfValDef3|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
      (=
        ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
    :qid |qp.fvfValDef4|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef5|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@8@01 n$2@15@01) (Set_in (inv@7@01 n$2@15@01) g0@2@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@13@01 n$2@15@01) (Set_in (inv@12@01 n$2@15@01) g1@3@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (=>
  (Set_in n$2@15@01 g1@3@01)
  (and
    (Set_in n$2@15@01 g1@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01))))
(assert (or (Set_in n$2@15@01 g1@3@01) (not (Set_in n$2@15@01 g1@3@01))))
(push) ; 3
; [then-branch: 3 | n$2@15@01 in g1@3@01 && Lookup(next, sm@14@01, n$2@15@01) != Null | live]
; [else-branch: 3 | !(n$2@15@01 in g1@3@01 && Lookup(next, sm@14@01, n$2@15@01) != Null) | live]
(push) ; 4
; [then-branch: 3 | n$2@15@01 in g1@3@01 && Lookup(next, sm@14@01, n$2@15@01) != Null]
(assert (and
  (Set_in n$2@15@01 g1@3@01)
  (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
      (=
        ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
    :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
    :qid |qp.fvfValDef3|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
      (=
        ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
    :qid |qp.fvfValDef4|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef5|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@8@01 n$2@15@01) (Set_in (inv@7@01 n$2@15@01) g0@2@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@13@01 n$2@15@01) (Set_in (inv@12@01 n$2@15@01) g1@3@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 3 | !(n$2@15@01 in g1@3@01 && Lookup(next, sm@14@01, n$2@15@01) != Null)]
(assert (not
  (and
    (Set_in n$2@15@01 g1@3@01)
    (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (=>
  (and
    (Set_in n$2@15@01 g1@3@01)
    (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))
  (and
    (Set_in n$2@15@01 g1@3@01)
    (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@15@01 g1@3@01)
      (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))))
  (and
    (Set_in n$2@15@01 g1@3@01)
    (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef3|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@14@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@14@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef5|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@15@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@15@01 g1@3@01)
      (and
        (Set_in n$2@15@01 g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01)))
    (or (Set_in n$2@15@01 g1@3@01) (not (Set_in n$2@15@01 g1@3@01)))
    (=>
      (and
        (Set_in n$2@15@01 g1@3@01)
        (not
          (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))
      (and
        (Set_in n$2@15@01 g1@3@01)
        (not
          (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01)))
    (or
      (not
        (and
          (Set_in n$2@15@01 g1@3@01)
          (not
            (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))))
      (and
        (Set_in n$2@15@01 g1@3@01)
        (not
          (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) g1@3@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@338@27@338@36-aux|)))
(assert (forall ((n$2@15@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@15@01 g1@3@01)
      (and
        (Set_in n$2@15@01 g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01)))
    (or (Set_in n$2@15@01 g1@3@01) (not (Set_in n$2@15@01 g1@3@01)))
    (=>
      (and
        (Set_in n$2@15@01 g1@3@01)
        (not
          (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))
      (and
        (Set_in n$2@15@01 g1@3@01)
        (not
          (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01)))
    (or
      (not
        (and
          (Set_in n$2@15@01 g1@3@01)
          (not
            (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null))))
      (and
        (Set_in n$2@15@01 g1@3@01)
        (not
          (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))))
  :pattern ((Set_in n$2@15@01 g1@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@338@27@338@36-aux|)))
(assert (forall ((n$2@15@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@15@01 g1@3@01)
      (not (= ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) g1@3@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) g1@3@01))
  :pattern ((Set_in n$2@15@01 g1@3@01) ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n$2@15@01) n$2@15@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@338@27@338@36|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; assert (forall e: Edge ::
;     { (e in $$(g0)) }
;     { (e in ($$(g0) union $$(g1))) }
;     (e in $$(g0)) ==> (e in ($$(g0) union $$(g1))))
; [eval] (forall e: Edge :: { (e in $$(g0)) } { (e in ($$(g0) union $$(g1))) } (e in $$(g0)) ==> (e in ($$(g0) union $$(g1))))
(declare-const e@16@01 Edge)
(push) ; 3
; [eval] (e in $$(g0)) ==> (e in ($$(g0) union $$(g1)))
; [eval] (e in $$(g0))
; [eval] $$(g0)
(push) ; 4
(declare-const n@17@01 $Ref)
(push) ; 5
; [eval] (n in refs)
(assert (Set_in n@17@01 g0@2@01))
(pop) ; 5
(declare-fun inv@18@01 ($Ref) $Ref)
(declare-fun img@19@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((n1@17@01 $Ref) (n2@17@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@17@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n1@17@01) n1@17@01))
      (and
        (Set_in n2@17@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) n2@17@01) n2@17@01))
      (= n1@17@01 n2@17@01))
    (= n1@17@01 n2@17@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@17@01 $Ref)) (!
  (=>
    (Set_in n@17@01 g0@2@01)
    (and (= (inv@18@01 n@17@01) n@17@01) (img@19@01 n@17@01)))
  :pattern ((Set_in n@17@01 g0@2@01))
  :pattern ((inv@18@01 n@17@01))
  :pattern ((img@19@01 n@17@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@19@01 r) (Set_in (inv@18@01 r) g0@2@01)) (= (inv@18@01 r) r))
  :pattern ((inv@18@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@18@01 r) g0@2@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) r) r))
  :pattern ((inv@18@01 r))
  :qid |quant-u-144|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@20@01 ((r $Ref) (e@16@01 Edge)) $Perm
  (ite
    (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r) (= r (inv@18@01 r)))
    ($Perm.min
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@21@01 ((r $Ref) (e@16@01 Edge)) $Perm
  (ite
    (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r) (= r (inv@18@01 r)))
    ($Perm.min
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@20@01 r e@16@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (pTaken@20@01 r e@16@01))
    $Perm.No)
  
  :qid |quant-u-146|))))
(check-sat)
; unknown
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@20@01 r e@16@01) $Perm.No)
  
  :qid |quant-u-147|))))
(check-sat)
; unknown
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r) (= r (inv@18@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@20@01 r e@16@01)) $Perm.No))
  
  :qid |quant-u-148|))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@22@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>)))
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r)))
    (=>
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>))))
  :qid |qp.fvfDomDef9|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@22@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@22@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef8|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
(pop) ; 4
; Joined path conditions
(assert (forall ((n@17@01 $Ref)) (!
  (=>
    (Set_in n@17@01 g0@2@01)
    (and (= (inv@18@01 n@17@01) n@17@01) (img@19@01 n@17@01)))
  :pattern ((Set_in n@17@01 g0@2@01))
  :pattern ((inv@18@01 n@17@01))
  :pattern ((img@19@01 n@17@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@19@01 r) (Set_in (inv@18@01 r) g0@2@01)) (= (inv@18@01 r) r))
  :pattern ((inv@18@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>)))
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r)))
    (=>
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>))))
  :qid |qp.fvfDomDef9|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@22@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@22@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@18@01 r) g0@2@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) r) r))
    :pattern ((inv@18@01 r))
    :qid |quant-u-144|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 4 | e@16@01 in $$(sm@22@01, g0@2@01) | live]
; [else-branch: 4 | !(e@16@01 in $$(sm@22@01, g0@2@01)) | live]
(push) ; 5
; [then-branch: 4 | e@16@01 in $$(sm@22@01, g0@2@01)]
(assert (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
; [eval] (e in ($$(g0) union $$(g1)))
; [eval] ($$(g0) union $$(g1))
; [eval] $$(g0)
(push) ; 6
(declare-const n@23@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@23@01 g0@2@01))
(pop) ; 7
(declare-fun inv@24@01 ($Ref) $Ref)
(declare-fun img@25@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@26@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@23@01 $Ref) (n2@23@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@23@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) n1@23@01) n1@23@01))
      (and
        (Set_in n2@23@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) n2@23@01) n2@23@01))
      (= n1@23@01 n2@23@01))
    (= n1@23@01 n2@23@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@23@01 $Ref)) (!
  (=>
    (Set_in n@23@01 g0@2@01)
    (and (= (inv@24@01 n@23@01) n@23@01) (img@25@01 n@23@01)))
  :pattern ((Set_in n@23@01 g0@2@01))
  :pattern ((inv@24@01 n@23@01))
  :pattern ((img@25@01 n@23@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@25@01 r) (Set_in (inv@24@01 r) g0@2@01)) (= (inv@24@01 r) r))
  :pattern ((inv@24@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@24@01 r) g0@2@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) r) r))
  :pattern ((inv@24@01 r))
  :qid |quant-u-150|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@27@01 ((r $Ref) (e@16@01 Edge)) $Perm
  (ite
    (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r) (= r (inv@24@01 r)))
    ($Perm.min
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@28@01 ((r $Ref) (e@16@01 Edge)) $Perm
  (ite
    (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r) (= r (inv@24@01 r)))
    ($Perm.min
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@27@01 r e@16@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (pTaken@27@01 r e@16@01))
    $Perm.No)
  
  :qid |quant-u-152|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@27@01 r e@16@01) $Perm.No)
  
  :qid |quant-u-153|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r) (= r (inv@24@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@27@01 r e@16@01)) $Perm.No))
  
  :qid |quant-u-154|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@29@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r)))
    (=>
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef16|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef13|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (forall ((n@23@01 $Ref)) (!
  (=>
    (Set_in n@23@01 g0@2@01)
    (and (= (inv@24@01 n@23@01) n@23@01) (img@25@01 n@23@01)))
  :pattern ((Set_in n@23@01 g0@2@01))
  :pattern ((inv@24@01 n@23@01))
  :pattern ((img@25@01 n@23@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@25@01 r) (Set_in (inv@24@01 r) g0@2@01)) (= (inv@24@01 r) r))
  :pattern ((inv@24@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r)))
    (=>
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef16|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef13|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@24@01 r) g0@2@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) r) r))
    :pattern ((inv@24@01 r))
    :qid |quant-u-150|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01)))
; [eval] $$(g1)
(set-option :timeout 0)
(push) ; 6
(declare-const n@30@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@30@01 g1@3@01))
(pop) ; 7
(declare-fun inv@31@01 ($Ref) $Ref)
(declare-fun img@32@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@33@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@30@01 $Ref) (n2@30@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@30@01 g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) n1@30@01) n1@30@01))
      (and
        (Set_in n2@30@01 g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) n2@30@01) n2@30@01))
      (= n1@30@01 n2@30@01))
    (= n1@30@01 n2@30@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@30@01 $Ref)) (!
  (=>
    (Set_in n@30@01 g1@3@01)
    (and (= (inv@31@01 n@30@01) n@30@01) (img@32@01 n@30@01)))
  :pattern ((Set_in n@30@01 g1@3@01))
  :pattern ((inv@31@01 n@30@01))
  :pattern ((img@32@01 n@30@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@32@01 r) (Set_in (inv@31@01 r) g1@3@01)) (= (inv@31@01 r) r))
  :pattern ((inv@31@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@31@01 r) g1@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) r) r))
  :pattern ((inv@31@01 r))
  :qid |quant-u-156|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@34@01 ((r $Ref) (e@16@01 Edge)) $Perm
  (ite
    (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r) (= r (inv@31@01 r)))
    ($Perm.min
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@35@01 ((r $Ref) (e@16@01 Edge)) $Perm
  (ite
    (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r) (= r (inv@31@01 r)))
    ($Perm.min
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@34@01 r e@16@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (pTaken@34@01 r e@16@01))
    $Perm.No)
  
  :qid |quant-u-158|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@34@01 r e@16@01) $Perm.No)
  
  :qid |quant-u-159|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r) (= r (inv@31@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@34@01 r e@16@01)) $Perm.No))
  
  :qid |quant-u-160|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (pTaken@35@01 r e@16@01))
    $Perm.No)
  
  :qid |quant-u-161|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@35@01 r e@16@01) $Perm.No)
  
  :qid |quant-u-162|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r) (= r (inv@31@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@34@01 r e@16@01))
        (pTaken@35@01 r e@16@01))
      $Perm.No))
  
  :qid |quant-u-163|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@36@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r)))
    (=>
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (forall ((n@30@01 $Ref)) (!
  (=>
    (Set_in n@30@01 g1@3@01)
    (and (= (inv@31@01 n@30@01) n@30@01) (img@32@01 n@30@01)))
  :pattern ((Set_in n@30@01 g1@3@01))
  :pattern ((inv@31@01 n@30@01))
  :pattern ((img@32@01 n@30@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@32@01 r) (Set_in (inv@31@01 r) g1@3@01)) (= (inv@31@01 r) r))
  :pattern ((inv@31@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r)))
    (=>
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@31@01 r) g1@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) r) r))
    :pattern ((inv@31@01 r))
    :qid |quant-u-156|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01)))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 4 | !(e@16@01 in $$(sm@22@01, g0@2@01))]
(assert (not
  (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (forall ((n@23@01 $Ref)) (!
  (=>
    (Set_in n@23@01 g0@2@01)
    (and (= (inv@24@01 n@23@01) n@23@01) (img@25@01 n@23@01)))
  :pattern ((Set_in n@23@01 g0@2@01))
  :pattern ((inv@24@01 n@23@01))
  :pattern ((img@25@01 n@23@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@25@01 r) (Set_in (inv@24@01 r) g0@2@01)) (= (inv@24@01 r) r))
  :pattern ((inv@24@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r)))
    (=>
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef16|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef13|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (forall ((n@30@01 $Ref)) (!
  (=>
    (Set_in n@30@01 g1@3@01)
    (and (= (inv@31@01 n@30@01) n@30@01) (img@32@01 n@30@01)))
  :pattern ((Set_in n@30@01 g1@3@01))
  :pattern ((inv@31@01 n@30@01))
  :pattern ((img@32@01 n@30@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@32@01 r) (Set_in (inv@31@01 r) g1@3@01)) (= (inv@31@01 r) r))
  :pattern ((inv@31@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r)))
    (=>
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (=>
  (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
  (and
    (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@24@01 r) g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) r) r))
      :pattern ((inv@24@01 r))
      :qid |quant-u-150|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@31@01 r) g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) r) r))
      :pattern ((inv@31@01 r))
      :qid |quant-u-156|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
; Joined path conditions
(assert (or
  (not
    (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
  (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@17@01 $Ref)) (!
  (=>
    (Set_in n@17@01 g0@2@01)
    (and (= (inv@18@01 n@17@01) n@17@01) (img@19@01 n@17@01)))
  :pattern ((Set_in n@17@01 g0@2@01))
  :pattern ((inv@18@01 n@17@01))
  :pattern ((img@19@01 n@17@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@19@01 r) (Set_in (inv@18@01 r) g0@2@01)) (= (inv@18@01 r) r))
  :pattern ((inv@18@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>)))
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r)))
    (=>
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@22@01  $FVF<next>))))
  :qid |qp.fvfDomDef9|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@22@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@18@01 r) g0@2@01) (img@19@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@22@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@22@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@26@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@26@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (forall ((n@23@01 $Ref)) (!
  (=>
    (Set_in n@23@01 g0@2@01)
    (and (= (inv@24@01 n@23@01) n@23@01) (img@25@01 n@23@01)))
  :pattern ((Set_in n@23@01 g0@2@01))
  :pattern ((inv@24@01 n@23@01))
  :pattern ((img@25@01 n@23@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@25@01 r) (Set_in (inv@24@01 r) g0@2@01)) (= (inv@24@01 r) r))
  :pattern ((inv@24@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r)))
    (=>
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@29@01  $FVF<next>))))
  :qid |qp.fvfDomDef16|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef13|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@24@01 r) g0@2@01) (img@25@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@29@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@29@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@33@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@33@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (forall ((n@30@01 $Ref)) (!
  (=>
    (Set_in n@30@01 g1@3@01)
    (and (= (inv@31@01 n@30@01) n@30@01) (img@32@01 n@30@01)))
  :pattern ((Set_in n@30@01 g1@3@01))
  :pattern ((inv@31@01 n@30@01))
  :pattern ((img@32@01 n@30@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@32@01 r) (Set_in (inv@31@01 r) g1@3@01)) (= (inv@31@01 r) r))
  :pattern ((inv@31@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r)))
    (=>
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@36@01  $FVF<next>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@31@01 r) g1@3@01) (img@32@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@36@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@36@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef22|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@18@01 r) g0@2@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@14@01  $FVF<next>) r) r))
  :pattern ((inv@18@01 r))
  :qid |quant-u-144|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((e@16@01 Edge)) (!
  (and
    (=>
      (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
      (and
        (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@24@01 r) g0@2@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) r) r))
          :pattern ((inv@24@01 r))
          :qid |quant-u-150|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@31@01 r) g1@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) r) r))
          :pattern ((inv@31@01 r))
          :qid |quant-u-156|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01)))
    (or
      (not
        (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
      (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))))
  :pattern ((Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@342@12@342@71-aux|)))
(assert (forall ((e@16@01 Edge)) (!
  (and
    (=>
      (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
      (and
        (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@24@01 r) g0@2@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@26@01  $FVF<next>) r) r))
          :pattern ((inv@24@01 r))
          :qid |quant-u-150|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@31@01 r) g1@3@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@33@01  $FVF<next>) r) r))
          :pattern ((inv@31@01 r))
          :qid |quant-u-156|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01)))
    (or
      (not
        (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
      (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))))
  :pattern ((Set_in e@16@01 (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@342@12@342@71-aux|)))
(assert (forall ((e@16@01 Edge)) (!
  (and
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)
    (=>
      (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
      (and
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01)
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :pattern ((Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
  :pattern ((Set_in e@16@01 (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@342@12@342@71_precondition|)))
(push) ; 3
(assert (not (forall ((e@16@01 Edge)) (!
  (=>
    (and
      (and
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)
        (=>
          (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
          (and
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01)
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
      (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
    (Set_in e@16@01 (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :pattern ((Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
  :pattern ((Set_in e@16@01 (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@342@12@342@71|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((e@16@01 Edge)) (!
  (=>
    (Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01))
    (Set_in e@16@01 (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :pattern ((Set_in e@16@01 ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@22@01  $FVF<next>)) g0@2@01)))
  :pattern ((Set_in e@16@01 (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@29@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@36@01  $FVF<next>)) g1@3@01))))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@342@12@342@71|)))
; [exec]
; assert ($$(g0) union $$(g1)) == $$((g0 union g1))
; [eval] ($$(g0) union $$(g1)) == $$((g0 union g1))
; [eval] ($$(g0) union $$(g1))
; [eval] $$(g0)
(push) ; 3
(declare-const n@37@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@37@01 g0@2@01))
(pop) ; 4
(declare-fun inv@38@01 ($Ref) $Ref)
(declare-fun img@39@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@40@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@40@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@40@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@40@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@40@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@40@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef26|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@37@01 $Ref) (n2@37@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@37@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@40@01  $FVF<next>) n1@37@01) n1@37@01))
      (and
        (Set_in n2@37@01 g0@2@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@40@01  $FVF<next>) n2@37@01) n2@37@01))
      (= n1@37@01 n2@37@01))
    (= n1@37@01 n2@37@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@37@01 $Ref)) (!
  (=>
    (Set_in n@37@01 g0@2@01)
    (and (= (inv@38@01 n@37@01) n@37@01) (img@39@01 n@37@01)))
  :pattern ((Set_in n@37@01 g0@2@01))
  :pattern ((inv@38@01 n@37@01))
  :pattern ((img@39@01 n@37@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@39@01 r) (Set_in (inv@38@01 r) g0@2@01)) (= (inv@38@01 r) r))
  :pattern ((inv@38@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@38@01 r) g0@2@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@40@01  $FVF<next>) r) r))
  :pattern ((inv@38@01 r))
  :qid |quant-u-165|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@41@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r) (= r (inv@38@01 r)))
    ($Perm.min
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@42@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r) (= r (inv@38@01 r)))
    ($Perm.min
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@41@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (pTaken@41@01 r))
    $Perm.No)
  
  :qid |quant-u-167|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@41@01 r) $Perm.No)
  
  :qid |quant-u-168|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r) (= r (inv@38@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@41@01 r)) $Perm.No))
  
  :qid |quant-u-169|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@43@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@43@01  $FVF<next>)))
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r)))
    (=>
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r))
      (Set_in r ($FVF.domain_next (as sm@43@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@43@01  $FVF<next>))))
  :qid |qp.fvfDomDef30|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@43@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@43@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@43@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@43@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@43@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@43@01  $FVF<next>)) g0@2@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@40@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@40@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@40@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@40@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef25|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@40@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef26|)))
(assert (forall ((n@37@01 $Ref)) (!
  (=>
    (Set_in n@37@01 g0@2@01)
    (and (= (inv@38@01 n@37@01) n@37@01) (img@39@01 n@37@01)))
  :pattern ((Set_in n@37@01 g0@2@01))
  :pattern ((inv@38@01 n@37@01))
  :pattern ((img@39@01 n@37@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@39@01 r) (Set_in (inv@38@01 r) g0@2@01)) (= (inv@38@01 r) r))
  :pattern ((inv@38@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@43@01  $FVF<next>)))
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r)))
    (=>
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r))
      (Set_in r ($FVF.domain_next (as sm@43@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@43@01  $FVF<next>))))
  :qid |qp.fvfDomDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@43@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@43@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@38@01 r) g0@2@01) (img@39@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@43@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@43@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@43@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@38@01 r) g0@2@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@40@01  $FVF<next>) r) r))
    :pattern ((inv@38@01 r))
    :qid |quant-u-165|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@43@01  $FVF<next>)) g0@2@01)))
; [eval] $$(g1)
(set-option :timeout 0)
(push) ; 3
(declare-const n@44@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@44@01 g1@3@01))
(pop) ; 4
(declare-fun inv@45@01 ($Ref) $Ref)
(declare-fun img@46@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@47@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef33|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@44@01 $Ref) (n2@44@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@44@01 g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@47@01  $FVF<next>) n1@44@01) n1@44@01))
      (and
        (Set_in n2@44@01 g1@3@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@47@01  $FVF<next>) n2@44@01) n2@44@01))
      (= n1@44@01 n2@44@01))
    (= n1@44@01 n2@44@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@44@01 $Ref)) (!
  (=>
    (Set_in n@44@01 g1@3@01)
    (and (= (inv@45@01 n@44@01) n@44@01) (img@46@01 n@44@01)))
  :pattern ((Set_in n@44@01 g1@3@01))
  :pattern ((inv@45@01 n@44@01))
  :pattern ((img@46@01 n@44@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@46@01 r) (Set_in (inv@45@01 r) g1@3@01)) (= (inv@45@01 r) r))
  :pattern ((inv@45@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@45@01 r) g1@3@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@47@01  $FVF<next>) r) r))
  :pattern ((inv@45@01 r))
  :qid |quant-u-171|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@48@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r) (= r (inv@45@01 r)))
    ($Perm.min
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@49@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r) (= r (inv@45@01 r)))
    ($Perm.min
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@48@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (pTaken@48@01 r))
    $Perm.No)
  
  :qid |quant-u-173|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@48@01 r) $Perm.No)
  
  :qid |quant-u-174|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r) (= r (inv@45@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@48@01 r)) $Perm.No))
  
  :qid |quant-u-175|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (pTaken@49@01 r))
    $Perm.No)
  
  :qid |quant-u-176|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@49@01 r) $Perm.No)
  
  :qid |quant-u-177|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r) (= r (inv@45@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@48@01 r)) (pTaken@49@01 r))
      $Perm.No))
  
  :qid |quant-u-178|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@50@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@50@01  $FVF<next>)))
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r)))
    (=>
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r))
      (Set_in r ($FVF.domain_next (as sm@50@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@50@01  $FVF<next>))))
  :qid |qp.fvfDomDef37|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@50@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@50@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@50@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@50@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@50@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@50@01  $FVF<next>)) g1@3@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@47@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@47@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef33|)))
(assert (forall ((n@44@01 $Ref)) (!
  (=>
    (Set_in n@44@01 g1@3@01)
    (and (= (inv@45@01 n@44@01) n@44@01) (img@46@01 n@44@01)))
  :pattern ((Set_in n@44@01 g1@3@01))
  :pattern ((inv@45@01 n@44@01))
  :pattern ((img@46@01 n@44@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@46@01 r) (Set_in (inv@45@01 r) g1@3@01)) (= (inv@45@01 r) r))
  :pattern ((inv@45@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@50@01  $FVF<next>)))
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r)))
    (=>
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r))
      (Set_in r ($FVF.domain_next (as sm@50@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@50@01  $FVF<next>))))
  :qid |qp.fvfDomDef37|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@50@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@50@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@45@01 r) g1@3@01) (img@46@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@50@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@50@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@50@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@45@01 r) g1@3@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@47@01  $FVF<next>) r) r))
    :pattern ((inv@45@01 r))
    :qid |quant-u-171|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@50@01  $FVF<next>)) g1@3@01)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(set-option :timeout 0)
(push) ; 3
(declare-const n@51@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@51@01 (Set_union g0@2@01 g1@3@01)))
(pop) ; 4
(declare-fun inv@52@01 ($Ref) $Ref)
(declare-fun img@53@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@54@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@54@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@54@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@54@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@54@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@54@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef40|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@51@01 $Ref) (n2@51@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@51@01 (Set_union g0@2@01 g1@3@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@54@01  $FVF<next>) n1@51@01) n1@51@01))
      (and
        (Set_in n2@51@01 (Set_union g0@2@01 g1@3@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@54@01  $FVF<next>) n2@51@01) n2@51@01))
      (= n1@51@01 n2@51@01))
    (= n1@51@01 n2@51@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@51@01 $Ref)) (!
  (=>
    (Set_in n@51@01 (Set_union g0@2@01 g1@3@01))
    (and (= (inv@52@01 n@51@01) n@51@01) (img@53@01 n@51@01)))
  :pattern ((Set_in n@51@01 (Set_union g0@2@01 g1@3@01)))
  :pattern ((inv@52@01 n@51@01))
  :pattern ((img@53@01 n@51@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@53@01 r) (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)))
    (= (inv@52@01 r) r))
  :pattern ((inv@52@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@54@01  $FVF<next>) r) r))
  :pattern ((inv@52@01 r))
  :qid |quant-u-180|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@55@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01))
      (img@53@01 r)
      (= r (inv@52@01 r)))
    ($Perm.min
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@56@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01))
      (img@53@01 r)
      (= r (inv@52@01 r)))
    ($Perm.min
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@55@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)) $Perm.Write $Perm.No)
      (pTaken@55@01 r))
    $Perm.No)
  
  :qid |quant-u-182|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@55@01 r) $Perm.No)
  
  :qid |quant-u-183|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01))
      (img@53@01 r)
      (= r (inv@52@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@55@01 r)) $Perm.No))
  
  :qid |quant-u-184|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
        $Perm.Write
        $Perm.No)
      (pTaken@56@01 r))
    $Perm.No)
  
  :qid |quant-u-185|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@56@01 r) $Perm.No)
  
  :qid |quant-u-186|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01))
      (img@53@01 r)
      (= r (inv@52@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@55@01 r)) (pTaken@56@01 r))
      $Perm.No))
  
  :qid |quant-u-187|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@57@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@57@01  $FVF<next>)))
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r)))
    (=>
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r))
      (Set_in r ($FVF.domain_next (as sm@57@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@57@01  $FVF<next>))))
  :qid |qp.fvfDomDef44|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@57@01  $FVF<next>)) (Set_union g0@2@01 g1@3@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01))
    (=
      ($FVF.lookup_next (as sm@54@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@54@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01))
    (=
      ($FVF.lookup_next (as sm@54@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@54@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@54@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef40|)))
(assert (forall ((n@51@01 $Ref)) (!
  (=>
    (Set_in n@51@01 (Set_union g0@2@01 g1@3@01))
    (and (= (inv@52@01 n@51@01) n@51@01) (img@53@01 n@51@01)))
  :pattern ((Set_in n@51@01 (Set_union g0@2@01 g1@3@01)))
  :pattern ((inv@52@01 n@51@01))
  :pattern ((img@53@01 n@51@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@53@01 r) (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)))
    (= (inv@52@01 r) r))
  :pattern ((inv@52@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@57@01  $FVF<next>)))
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r)))
    (=>
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r))
      (Set_in r ($FVF.domain_next (as sm@57@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@57@01  $FVF<next>))))
  :qid |qp.fvfDomDef44|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r))
      (and (img@8@01 r) (Set_in (inv@7@01 r) g0@2@01)))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01)) (img@53@01 r))
      (and (img@13@01 r) (Set_in (inv@12@01 r) g1@3@01)))
    (=
      ($FVF.lookup_next (as sm@57@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@4@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@4@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@57@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@52@01 r) (Set_union g0@2@01 g1@3@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@54@01  $FVF<next>) r) r))
    :pattern ((inv@52@01 r))
    :qid |quant-u-180|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@57@01  $FVF<next>)) (Set_union g0@2@01 g1@3@01))))
(set-option :timeout 0)
(push) ; 3
(assert (not (Set_equal (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@43@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@50@01  $FVF<next>)) g1@3@01)) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@57@01  $FVF<next>)) (Set_union g0@2@01 g1@3@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (Set_equal (Set_union ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@43@01  $FVF<next>)) g0@2@01) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@50@01  $FVF<next>)) g1@3@01)) ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@57@01  $FVF<next>)) (Set_union g0@2@01 g1@3@01))))
(pop) ; 2
(pop) ; 1
; ---------- test_intersection ----------
(declare-const g0@58@01 Set<$Ref>)
(declare-const g1@59@01 Set<$Ref>)
(declare-const g0@60@01 Set<$Ref>)
(declare-const g1@61@01 Set<$Ref>)
(push) ; 1
(declare-const $t@62@01 $Snap)
(assert (= $t@62@01 ($Snap.combine ($Snap.first $t@62@01) ($Snap.second $t@62@01))))
(assert (= ($Snap.first $t@62@01) $Snap.unit))
; [eval] !((null in g0))
; [eval] (null in g0)
(assert (not (Set_in $Ref.null g0@60@01)))
(assert (=
  ($Snap.second $t@62@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@62@01))
    ($Snap.second ($Snap.second $t@62@01)))))
(declare-const n@63@01 $Ref)
(push) ; 2
; [eval] (n in g0)
(assert (Set_in n@63@01 g0@60@01))
(declare-const sm@64@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@65@01 ($Ref) $Ref)
(declare-fun img@66@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@63@01 $Ref) (n2@63@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@63@01 g0@60@01)
      (Set_in n2@63@01 g0@60@01)
      (= n1@63@01 n2@63@01))
    (= n1@63@01 n2@63@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@63@01 $Ref)) (!
  (=>
    (Set_in n@63@01 g0@60@01)
    (and (= (inv@65@01 n@63@01) n@63@01) (img@66@01 n@63@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) n@63@01) n@63@01))
  :qid |quant-u-189|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01)) (= (inv@65@01 r) r))
  :pattern ((inv@65@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@63@01 $Ref)) (!
  (=> (Set_in n@63@01 g0@60@01) (not (= n@63@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) n@63@01) n@63@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@67@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@67@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@65@01 r) g0@60@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) r) r))
  :pattern ((inv@65@01 r))
  :qid |quant-u-190|)))
(assert (=
  ($Snap.second ($Snap.second $t@62@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@62@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@62@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@62@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g0) } { (n$0 in g0), n$0.next } (n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@68@01 $Ref)
(push) ; 2
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 3
; [then-branch: 5 | !(n$0@68@01 in g0@60@01) | live]
; [else-branch: 5 | n$0@68@01 in g0@60@01 | live]
(push) ; 4
; [then-branch: 5 | !(n$0@68@01 in g0@60@01)]
(assert (not (Set_in n$0@68@01 g0@60@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 5 | n$0@68@01 in g0@60@01]
(assert (Set_in n$0@68@01 g0@60@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
      (=
        ($FVF.lookup_next (as sm@67@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
    :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
    :qid |qp.fvfValDef46|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef47|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01))
(push) ; 5
(assert (not (and (img@66@01 n$0@68@01) (Set_in (inv@65@01 n$0@68@01) g0@60@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@67@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (=>
  (Set_in n$0@68@01 g0@60@01)
  (and
    (Set_in n$0@68@01 g0@60@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01))))
(assert (or (Set_in n$0@68@01 g0@60@01) (not (Set_in n$0@68@01 g0@60@01))))
(push) ; 3
; [then-branch: 6 | n$0@68@01 in g0@60@01 && Lookup(next, sm@67@01, n$0@68@01) != Null | live]
; [else-branch: 6 | !(n$0@68@01 in g0@60@01 && Lookup(next, sm@67@01, n$0@68@01) != Null) | live]
(push) ; 4
; [then-branch: 6 | n$0@68@01 in g0@60@01 && Lookup(next, sm@67@01, n$0@68@01) != Null]
(assert (and
  (Set_in n$0@68@01 g0@60@01)
  (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
      (=
        ($FVF.lookup_next (as sm@67@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
    :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
    :qid |qp.fvfValDef46|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef47|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01))
(push) ; 5
(assert (not (and (img@66@01 n$0@68@01) (Set_in (inv@65@01 n$0@68@01) g0@60@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 6 | !(n$0@68@01 in g0@60@01 && Lookup(next, sm@67@01, n$0@68@01) != Null)]
(assert (not
  (and
    (Set_in n$0@68@01 g0@60@01)
    (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@67@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef47|)))
(assert (=>
  (and
    (Set_in n$0@68@01 g0@60@01)
    (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))
  (and
    (Set_in n$0@68@01 g0@60@01)
    (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@68@01 g0@60@01)
      (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))))
  (and
    (Set_in n$0@68@01 g0@60@01)
    (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@67@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@67@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef47|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@68@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@68@01 g0@60@01)
      (and
        (Set_in n$0@68@01 g0@60@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01)))
    (or (Set_in n$0@68@01 g0@60@01) (not (Set_in n$0@68@01 g0@60@01)))
    (=>
      (and
        (Set_in n$0@68@01 g0@60@01)
        (not
          (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))
      (and
        (Set_in n$0@68@01 g0@60@01)
        (not
          (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01)))
    (or
      (not
        (and
          (Set_in n$0@68@01 g0@60@01)
          (not
            (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))))
      (and
        (Set_in n$0@68@01 g0@60@01)
        (not
          (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) g0@60@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@349@14@349@23-aux|)))
(assert (forall ((n$0@68@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@68@01 g0@60@01)
      (and
        (Set_in n$0@68@01 g0@60@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01)))
    (or (Set_in n$0@68@01 g0@60@01) (not (Set_in n$0@68@01 g0@60@01)))
    (=>
      (and
        (Set_in n$0@68@01 g0@60@01)
        (not
          (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))
      (and
        (Set_in n$0@68@01 g0@60@01)
        (not
          (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01)))
    (or
      (not
        (and
          (Set_in n$0@68@01 g0@60@01)
          (not
            (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null))))
      (and
        (Set_in n$0@68@01 g0@60@01)
        (not
          (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))))
  :pattern ((Set_in n$0@68@01 g0@60@01) ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@349@14@349@23-aux|)))
(assert (forall ((n$0@68@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@68@01 g0@60@01)
      (not (= ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) g0@60@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) g0@60@01))
  :pattern ((Set_in n$0@68@01 g0@60@01) ($FVF.loc_next ($FVF.lookup_next (as sm@67@01  $FVF<next>) n$0@68@01) n$0@68@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@349@14@349@23|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@62@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@62@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@62@01))))
  $Snap.unit))
; [eval] !((null in g1))
; [eval] (null in g1)
(assert (not (Set_in $Ref.null g1@61@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01))))))))
(declare-const n$1@69@01 $Ref)
(push) ; 2
; [eval] (n$1 in g1)
(assert (Set_in n$1@69@01 g1@61@01))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@70@01 ($Ref) $Ref)
(declare-fun img@71@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n$11@69@01 $Ref) (n$12@69@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@69@01 g1@61@01)
      (Set_in n$12@69@01 g1@61@01)
      (= n$11@69@01 n$12@69@01))
    (= n$11@69@01 n$12@69@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@69@01 $Ref)) (!
  (=>
    (Set_in n$1@69@01 g1@61@01)
    (and (= (inv@70@01 n$1@69@01) n$1@69@01) (img@71@01 n$1@69@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) n$1@69@01) n$1@69@01))
  :qid |quant-u-192|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01)) (= (inv@70@01 r) r))
  :pattern ((inv@70@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@69@01 $Ref)) (!
  (=> (Set_in n$1@69@01 g1@61@01) (not (= n$1@69@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) n$1@69@01) n$1@69@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 2
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$1@69@01 n@63@01)
    (=
      (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
      (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))))
  
  :qid |quant-u-193|))))
(check-sat)
; unknown
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
(declare-const sm@72@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@70@01 r) g1@61@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) r) r))
  :pattern ((inv@70@01 r))
  :qid |quant-u-194|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01))))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g1) } { (n$2 in g1), n$2.next } (n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@73@01 $Ref)
(set-option :timeout 0)
(push) ; 2
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 3
; [then-branch: 7 | !(n$2@73@01 in g1@61@01) | live]
; [else-branch: 7 | n$2@73@01 in g1@61@01 | live]
(push) ; 4
; [then-branch: 7 | !(n$2@73@01 in g1@61@01)]
(assert (not (Set_in n$2@73@01 g1@61@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 7 | n$2@73@01 in g1@61@01]
(assert (Set_in n$2@73@01 g1@61@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
      (=
        ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
    :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
    :qid |qp.fvfValDef48|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
      (=
        ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r))
    :qid |qp.fvfValDef49|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef50|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@66@01 n$2@73@01) (Set_in (inv@65@01 n$2@73@01) g0@60@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@71@01 n$2@73@01) (Set_in (inv@70@01 n$2@73@01) g1@61@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (=>
  (Set_in n$2@73@01 g1@61@01)
  (and
    (Set_in n$2@73@01 g1@61@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01))))
(assert (or (Set_in n$2@73@01 g1@61@01) (not (Set_in n$2@73@01 g1@61@01))))
(push) ; 3
; [then-branch: 8 | n$2@73@01 in g1@61@01 && Lookup(next, sm@72@01, n$2@73@01) != Null | live]
; [else-branch: 8 | !(n$2@73@01 in g1@61@01 && Lookup(next, sm@72@01, n$2@73@01) != Null) | live]
(push) ; 4
; [then-branch: 8 | n$2@73@01 in g1@61@01 && Lookup(next, sm@72@01, n$2@73@01) != Null]
(assert (and
  (Set_in n$2@73@01 g1@61@01)
  (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
      (=
        ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
    :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
    :qid |qp.fvfValDef48|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
      (=
        ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r))
    :qid |qp.fvfValDef49|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef50|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@66@01 n$2@73@01) (Set_in (inv@65@01 n$2@73@01) g0@60@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@71@01 n$2@73@01) (Set_in (inv@70@01 n$2@73@01) g1@61@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 8 | !(n$2@73@01 in g1@61@01 && Lookup(next, sm@72@01, n$2@73@01) != Null)]
(assert (not
  (and
    (Set_in n$2@73@01 g1@61@01)
    (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef50|)))
(assert (=>
  (and
    (Set_in n$2@73@01 g1@61@01)
    (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))
  (and
    (Set_in n$2@73@01 g1@61@01)
    (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@73@01 g1@61@01)
      (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))))
  (and
    (Set_in n$2@73@01 g1@61@01)
    (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@66@01 r) (Set_in (inv@65@01 r) g0@60@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@71@01 r) (Set_in (inv@70@01 r) g1@61@01))
    (=
      ($FVF.lookup_next (as sm@72@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@62@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@72@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef50|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@73@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@73@01 g1@61@01)
      (and
        (Set_in n$2@73@01 g1@61@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01)))
    (or (Set_in n$2@73@01 g1@61@01) (not (Set_in n$2@73@01 g1@61@01)))
    (=>
      (and
        (Set_in n$2@73@01 g1@61@01)
        (not
          (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))
      (and
        (Set_in n$2@73@01 g1@61@01)
        (not
          (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01)))
    (or
      (not
        (and
          (Set_in n$2@73@01 g1@61@01)
          (not
            (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))))
      (and
        (Set_in n$2@73@01 g1@61@01)
        (not
          (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@349@27@349@36-aux|)))
(assert (forall ((n$2@73@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@73@01 g1@61@01)
      (and
        (Set_in n$2@73@01 g1@61@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01)))
    (or (Set_in n$2@73@01 g1@61@01) (not (Set_in n$2@73@01 g1@61@01)))
    (=>
      (and
        (Set_in n$2@73@01 g1@61@01)
        (not
          (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))
      (and
        (Set_in n$2@73@01 g1@61@01)
        (not
          (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01)))
    (or
      (not
        (and
          (Set_in n$2@73@01 g1@61@01)
          (not
            (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null))))
      (and
        (Set_in n$2@73@01 g1@61@01)
        (not
          (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))))
  :pattern ((Set_in n$2@73@01 g1@61@01) ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@349@27@349@36-aux|)))
(assert (forall ((n$2@73@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@73@01 g1@61@01)
      (not (= ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) g1@61@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) g1@61@01))
  :pattern ((Set_in n$2@73@01 g1@61@01) ($FVF.loc_next ($FVF.lookup_next (as sm@72@01  $FVF<next>) n$2@73@01) n$2@73@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@349@27@349@36|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@62@01))))))
  $Snap.unit))
; [eval] (g0 intersection g1) == Set[Ref]()
; [eval] (g0 intersection g1)
; [eval] Set[Ref]()
(assert (Set_equal (Set_intersection g0@60@01 g1@61@01) (as Set_empty  Set<$Ref>)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; assert (forall r: Ref ::
;     { (r in g0), (r in g1) }
;     (r in g0) ==> !((r in g1))) &&
;   (forall r$0: Ref ::
;     { (r$0 in g0), (r$0 in g1) }
;     (r$0 in g1) ==> !((r$0 in g0)))
; [eval] (forall r: Ref :: { (r in g0), (r in g1) } (r in g0) ==> !((r in g1)))
(declare-const r@74@01 $Ref)
(push) ; 3
; [eval] (r in g0) ==> !((r in g1))
; [eval] (r in g0)
(push) ; 4
; [then-branch: 9 | r@74@01 in g0@60@01 | live]
; [else-branch: 9 | !(r@74@01 in g0@60@01) | live]
(push) ; 5
; [then-branch: 9 | r@74@01 in g0@60@01]
(assert (Set_in r@74@01 g0@60@01))
; [eval] !((r in g1))
; [eval] (r in g1)
(pop) ; 5
(push) ; 5
; [else-branch: 9 | !(r@74@01 in g0@60@01)]
(assert (not (Set_in r@74@01 g0@60@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r@74@01 g0@60@01)) (Set_in r@74@01 g0@60@01)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r@74@01 $Ref)) (!
  (or (not (Set_in r@74@01 g0@60@01)) (Set_in r@74@01 g0@60@01))
  :pattern ((Set_in r@74@01 g0@60@01) (Set_in r@74@01 g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@355@12@355@32-aux|)))
(push) ; 3
(assert (not (forall ((r@74@01 $Ref)) (!
  (=> (Set_in r@74@01 g0@60@01) (not (Set_in r@74@01 g1@61@01)))
  :pattern ((Set_in r@74@01 g0@60@01) (Set_in r@74@01 g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@355@12@355@32|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((r@74@01 $Ref)) (!
  (=> (Set_in r@74@01 g0@60@01) (not (Set_in r@74@01 g1@61@01)))
  :pattern ((Set_in r@74@01 g0@60@01) (Set_in r@74@01 g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@355@12@355@32|)))
; [eval] (forall r$0: Ref :: { (r$0 in g0), (r$0 in g1) } (r$0 in g1) ==> !((r$0 in g0)))
(declare-const r$0@75@01 $Ref)
(push) ; 3
; [eval] (r$0 in g1) ==> !((r$0 in g0))
; [eval] (r$0 in g1)
(push) ; 4
; [then-branch: 10 | r$0@75@01 in g1@61@01 | live]
; [else-branch: 10 | !(r$0@75@01 in g1@61@01) | live]
(push) ; 5
; [then-branch: 10 | r$0@75@01 in g1@61@01]
(assert (Set_in r$0@75@01 g1@61@01))
; [eval] !((r$0 in g0))
; [eval] (r$0 in g0)
(pop) ; 5
(push) ; 5
; [else-branch: 10 | !(r$0@75@01 in g1@61@01)]
(assert (not (Set_in r$0@75@01 g1@61@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r$0@75@01 g1@61@01)) (Set_in r$0@75@01 g1@61@01)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r$0@75@01 $Ref)) (!
  (or (not (Set_in r$0@75@01 g1@61@01)) (Set_in r$0@75@01 g1@61@01))
  :pattern ((Set_in r$0@75@01 g0@60@01) (Set_in r$0@75@01 g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@355@12@355@32-aux|)))
(push) ; 3
(assert (not (forall ((r$0@75@01 $Ref)) (!
  (=> (Set_in r$0@75@01 g1@61@01) (not (Set_in r$0@75@01 g0@60@01)))
  :pattern ((Set_in r$0@75@01 g0@60@01) (Set_in r$0@75@01 g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@355@12@355@32|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((r$0@75@01 $Ref)) (!
  (=> (Set_in r$0@75@01 g1@61@01) (not (Set_in r$0@75@01 g0@60@01)))
  :pattern ((Set_in r$0@75@01 g0@60@01) (Set_in r$0@75@01 g1@61@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@355@12@355@32|)))
(pop) ; 2
(pop) ; 1
; ---------- test_disjoint ----------
(declare-const g0@76@01 Set<$Ref>)
(declare-const g1@77@01 Set<$Ref>)
(declare-const g0@78@01 Set<$Ref>)
(declare-const g1@79@01 Set<$Ref>)
(push) ; 1
(declare-const $t@80@01 $Snap)
(assert (= $t@80@01 ($Snap.combine ($Snap.first $t@80@01) ($Snap.second $t@80@01))))
(assert (= ($Snap.first $t@80@01) $Snap.unit))
; [eval] !((null in g0))
; [eval] (null in g0)
(assert (not (Set_in $Ref.null g0@78@01)))
(assert (=
  ($Snap.second $t@80@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@80@01))
    ($Snap.second ($Snap.second $t@80@01)))))
(declare-const n@81@01 $Ref)
(push) ; 2
; [eval] (n in g0)
(assert (Set_in n@81@01 g0@78@01))
(declare-const sm@82@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@83@01 ($Ref) $Ref)
(declare-fun img@84@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@81@01 $Ref) (n2@81@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@81@01 g0@78@01)
      (Set_in n2@81@01 g0@78@01)
      (= n1@81@01 n2@81@01))
    (= n1@81@01 n2@81@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@81@01 $Ref)) (!
  (=>
    (Set_in n@81@01 g0@78@01)
    (and (= (inv@83@01 n@81@01) n@81@01) (img@84@01 n@81@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) n@81@01) n@81@01))
  :qid |quant-u-196|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)) (= (inv@83@01 r) r))
  :pattern ((inv@83@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@81@01 $Ref)) (!
  (=> (Set_in n@81@01 g0@78@01) (not (= n@81@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) n@81@01) n@81@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@85@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@85@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@83@01 r) g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) r) r))
  :pattern ((inv@83@01 r))
  :qid |quant-u-197|)))
(assert (=
  ($Snap.second ($Snap.second $t@80@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@80@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@80@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g0) } { (n$0 in g0), n$0.next } (n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@86@01 $Ref)
(push) ; 2
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 3
; [then-branch: 11 | !(n$0@86@01 in g0@78@01) | live]
; [else-branch: 11 | n$0@86@01 in g0@78@01 | live]
(push) ; 4
; [then-branch: 11 | !(n$0@86@01 in g0@78@01)]
(assert (not (Set_in n$0@86@01 g0@78@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 11 | n$0@86@01 in g0@78@01]
(assert (Set_in n$0@86@01 g0@78@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@85@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef52|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef53|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01))
(push) ; 5
(assert (not (and (img@84@01 n$0@86@01) (Set_in (inv@83@01 n$0@86@01) g0@78@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@85@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (=>
  (Set_in n$0@86@01 g0@78@01)
  (and
    (Set_in n$0@86@01 g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01))))
(assert (or (Set_in n$0@86@01 g0@78@01) (not (Set_in n$0@86@01 g0@78@01))))
(push) ; 3
; [then-branch: 12 | n$0@86@01 in g0@78@01 && Lookup(next, sm@85@01, n$0@86@01) != Null | live]
; [else-branch: 12 | !(n$0@86@01 in g0@78@01 && Lookup(next, sm@85@01, n$0@86@01) != Null) | live]
(push) ; 4
; [then-branch: 12 | n$0@86@01 in g0@78@01 && Lookup(next, sm@85@01, n$0@86@01) != Null]
(assert (and
  (Set_in n$0@86@01 g0@78@01)
  (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@85@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef52|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef53|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01))
(push) ; 5
(assert (not (and (img@84@01 n$0@86@01) (Set_in (inv@83@01 n$0@86@01) g0@78@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 12 | !(n$0@86@01 in g0@78@01 && Lookup(next, sm@85@01, n$0@86@01) != Null)]
(assert (not
  (and
    (Set_in n$0@86@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@85@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef53|)))
(assert (=>
  (and
    (Set_in n$0@86@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))
  (and
    (Set_in n$0@86@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@86@01 g0@78@01)
      (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))))
  (and
    (Set_in n$0@86@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@85@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@85@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef53|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@86@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@86@01 g0@78@01)
      (and
        (Set_in n$0@86@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01)))
    (or (Set_in n$0@86@01 g0@78@01) (not (Set_in n$0@86@01 g0@78@01)))
    (=>
      (and
        (Set_in n$0@86@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))
      (and
        (Set_in n$0@86@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01)))
    (or
      (not
        (and
          (Set_in n$0@86@01 g0@78@01)
          (not
            (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))))
      (and
        (Set_in n$0@86@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) g0@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@373@14@373@23-aux|)))
(assert (forall ((n$0@86@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@86@01 g0@78@01)
      (and
        (Set_in n$0@86@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01)))
    (or (Set_in n$0@86@01 g0@78@01) (not (Set_in n$0@86@01 g0@78@01)))
    (=>
      (and
        (Set_in n$0@86@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))
      (and
        (Set_in n$0@86@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01)))
    (or
      (not
        (and
          (Set_in n$0@86@01 g0@78@01)
          (not
            (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null))))
      (and
        (Set_in n$0@86@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))))
  :pattern ((Set_in n$0@86@01 g0@78@01) ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@373@14@373@23-aux|)))
(assert (forall ((n$0@86@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@86@01 g0@78@01)
      (not (= ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) g0@78@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) g0@78@01))
  :pattern ((Set_in n$0@86@01 g0@78@01) ($FVF.loc_next ($FVF.lookup_next (as sm@85@01  $FVF<next>) n$0@86@01) n$0@86@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@373@14@373@23|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@80@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@80@01))))
  $Snap.unit))
; [eval] !((null in g1))
; [eval] (null in g1)
(assert (not (Set_in $Ref.null g1@79@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))))
(declare-const n$1@87@01 $Ref)
(push) ; 2
; [eval] (n$1 in g1)
(assert (Set_in n$1@87@01 g1@79@01))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@88@01 ($Ref) $Ref)
(declare-fun img@89@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n$11@87@01 $Ref) (n$12@87@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@87@01 g1@79@01)
      (Set_in n$12@87@01 g1@79@01)
      (= n$11@87@01 n$12@87@01))
    (= n$11@87@01 n$12@87@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@87@01 $Ref)) (!
  (=>
    (Set_in n$1@87@01 g1@79@01)
    (and (= (inv@88@01 n$1@87@01) n$1@87@01) (img@89@01 n$1@87@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) n$1@87@01) n$1@87@01))
  :qid |quant-u-199|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)) (= (inv@88@01 r) r))
  :pattern ((inv@88@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@87@01 $Ref)) (!
  (=> (Set_in n$1@87@01 g1@79@01) (not (= n$1@87@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) n$1@87@01) n$1@87@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 2
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$1@87@01 n@81@01)
    (=
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))))
  
  :qid |quant-u-200|))))
(check-sat)
; unknown
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
(declare-const sm@90@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@88@01 r) g1@79@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) r) r))
  :pattern ((inv@88@01 r))
  :qid |quant-u-201|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g1) } { (n$2 in g1), n$2.next } (n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@91@01 $Ref)
(set-option :timeout 0)
(push) ; 2
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 3
; [then-branch: 13 | !(n$2@91@01 in g1@79@01) | live]
; [else-branch: 13 | n$2@91@01 in g1@79@01 | live]
(push) ; 4
; [then-branch: 13 | !(n$2@91@01 in g1@79@01)]
(assert (not (Set_in n$2@91@01 g1@79@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 13 | n$2@91@01 in g1@79@01]
(assert (Set_in n$2@91@01 g1@79@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef54|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef55|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef56|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$2@91@01) (Set_in (inv@83@01 n$2@91@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$2@91@01) (Set_in (inv@88@01 n$2@91@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (=>
  (Set_in n$2@91@01 g1@79@01)
  (and
    (Set_in n$2@91@01 g1@79@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01))))
(assert (or (Set_in n$2@91@01 g1@79@01) (not (Set_in n$2@91@01 g1@79@01))))
(push) ; 3
; [then-branch: 14 | n$2@91@01 in g1@79@01 && Lookup(next, sm@90@01, n$2@91@01) != Null | live]
; [else-branch: 14 | !(n$2@91@01 in g1@79@01 && Lookup(next, sm@90@01, n$2@91@01) != Null) | live]
(push) ; 4
; [then-branch: 14 | n$2@91@01 in g1@79@01 && Lookup(next, sm@90@01, n$2@91@01) != Null]
(assert (and
  (Set_in n$2@91@01 g1@79@01)
  (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef54|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef55|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef56|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$2@91@01) (Set_in (inv@83@01 n$2@91@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$2@91@01) (Set_in (inv@88@01 n$2@91@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 14 | !(n$2@91@01 in g1@79@01 && Lookup(next, sm@90@01, n$2@91@01) != Null)]
(assert (not
  (and
    (Set_in n$2@91@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef56|)))
(assert (=>
  (and
    (Set_in n$2@91@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))
  (and
    (Set_in n$2@91@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@91@01 g1@79@01)
      (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))))
  (and
    (Set_in n$2@91@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@90@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@90@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef56|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@91@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@91@01 g1@79@01)
      (and
        (Set_in n$2@91@01 g1@79@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01)))
    (or (Set_in n$2@91@01 g1@79@01) (not (Set_in n$2@91@01 g1@79@01)))
    (=>
      (and
        (Set_in n$2@91@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))
      (and
        (Set_in n$2@91@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01)))
    (or
      (not
        (and
          (Set_in n$2@91@01 g1@79@01)
          (not
            (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))))
      (and
        (Set_in n$2@91@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) g1@79@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@373@27@373@36-aux|)))
(assert (forall ((n$2@91@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@91@01 g1@79@01)
      (and
        (Set_in n$2@91@01 g1@79@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01)))
    (or (Set_in n$2@91@01 g1@79@01) (not (Set_in n$2@91@01 g1@79@01)))
    (=>
      (and
        (Set_in n$2@91@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))
      (and
        (Set_in n$2@91@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01)))
    (or
      (not
        (and
          (Set_in n$2@91@01 g1@79@01)
          (not
            (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null))))
      (and
        (Set_in n$2@91@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))))
  :pattern ((Set_in n$2@91@01 g1@79@01) ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@373@27@373@36-aux|)))
(assert (forall ((n$2@91@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@91@01 g1@79@01)
      (not (= ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) g1@79@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) g1@79@01))
  :pattern ((Set_in n$2@91@01 g1@79@01) ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n$2@91@01) n$2@91@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@373@27@373@36|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01))))))
  $Snap.unit))
; [eval] (g0 intersection g1) == Set[Ref]()
; [eval] (g0 intersection g1)
; [eval] Set[Ref]()
(assert (Set_equal (Set_intersection g0@78@01 g1@79@01) (as Set_empty  Set<$Ref>)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@92@01 $Snap)
(assert (= $t@92@01 ($Snap.combine ($Snap.first $t@92@01) ($Snap.second $t@92@01))))
(assert (= ($Snap.first $t@92@01) $Snap.unit))
; [eval] !((null in (g0 union g1)))
; [eval] (null in (g0 union g1))
; [eval] (g0 union g1)
(assert (not (Set_in $Ref.null (Set_union g0@78@01 g1@79@01))))
(assert (=
  ($Snap.second $t@92@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@92@01))
    ($Snap.second ($Snap.second $t@92@01)))))
(declare-const n$3@93@01 $Ref)
(push) ; 3
; [eval] (n$3 in (g0 union g1))
; [eval] (g0 union g1)
(assert (Set_in n$3@93@01 (Set_union g0@78@01 g1@79@01)))
(declare-const sm@94@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@95@01 ($Ref) $Ref)
(declare-fun img@96@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$31@93@01 $Ref) (n$32@93@01 $Ref)) (!
  (=>
    (and
      (Set_in n$31@93@01 (Set_union g0@78@01 g1@79@01))
      (Set_in n$32@93@01 (Set_union g0@78@01 g1@79@01))
      (= n$31@93@01 n$32@93@01))
    (= n$31@93@01 n$32@93@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$3@93@01 $Ref)) (!
  (=>
    (Set_in n$3@93@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@95@01 n$3@93@01) n$3@93@01) (img@96@01 n$3@93@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) n$3@93@01) n$3@93@01))
  :qid |quant-u-203|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@95@01 r) r))
  :pattern ((inv@95@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$3@93@01 $Ref)) (!
  (=>
    (Set_in n$3@93@01 (Set_union g0@78@01 g1@79@01))
    (not (= n$3@93@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) n$3@93@01) n$3@93@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@97@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@97@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
  :pattern ((inv@95@01 r))
  :qid |quant-u-204|)))
(assert (=
  ($Snap.second ($Snap.second $t@92@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@92@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@92@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@92@01))) $Snap.unit))
; [eval] (forall n$4: Ref :: { (n$4.next in (g0 union g1)) } { (n$4 in (g0 union g1)), n$4.next } (n$4 in (g0 union g1)) && n$4.next != null ==> (n$4.next in (g0 union g1)))
(declare-const n$4@98@01 $Ref)
(push) ; 3
; [eval] (n$4 in (g0 union g1)) && n$4.next != null ==> (n$4.next in (g0 union g1))
; [eval] (n$4 in (g0 union g1)) && n$4.next != null
; [eval] (n$4 in (g0 union g1))
; [eval] (g0 union g1)
(push) ; 4
; [then-branch: 15 | !(n$4@98@01 in g0@78@01 ∪ g1@79@01) | live]
; [else-branch: 15 | n$4@98@01 in g0@78@01 ∪ g1@79@01 | live]
(push) ; 5
; [then-branch: 15 | !(n$4@98@01 in g0@78@01 ∪ g1@79@01)]
(assert (not (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 15 | n$4@98@01 in g0@78@01 ∪ g1@79@01]
(assert (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01)))
; [eval] n$4.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
      (=
        ($FVF.lookup_next (as sm@97@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
    :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
    :qid |qp.fvfValDef58|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef59|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01))
(push) ; 6
(assert (not (and
  (img@96@01 n$4@98@01)
  (Set_in (inv@95@01 n$4@98@01) (Set_union g0@78@01 g1@79@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@97@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
(assert (=>
  (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
  (and
    (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01))))
(assert (or
  (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
  (not (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01)))))
(push) ; 4
; [then-branch: 16 | n$4@98@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@97@01, n$4@98@01) != Null | live]
; [else-branch: 16 | !(n$4@98@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@97@01, n$4@98@01) != Null) | live]
(push) ; 5
; [then-branch: 16 | n$4@98@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@97@01, n$4@98@01) != Null]
(assert (and
  (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
  (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))))
; [eval] (n$4.next in (g0 union g1))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
      (=
        ($FVF.lookup_next (as sm@97@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
    :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
    :qid |qp.fvfValDef58|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef59|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01))
(push) ; 6
(assert (not (and
  (img@96@01 n$4@98@01)
  (Set_in (inv@95@01 n$4@98@01) (Set_union g0@78@01 g1@79@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; [eval] (g0 union g1)
(pop) ; 5
(push) ; 5
; [else-branch: 16 | !(n$4@98@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@97@01, n$4@98@01) != Null)]
(assert (not
  (and
    (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@97@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
(assert (=>
  (and
    (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))
  (and
    (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
      (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))))
  (and
    (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@97@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@97@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef59|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@98@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01)))
    (or
      (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
      (not (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))))
    (=>
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01)))
    (or
      (not
        (and
          (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
          (not
            (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))))
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) (Set_union g0@78@01 g1@79@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31-aux|)))
(assert (forall ((n$4@98@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01)))
    (or
      (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
      (not (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))))
    (=>
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01)))
    (or
      (not
        (and
          (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
          (not
            (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null))))
      (and
        (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))))
  :pattern ((Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31-aux|)))
(assert (forall ((n$4@98@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01))
      (not (= ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in n$4@98@01 (Set_union g0@78@01 g1@79@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n$4@98@01) n$4@98@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@92@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@92@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@92@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@92@01))))
  $Snap.unit))
; [eval] (forall u: Ref, v: Ref :: { (u in g0), (v in g1) } { (u in g0), exists_path($$((g0 union g1)), u, v) } { (v in g1), exists_path($$((g0 union g1)), u, v) } { exists_path($$((g0 union g1)), u, v) } (u in g0) && (v in g1) ==> !exists_path($$((g0 union g1)), u, v))
(declare-const u@99@01 $Ref)
(declare-const v@100@01 $Ref)
(push) ; 3
; [eval] (u in g0) && (v in g1) ==> !exists_path($$((g0 union g1)), u, v)
; [eval] (u in g0) && (v in g1)
; [eval] (u in g0)
(push) ; 4
; [then-branch: 17 | !(u@99@01 in g0@78@01) | live]
; [else-branch: 17 | u@99@01 in g0@78@01 | live]
(push) ; 5
; [then-branch: 17 | !(u@99@01 in g0@78@01)]
(assert (not (Set_in u@99@01 g0@78@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 17 | u@99@01 in g0@78@01]
(assert (Set_in u@99@01 g0@78@01))
; [eval] (v in g1)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in u@99@01 g0@78@01) (not (Set_in u@99@01 g0@78@01))))
(push) ; 4
; [then-branch: 18 | u@99@01 in g0@78@01 && v@100@01 in g1@79@01 | live]
; [else-branch: 18 | !(u@99@01 in g0@78@01 && v@100@01 in g1@79@01) | live]
(push) ; 5
; [then-branch: 18 | u@99@01 in g0@78@01 && v@100@01 in g1@79@01]
(assert (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01)))
; [eval] !exists_path($$((g0 union g1)), u, v)
; [eval] exists_path($$((g0 union g1)), u, v)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 6
(declare-const n@101@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@101@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 7
(declare-fun inv@102@01 ($Ref) $Ref)
(declare-fun img@103@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@101@01 $Ref) (n2@101@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@101@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n1@101@01) n1@101@01))
      (and
        (Set_in n2@101@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n2@101@01) n2@101@01))
      (= n1@101@01 n2@101@01))
    (= n1@101@01 n2@101@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@101@01 $Ref)) (!
  (=>
    (Set_in n@101@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@102@01 n@101@01) n@101@01) (img@103@01 n@101@01)))
  :pattern ((Set_in n@101@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@102@01 n@101@01))
  :pattern ((img@103@01 n@101@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@103@01 r) (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@102@01 r) r))
  :pattern ((inv@102@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
  :pattern ((inv@102@01 r))
  :qid |quant-u-206|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@104@01 ((r $Ref) (u@99@01 $Ref) (v@100@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
      (img@103@01 r)
      (= r (inv@102@01 r)))
    ($Perm.min
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@104@01 r u@99@01 v@100@01))
    $Perm.No)
  
  :qid |quant-u-208|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@104@01 r u@99@01 v@100@01) $Perm.No)
  
  :qid |quant-u-209|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
      (img@103@01 r)
      (= r (inv@102@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@104@01 r u@99@01 v@100@01))
      $Perm.No))
  
  :qid |quant-u-210|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@105@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r)))
    (=>
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>))))
  :qid |qp.fvfDomDef62|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@105@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@101@01 $Ref)) (!
  (=>
    (Set_in n@101@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@102@01 n@101@01) n@101@01) (img@103@01 n@101@01)))
  :pattern ((Set_in n@101@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@102@01 n@101@01))
  :pattern ((img@103@01 n@101@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@103@01 r) (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@102@01 r) r))
  :pattern ((inv@102@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r)))
    (=>
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>))))
  :qid |qp.fvfDomDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@105@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
    :pattern ((inv@102@01 r))
    :qid |quant-u-206|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 18 | !(u@99@01 in g0@78@01 && v@100@01 in g1@79@01)]
(assert (not (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((n@101@01 $Ref)) (!
  (=>
    (Set_in n@101@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@102@01 n@101@01) n@101@01) (img@103@01 n@101@01)))
  :pattern ((Set_in n@101@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@102@01 n@101@01))
  :pattern ((img@103@01 n@101@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@103@01 r) (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@102@01 r) r))
  :pattern ((inv@102@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r)))
    (=>
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>))))
  :qid |qp.fvfDomDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@105@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef61|)))
(assert (=>
  (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
  (and
    (Set_in u@99@01 g0@78@01)
    (Set_in v@100@01 g1@79@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
      :pattern ((inv@102@01 r))
      :qid |quant-u-206|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))))
; Joined path conditions
(assert (or
  (not (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01)))
  (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@101@01 $Ref)) (!
  (=>
    (Set_in n@101@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@102@01 n@101@01) n@101@01) (img@103@01 n@101@01)))
  :pattern ((Set_in n@101@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@102@01 n@101@01))
  :pattern ((img@103@01 n@101@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@103@01 r) (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@102@01 r) r))
  :pattern ((inv@102@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r)))
    (=>
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@105@01  $FVF<next>))))
  :qid |qp.fvfDomDef62|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01)) (img@103@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@105@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@105@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef61|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@99@01 $Ref) (v@100@01 $Ref)) (!
  (and
    (or (Set_in u@99@01 g0@78@01) (not (Set_in u@99@01 g0@78@01)))
    (=>
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
      (and
        (Set_in u@99@01 g0@78@01)
        (Set_in v@100@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
          :pattern ((inv@102@01 r))
          :qid |quant-u-206|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01)))
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))))
  :pattern ((Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@99@01 $Ref) (v@100@01 $Ref)) (!
  (and
    (or (Set_in u@99@01 g0@78@01) (not (Set_in u@99@01 g0@78@01)))
    (=>
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
      (and
        (Set_in u@99@01 g0@78@01)
        (Set_in v@100@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
          :pattern ((inv@102@01 r))
          :qid |quant-u-206|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01)))
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))))
  :pattern ((Set_in u@99@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@99@01 $Ref) (v@100@01 $Ref)) (!
  (and
    (or (Set_in u@99@01 g0@78@01) (not (Set_in u@99@01 g0@78@01)))
    (=>
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
      (and
        (Set_in u@99@01 g0@78@01)
        (Set_in v@100@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
          :pattern ((inv@102@01 r))
          :qid |quant-u-206|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01)))
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))))
  :pattern ((Set_in v@100@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@99@01 $Ref) (v@100@01 $Ref)) (!
  (and
    (or (Set_in u@99@01 g0@78@01) (not (Set_in u@99@01 g0@78@01)))
    (=>
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
      (and
        (Set_in u@99@01 g0@78@01)
        (Set_in v@100@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@102@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
          :pattern ((inv@102@01 r))
          :qid |quant-u-206|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01)))
      (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@99@01 $Ref) (v@100@01 $Ref)) (!
  (=>
    (and (Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01)))
  :pattern ((Set_in u@99@01 g0@78@01) (Set_in v@100@01 g1@79@01))
  :pattern ((Set_in u@99@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01))
  :pattern ((Set_in v@100@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@105@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@99@01 v@100@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@92@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@92@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@92@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@92@01)))))
  $Snap.unit))
; [eval] (forall u: Ref, v: Ref :: { (u in g0), (v in g0) } { (u in g0), exists_path($$(g0), u, v) } { (u in g0), exists_path($$((g0 union g1)), u, v) } { (v in g0), exists_path($$(g0), u, v) } { (v in g0), exists_path($$((g0 union g1)), u, v) } { exists_path($$(g0), u, v) } { exists_path($$((g0 union g1)), u, v) } (u in g0) && ((v in g0) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v))
(declare-const u@106@01 $Ref)
(declare-const v@107@01 $Ref)
(push) ; 3
; [eval] (u in g0) && ((v in g0) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v)
; [eval] (u in g0) && ((v in g0) && exists_path($$(g0), u, v))
; [eval] (u in g0)
(push) ; 4
; [then-branch: 19 | !(u@106@01 in g0@78@01) | live]
; [else-branch: 19 | u@106@01 in g0@78@01 | live]
(push) ; 5
; [then-branch: 19 | !(u@106@01 in g0@78@01)]
(assert (not (Set_in u@106@01 g0@78@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 19 | u@106@01 in g0@78@01]
(assert (Set_in u@106@01 g0@78@01))
; [eval] (v in g0)
(push) ; 6
; [then-branch: 20 | !(v@107@01 in g0@78@01) | live]
; [else-branch: 20 | v@107@01 in g0@78@01 | live]
(push) ; 7
; [then-branch: 20 | !(v@107@01 in g0@78@01)]
(assert (not (Set_in v@107@01 g0@78@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 20 | v@107@01 in g0@78@01]
(assert (Set_in v@107@01 g0@78@01))
; [eval] exists_path($$(g0), u, v)
; [eval] $$(g0)
(push) ; 8
(declare-const n@108@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@108@01 g0@78@01))
(pop) ; 9
(declare-fun inv@109@01 ($Ref) $Ref)
(declare-fun img@110@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@108@01 $Ref) (n2@108@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@108@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n1@108@01) n1@108@01))
      (and
        (Set_in n2@108@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) n2@108@01) n2@108@01))
      (= n1@108@01 n2@108@01))
    (= n1@108@01 n2@108@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@108@01 $Ref)) (!
  (=>
    (Set_in n@108@01 g0@78@01)
    (and (= (inv@109@01 n@108@01) n@108@01) (img@110@01 n@108@01)))
  :pattern ((Set_in n@108@01 g0@78@01))
  :pattern ((inv@109@01 n@108@01))
  :pattern ((img@110@01 n@108@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@110@01 r) (Set_in (inv@109@01 r) g0@78@01)) (= (inv@109@01 r) r))
  :pattern ((inv@109@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@109@01 r) g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
  :pattern ((inv@109@01 r))
  :qid |quant-u-212|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@111@01 ((r $Ref) (u@106@01 $Ref) (v@107@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r) (= r (inv@109@01 r)))
    ($Perm.min
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@111@01 r u@106@01 v@107@01))
    $Perm.No)
  
  :qid |quant-u-214|))))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@111@01 r u@106@01 v@107@01) $Perm.No)
  
  :qid |quant-u-215|))))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r) (= r (inv@109@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@111@01 r u@106@01 v@107@01))
      $Perm.No))
  
  :qid |quant-u-216|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@112@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r)))
    (=>
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@112@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@108@01 $Ref)) (!
  (=>
    (Set_in n@108@01 g0@78@01)
    (and (= (inv@109@01 n@108@01) n@108@01) (img@110@01 n@108@01)))
  :pattern ((Set_in n@108@01 g0@78@01))
  :pattern ((inv@109@01 n@108@01))
  :pattern ((img@110@01 n@108@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@110@01 r) (Set_in (inv@109@01 r) g0@78@01)) (= (inv@109@01 r) r))
  :pattern ((inv@109@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r)))
    (=>
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@112@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@109@01 r) g0@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
    :pattern ((inv@109@01 r))
    :qid |quant-u-212|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((n@108@01 $Ref)) (!
  (=>
    (Set_in n@108@01 g0@78@01)
    (and (= (inv@109@01 n@108@01) n@108@01) (img@110@01 n@108@01)))
  :pattern ((Set_in n@108@01 g0@78@01))
  :pattern ((inv@109@01 n@108@01))
  :pattern ((img@110@01 n@108@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@110@01 r) (Set_in (inv@109@01 r) g0@78@01)) (= (inv@109@01 r) r))
  :pattern ((inv@109@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r)))
    (=>
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@112@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (=>
  (Set_in v@107@01 g0@78@01)
  (and
    (Set_in v@107@01 g0@78@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@109@01 r) g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
      :pattern ((inv@109@01 r))
      :qid |quant-u-212|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01))))
(assert (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((n@108@01 $Ref)) (!
  (=>
    (Set_in n@108@01 g0@78@01)
    (and (= (inv@109@01 n@108@01) n@108@01) (img@110@01 n@108@01)))
  :pattern ((Set_in n@108@01 g0@78@01))
  :pattern ((inv@109@01 n@108@01))
  :pattern ((img@110@01 n@108@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@110@01 r) (Set_in (inv@109@01 r) g0@78@01)) (= (inv@109@01 r) r))
  :pattern ((inv@109@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r)))
    (=>
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@112@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (=>
  (Set_in u@106@01 g0@78@01)
  (and
    (Set_in u@106@01 g0@78@01)
    (=>
      (Set_in v@107@01 g0@78@01)
      (and
        (Set_in v@107@01 g0@78@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@109@01 r) g0@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
          :pattern ((inv@109@01 r))
          :qid |quant-u-212|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
    (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01))))))
(assert (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 21 | u@106@01 in g0@78@01 && v@107@01 in g0@78@01 && exists_path[Bool]($$(sm@112@01, g0@78@01), u@106@01, v@107@01) | live]
; [else-branch: 21 | !(u@106@01 in g0@78@01 && v@107@01 in g0@78@01 && exists_path[Bool]($$(sm@112@01, g0@78@01), u@106@01, v@107@01)) | live]
(push) ; 5
; [then-branch: 21 | u@106@01 in g0@78@01 && v@107@01 in g0@78@01 && exists_path[Bool]($$(sm@112@01, g0@78@01), u@106@01, v@107@01)]
(assert (and
  (Set_in u@106@01 g0@78@01)
  (and
    (Set_in v@107@01 g0@78@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
; [eval] exists_path($$((g0 union g1)), u, v)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 6
(declare-const n@113@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@113@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 7
(declare-fun inv@114@01 ($Ref) $Ref)
(declare-fun img@115@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@116@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@116@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef67|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@113@01 $Ref) (n2@113@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@113@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) n1@113@01) n1@113@01))
      (and
        (Set_in n2@113@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) n2@113@01) n2@113@01))
      (= n1@113@01 n2@113@01))
    (= n1@113@01 n2@113@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@113@01 $Ref)) (!
  (=>
    (Set_in n@113@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@114@01 n@113@01) n@113@01) (img@115@01 n@113@01)))
  :pattern ((Set_in n@113@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@114@01 n@113@01))
  :pattern ((img@115@01 n@113@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@115@01 r) (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@114@01 r) r))
  :pattern ((inv@114@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
  :pattern ((inv@114@01 r))
  :qid |quant-u-218|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@117@01 ((r $Ref) (u@106@01 $Ref) (v@107@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
      (img@115@01 r)
      (= r (inv@114@01 r)))
    ($Perm.min
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@117@01 r u@106@01 v@107@01))
    $Perm.No)
  
  :qid |quant-u-220|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@117@01 r u@106@01 v@107@01) $Perm.No)
  
  :qid |quant-u-221|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
      (img@115@01 r)
      (= r (inv@114@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@117@01 r u@106@01 v@107@01))
      $Perm.No))
  
  :qid |quant-u-222|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@118@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r)))
    (=>
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>))))
  :qid |qp.fvfDomDef70|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@118@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@116@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef67|)))
(assert (forall ((n@113@01 $Ref)) (!
  (=>
    (Set_in n@113@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@114@01 n@113@01) n@113@01) (img@115@01 n@113@01)))
  :pattern ((Set_in n@113@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@114@01 n@113@01))
  :pattern ((img@115@01 n@113@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@115@01 r) (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@114@01 r) r))
  :pattern ((inv@114@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r)))
    (=>
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>))))
  :qid |qp.fvfDomDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@118@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
    :pattern ((inv@114@01 r))
    :qid |quant-u-218|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 21 | !(u@106@01 in g0@78@01 && v@107@01 in g0@78@01 && exists_path[Bool]($$(sm@112@01, g0@78@01), u@106@01, v@107@01))]
(assert (not
  (and
    (Set_in u@106@01 g0@78@01)
    (and
      (Set_in v@107@01 g0@78@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@116@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef67|)))
(assert (forall ((n@113@01 $Ref)) (!
  (=>
    (Set_in n@113@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@114@01 n@113@01) n@113@01) (img@115@01 n@113@01)))
  :pattern ((Set_in n@113@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@114@01 n@113@01))
  :pattern ((img@115@01 n@113@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@115@01 r) (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@114@01 r) r))
  :pattern ((inv@114@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r)))
    (=>
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>))))
  :qid |qp.fvfDomDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@118@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef69|)))
(assert (=>
  (and
    (Set_in u@106@01 g0@78@01)
    (and
      (Set_in v@107@01 g0@78@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
  (and
    (Set_in u@106@01 g0@78@01)
    (Set_in v@107@01 g0@78@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
      :pattern ((inv@114@01 r))
      :qid |quant-u-218|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
  (and
    (Set_in u@106@01 g0@78@01)
    (and
      (Set_in v@107@01 g0@78@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@108@01 $Ref)) (!
  (=>
    (Set_in n@108@01 g0@78@01)
    (and (= (inv@109@01 n@108@01) n@108@01) (img@110@01 n@108@01)))
  :pattern ((Set_in n@108@01 g0@78@01))
  :pattern ((inv@109@01 n@108@01))
  :pattern ((img@110@01 n@108@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@110@01 r) (Set_in (inv@109@01 r) g0@78@01)) (= (inv@109@01 r) r))
  :pattern ((inv@109@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r)))
    (=>
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@112@01  $FVF<next>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@109@01 r) g0@78@01) (img@110@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@112@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@112@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@116@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@116@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef67|)))
(assert (forall ((n@113@01 $Ref)) (!
  (=>
    (Set_in n@113@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@114@01 n@113@01) n@113@01) (img@115@01 n@113@01)))
  :pattern ((Set_in n@113@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@114@01 n@113@01))
  :pattern ((img@115@01 n@113@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@115@01 r) (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@114@01 r) r))
  :pattern ((inv@114@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r)))
    (=>
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@118@01  $FVF<next>))))
  :qid |qp.fvfDomDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01)) (img@115@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@118@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@118@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef69|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((Set_in u@106@01 g0@78@01) (Set_in v@107@01 g0@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((Set_in u@106@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((Set_in u@106@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((Set_in v@107@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((Set_in v@107@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (and
    (=>
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in u@106@01 g0@78@01)
        (=>
          (Set_in v@107@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@109@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@97@01  $FVF<next>) r) r))
              :pattern ((inv@109@01 r))
              :qid |quant-u-212|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@107@01 g0@78@01) (not (Set_in v@107@01 g0@78@01)))))
    (or (Set_in u@106@01 g0@78@01) (not (Set_in u@106@01 g0@78@01)))
    (=>
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
      (and
        (Set_in u@106@01 g0@78@01)
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@114@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@116@01  $FVF<next>) r) r))
          :pattern ((inv@114@01 r))
          :qid |quant-u-218|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@106@01 g0@78@01)
          (and
            (Set_in v@107@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))))
      (and
        (Set_in u@106@01 g0@78@01)
        (and
          (Set_in v@107@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@106@01 $Ref) (v@107@01 $Ref)) (!
  (=>
    (and
      (Set_in u@106@01 g0@78@01)
      (and
        (Set_in v@107@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01)))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :pattern ((Set_in u@106@01 g0@78@01) (Set_in v@107@01 g0@78@01))
  :pattern ((Set_in u@106@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))
  :pattern ((Set_in u@106@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :pattern ((Set_in v@107@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))
  :pattern ((Set_in v@107@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@112@01  $FVF<next>)) g0@78@01) u@106@01 v@107@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@118@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@106@01 v@107@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@92@01)))))
  $Snap.unit))
; [eval] (forall u: Ref, v: Ref :: { (u in g1), (v in g1) } { (u in g1), exists_path($$(g0), u, v) } { (u in g1), exists_path($$((g0 union g1)), u, v) } { (v in g1), exists_path($$(g0), u, v) } { (v in g1), exists_path($$((g0 union g1)), u, v) } { exists_path($$(g0), u, v) } { exists_path($$((g0 union g1)), u, v) } (u in g1) && ((v in g1) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v))
(declare-const u@119@01 $Ref)
(declare-const v@120@01 $Ref)
(push) ; 3
; [eval] (u in g1) && ((v in g1) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v)
; [eval] (u in g1) && ((v in g1) && exists_path($$(g0), u, v))
; [eval] (u in g1)
(push) ; 4
; [then-branch: 22 | !(u@119@01 in g1@79@01) | live]
; [else-branch: 22 | u@119@01 in g1@79@01 | live]
(push) ; 5
; [then-branch: 22 | !(u@119@01 in g1@79@01)]
(assert (not (Set_in u@119@01 g1@79@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 22 | u@119@01 in g1@79@01]
(assert (Set_in u@119@01 g1@79@01))
; [eval] (v in g1)
(push) ; 6
; [then-branch: 23 | !(v@120@01 in g1@79@01) | live]
; [else-branch: 23 | v@120@01 in g1@79@01 | live]
(push) ; 7
; [then-branch: 23 | !(v@120@01 in g1@79@01)]
(assert (not (Set_in v@120@01 g1@79@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 23 | v@120@01 in g1@79@01]
(assert (Set_in v@120@01 g1@79@01))
; [eval] exists_path($$(g0), u, v)
; [eval] $$(g0)
(push) ; 8
(declare-const n@121@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@121@01 g0@78@01))
(pop) ; 9
(declare-fun inv@122@01 ($Ref) $Ref)
(declare-fun img@123@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@124@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@124@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@121@01 $Ref) (n2@121@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@121@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) n1@121@01) n1@121@01))
      (and
        (Set_in n2@121@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) n2@121@01) n2@121@01))
      (= n1@121@01 n2@121@01))
    (= n1@121@01 n2@121@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@121@01 $Ref)) (!
  (=>
    (Set_in n@121@01 g0@78@01)
    (and (= (inv@122@01 n@121@01) n@121@01) (img@123@01 n@121@01)))
  :pattern ((Set_in n@121@01 g0@78@01))
  :pattern ((inv@122@01 n@121@01))
  :pattern ((img@123@01 n@121@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@123@01 r) (Set_in (inv@122@01 r) g0@78@01)) (= (inv@122@01 r) r))
  :pattern ((inv@122@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@122@01 r) g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
  :pattern ((inv@122@01 r))
  :qid |quant-u-224|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@125@01 ((r $Ref) (u@119@01 $Ref) (v@120@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r) (= r (inv@122@01 r)))
    ($Perm.min
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@125@01 r u@119@01 v@120@01))
    $Perm.No)
  
  :qid |quant-u-226|))))
(check-sat)
; unknown
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@125@01 r u@119@01 v@120@01) $Perm.No)
  
  :qid |quant-u-227|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r) (= r (inv@122@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@125@01 r u@119@01 v@120@01))
      $Perm.No))
  
  :qid |quant-u-228|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@126@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r)))
    (=>
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>))))
  :qid |qp.fvfDomDef75|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@126@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef74|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@124@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((n@121@01 $Ref)) (!
  (=>
    (Set_in n@121@01 g0@78@01)
    (and (= (inv@122@01 n@121@01) n@121@01) (img@123@01 n@121@01)))
  :pattern ((Set_in n@121@01 g0@78@01))
  :pattern ((inv@122@01 n@121@01))
  :pattern ((img@123@01 n@121@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@123@01 r) (Set_in (inv@122@01 r) g0@78@01)) (= (inv@122@01 r) r))
  :pattern ((inv@122@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r)))
    (=>
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>))))
  :qid |qp.fvfDomDef75|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@126@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef74|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@122@01 r) g0@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
    :pattern ((inv@122@01 r))
    :qid |quant-u-224|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@124@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((n@121@01 $Ref)) (!
  (=>
    (Set_in n@121@01 g0@78@01)
    (and (= (inv@122@01 n@121@01) n@121@01) (img@123@01 n@121@01)))
  :pattern ((Set_in n@121@01 g0@78@01))
  :pattern ((inv@122@01 n@121@01))
  :pattern ((img@123@01 n@121@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@123@01 r) (Set_in (inv@122@01 r) g0@78@01)) (= (inv@122@01 r) r))
  :pattern ((inv@122@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r)))
    (=>
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>))))
  :qid |qp.fvfDomDef75|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@126@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef74|)))
(assert (=>
  (Set_in v@120@01 g1@79@01)
  (and
    (Set_in v@120@01 g1@79@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@122@01 r) g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
      :pattern ((inv@122@01 r))
      :qid |quant-u-224|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01))))
(assert (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@124@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((n@121@01 $Ref)) (!
  (=>
    (Set_in n@121@01 g0@78@01)
    (and (= (inv@122@01 n@121@01) n@121@01) (img@123@01 n@121@01)))
  :pattern ((Set_in n@121@01 g0@78@01))
  :pattern ((inv@122@01 n@121@01))
  :pattern ((img@123@01 n@121@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@123@01 r) (Set_in (inv@122@01 r) g0@78@01)) (= (inv@122@01 r) r))
  :pattern ((inv@122@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r)))
    (=>
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>))))
  :qid |qp.fvfDomDef75|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@126@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef74|)))
(assert (=>
  (Set_in u@119@01 g1@79@01)
  (and
    (Set_in u@119@01 g1@79@01)
    (=>
      (Set_in v@120@01 g1@79@01)
      (and
        (Set_in v@120@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@122@01 r) g0@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
          :pattern ((inv@122@01 r))
          :qid |quant-u-224|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
    (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01))))))
(assert (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 24 | u@119@01 in g1@79@01 && v@120@01 in g1@79@01 && exists_path[Bool]($$(sm@126@01, g0@78@01), u@119@01, v@120@01) | live]
; [else-branch: 24 | !(u@119@01 in g1@79@01 && v@120@01 in g1@79@01 && exists_path[Bool]($$(sm@126@01, g0@78@01), u@119@01, v@120@01)) | live]
(push) ; 5
; [then-branch: 24 | u@119@01 in g1@79@01 && v@120@01 in g1@79@01 && exists_path[Bool]($$(sm@126@01, g0@78@01), u@119@01, v@120@01)]
(assert (and
  (Set_in u@119@01 g1@79@01)
  (and
    (Set_in v@120@01 g1@79@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
; [eval] exists_path($$((g0 union g1)), u, v)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 6
(declare-const n@127@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@127@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 7
(declare-fun inv@128@01 ($Ref) $Ref)
(declare-fun img@129@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@130@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@130@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef77|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@127@01 $Ref) (n2@127@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@127@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) n1@127@01) n1@127@01))
      (and
        (Set_in n2@127@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) n2@127@01) n2@127@01))
      (= n1@127@01 n2@127@01))
    (= n1@127@01 n2@127@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@127@01 $Ref)) (!
  (=>
    (Set_in n@127@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@128@01 n@127@01) n@127@01) (img@129@01 n@127@01)))
  :pattern ((Set_in n@127@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@128@01 n@127@01))
  :pattern ((img@129@01 n@127@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@129@01 r) (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@128@01 r) r))
  :pattern ((inv@128@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
  :pattern ((inv@128@01 r))
  :qid |quant-u-230|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@131@01 ((r $Ref) (u@119@01 $Ref) (v@120@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
      (img@129@01 r)
      (= r (inv@128@01 r)))
    ($Perm.min
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@131@01 r u@119@01 v@120@01))
    $Perm.No)
  
  :qid |quant-u-232|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@131@01 r u@119@01 v@120@01) $Perm.No)
  
  :qid |quant-u-233|))))
(check-sat)
; unknown
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
      (img@129@01 r)
      (= r (inv@128@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@131@01 r u@119@01 v@120@01))
      $Perm.No))
  
  :qid |quant-u-234|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@132@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r)))
    (=>
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>))))
  :qid |qp.fvfDomDef80|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef79|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@130@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef77|)))
(assert (forall ((n@127@01 $Ref)) (!
  (=>
    (Set_in n@127@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@128@01 n@127@01) n@127@01) (img@129@01 n@127@01)))
  :pattern ((Set_in n@127@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@128@01 n@127@01))
  :pattern ((img@129@01 n@127@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@129@01 r) (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@128@01 r) r))
  :pattern ((inv@128@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r)))
    (=>
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
    :pattern ((inv@128@01 r))
    :qid |quant-u-230|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 24 | !(u@119@01 in g1@79@01 && v@120@01 in g1@79@01 && exists_path[Bool]($$(sm@126@01, g0@78@01), u@119@01, v@120@01))]
(assert (not
  (and
    (Set_in u@119@01 g1@79@01)
    (and
      (Set_in v@120@01 g1@79@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@130@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef77|)))
(assert (forall ((n@127@01 $Ref)) (!
  (=>
    (Set_in n@127@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@128@01 n@127@01) n@127@01) (img@129@01 n@127@01)))
  :pattern ((Set_in n@127@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@128@01 n@127@01))
  :pattern ((img@129@01 n@127@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@129@01 r) (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@128@01 r) r))
  :pattern ((inv@128@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r)))
    (=>
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef79|)))
(assert (=>
  (and
    (Set_in u@119@01 g1@79@01)
    (and
      (Set_in v@120@01 g1@79@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
  (and
    (Set_in u@119@01 g1@79@01)
    (Set_in v@120@01 g1@79@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
      :pattern ((inv@128@01 r))
      :qid |quant-u-230|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
  (and
    (Set_in u@119@01 g1@79@01)
    (and
      (Set_in v@120@01 g1@79@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@124@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@124@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef72|)))
(assert (forall ((n@121@01 $Ref)) (!
  (=>
    (Set_in n@121@01 g0@78@01)
    (and (= (inv@122@01 n@121@01) n@121@01) (img@123@01 n@121@01)))
  :pattern ((Set_in n@121@01 g0@78@01))
  :pattern ((inv@122@01 n@121@01))
  :pattern ((img@123@01 n@121@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@123@01 r) (Set_in (inv@122@01 r) g0@78@01)) (= (inv@122@01 r) r))
  :pattern ((inv@122@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r)))
    (=>
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@126@01  $FVF<next>))))
  :qid |qp.fvfDomDef75|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@122@01 r) g0@78@01) (img@123@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@126@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@126@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@130@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef76|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@130@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef77|)))
(assert (forall ((n@127@01 $Ref)) (!
  (=>
    (Set_in n@127@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@128@01 n@127@01) n@127@01) (img@129@01 n@127@01)))
  :pattern ((Set_in n@127@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@128@01 n@127@01))
  :pattern ((img@129@01 n@127@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@129@01 r) (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@128@01 r) r))
  :pattern ((inv@128@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r)))
    (=>
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@132@01  $FVF<next>))))
  :qid |qp.fvfDomDef80|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01)) (img@129@01 r))
      (and (img@96@01 r) (Set_in (inv@95@01 r) (Set_union g0@78@01 g1@79@01))))
    (=
      ($FVF.lookup_next (as sm@132@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r)))
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@92@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@132@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef79|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((Set_in u@119@01 g1@79@01) (Set_in v@120@01 g1@79@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((Set_in u@119@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((Set_in u@119@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((Set_in v@120@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((Set_in v@120@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (and
    (=>
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in u@119@01 g1@79@01)
        (=>
          (Set_in v@120@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@122@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@124@01  $FVF<next>) r) r))
              :pattern ((inv@122@01 r))
              :qid |quant-u-224|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@120@01 g1@79@01) (not (Set_in v@120@01 g1@79@01)))))
    (or (Set_in u@119@01 g1@79@01) (not (Set_in u@119@01 g1@79@01)))
    (=>
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
      (and
        (Set_in u@119@01 g1@79@01)
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@128@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@130@01  $FVF<next>) r) r))
          :pattern ((inv@128@01 r))
          :qid |quant-u-230|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@119@01 g1@79@01)
          (and
            (Set_in v@120@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))))
      (and
        (Set_in u@119@01 g1@79@01)
        (and
          (Set_in v@120@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@119@01 $Ref) (v@120@01 $Ref)) (!
  (=>
    (and
      (Set_in u@119@01 g1@79@01)
      (and
        (Set_in v@120@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01)))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :pattern ((Set_in u@119@01 g1@79@01) (Set_in v@120@01 g1@79@01))
  :pattern ((Set_in u@119@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))
  :pattern ((Set_in u@119@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :pattern ((Set_in v@120@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))
  :pattern ((Set_in v@120@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@126@01  $FVF<next>)) g0@78@01) u@119@01 v@120@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@132@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@119@01 v@120@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117|)))
(pop) ; 2
(push) ; 2
; [exec]
; inhale apply_noExit($$((g0 union g1)), (g0 union g1), g0)
(declare-const $t@133@01 $Snap)
(assert (= $t@133@01 $Snap.unit))
; [eval] apply_noExit($$((g0 union g1)), (g0 union g1), g0)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(declare-const n@134@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@134@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 4
(declare-fun inv@135@01 ($Ref) $Ref)
(declare-fun img@136@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@134@01 $Ref) (n2@134@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@134@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n1@134@01) n1@134@01))
      (and
        (Set_in n2@134@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) n2@134@01) n2@134@01))
      (= n1@134@01 n2@134@01))
    (= n1@134@01 n2@134@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@134@01 $Ref)) (!
  (=>
    (Set_in n@134@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@135@01 n@134@01) n@134@01) (img@136@01 n@134@01)))
  :pattern ((Set_in n@134@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@135@01 n@134@01))
  :pattern ((img@136@01 n@134@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@136@01 r) (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@135@01 r) r))
  :pattern ((inv@135@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) r) r))
  :pattern ((inv@135@01 r))
  :qid |quant-u-236|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@137@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01))
      (img@136@01 r)
      (= r (inv@135@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@138@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01))
      (img@136@01 r)
      (= r (inv@135@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@137@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@137@01 r))
    $Perm.No)
  
  :qid |quant-u-238|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@137@01 r) $Perm.No)
  
  :qid |quant-u-239|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01))
      (img@136@01 r)
      (= r (inv@135@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@137@01 r)) $Perm.No))
  
  :qid |quant-u-240|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (pTaken@138@01 r))
    $Perm.No)
  
  :qid |quant-u-241|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@138@01 r) $Perm.No)
  
  :qid |quant-u-242|))))
(check-sat)
; unknown
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01))
      (img@136@01 r)
      (= r (inv@135@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@137@01 r)) (pTaken@138@01 r))
      $Perm.No))
  
  :qid |quant-u-243|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@139@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@139@01  $FVF<next>)))
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r)))
    (=>
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r))
      (Set_in r ($FVF.domain_next (as sm@139@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@139@01  $FVF<next>))))
  :qid |qp.fvfDomDef84|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@139@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@139@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@139@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@139@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@139@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef83|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@139@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@134@01 $Ref)) (!
  (=>
    (Set_in n@134@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@135@01 n@134@01) n@134@01) (img@136@01 n@134@01)))
  :pattern ((Set_in n@134@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@135@01 n@134@01))
  :pattern ((img@136@01 n@134@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@136@01 r) (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@135@01 r) r))
  :pattern ((inv@135@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@139@01  $FVF<next>)))
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r)))
    (=>
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r))
      (Set_in r ($FVF.domain_next (as sm@139@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@139@01  $FVF<next>))))
  :qid |qp.fvfDomDef84|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@139@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@139@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01)) (img@136@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@139@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@139@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@139@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef83|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@135@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@90@01  $FVF<next>) r) r))
    :pattern ((inv@135@01 r))
    :qid |quant-u-236|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@139@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
; [eval] (g0 union g1)
(assert (apply_noExit<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@139@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) (Set_union g0@78@01 g1@79@01) g0@78@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale apply_TCFraming(g0, g1)
(declare-const $t@140@01 $Snap)
(assert (= $t@140@01 $Snap.unit))
; [eval] apply_TCFraming(g0, g1)
(set-option :timeout 0)
(push) ; 3
; [eval] !((null in g0))
; [eval] (null in g0)
(declare-const n@141@01 $Ref)
(push) ; 4
; [eval] (n in g0)
(assert (Set_in n@141@01 g0@78@01))
(pop) ; 4
(declare-fun inv@142@01 ($Ref) $Ref)
(declare-fun img@143@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@144@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef87|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@141@01 $Ref) (n2@141@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@141@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n1@141@01) n1@141@01))
      (and
        (Set_in n2@141@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) n2@141@01) n2@141@01))
      (= n1@141@01 n2@141@01))
    (= n1@141@01 n2@141@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@141@01 $Ref)) (!
  (=>
    (Set_in n@141@01 g0@78@01)
    (and (= (inv@142@01 n@141@01) n@141@01) (img@143@01 n@141@01)))
  :pattern ((Set_in n@141@01 g0@78@01))
  :pattern ((inv@142@01 n@141@01))
  :pattern ((img@143@01 n@141@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@143@01 r) (Set_in (inv@142@01 r) g0@78@01)) (= (inv@142@01 r) r))
  :pattern ((inv@142@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@142@01 r) g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) r) r))
  :pattern ((inv@142@01 r))
  :qid |quant-u-245|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@145@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r) (= r (inv@142@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@146@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r) (= r (inv@142@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@145@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@145@01 r))
    $Perm.No)
  
  :qid |quant-u-247|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r) (= r (inv@142@01 r)))
    (= (- $Perm.Write (pTaken@145@01 r)) $Perm.No))
  
  :qid |quant-u-248|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@147@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@147@01  $FVF<next>)))
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r)))
    (=>
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r))
      (Set_in r ($FVF.domain_next (as sm@147@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@147@01  $FVF<next>))))
  :qid |qp.fvfDomDef91|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@147@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@147@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@147@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@147@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@147@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef90|)))
; [eval] (forall n$0: Ref ::(n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@148@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 5
; [then-branch: 25 | !(n$0@148@01 in g0@78@01) | live]
; [else-branch: 25 | n$0@148@01 in g0@78@01 | live]
(push) ; 6
; [then-branch: 25 | !(n$0@148@01 in g0@78@01)]
(assert (not (Set_in n$0@148@01 g0@78@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 25 | n$0@148@01 in g0@78@01]
(assert (Set_in n$0@148@01 g0@78@01))
; [eval] n$0.next != null
(declare-const sm@149@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(declare-const pm@150@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@150@01  $FPM) r)
    (+
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resPrmSumDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resTrgDef96|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) n$0@148@01))
(push) ; 7
(assert (not (< $Perm.No ($FVF.perm_next (as pm@150@01  $FPM) n$0@148@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@150@01  $FPM) r)
    (+
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resPrmSumDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resTrgDef96|)))
(assert (=>
  (Set_in n$0@148@01 g0@78@01)
  (and
    (Set_in n$0@148@01 g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) n$0@148@01))))
(assert (or (Set_in n$0@148@01 g0@78@01) (not (Set_in n$0@148@01 g0@78@01))))
(push) ; 5
; [then-branch: 26 | n$0@148@01 in g0@78@01 && Lookup(next, sm@149@01, n$0@148@01) != Null | live]
; [else-branch: 26 | !(n$0@148@01 in g0@78@01 && Lookup(next, sm@149@01, n$0@148@01) != Null) | live]
(push) ; 6
; [then-branch: 26 | n$0@148@01 in g0@78@01 && Lookup(next, sm@149@01, n$0@148@01) != Null]
(assert (and
  (Set_in n$0@148@01 g0@78@01)
  (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef92|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) n$0@148@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$0@148@01) (Set_in (inv@83@01 n$0@148@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$0@148@01) (Set_in (inv@88@01 n$0@148@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 26 | !(n$0@148@01 in g0@78@01 && Lookup(next, sm@149@01, n$0@148@01) != Null)]
(assert (not
  (and
    (Set_in n$0@148@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (and
    (Set_in n$0@148@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null)))
  (and
    (Set_in n$0@148@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) n$0@148@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@148@01 g0@78@01)
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null))))
  (and
    (Set_in n$0@148@01 g0@78@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@150@01  $FPM) r)
    (+
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resPrmSumDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resTrgDef96|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$0@148@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@148@01 g0@78@01)
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) g0@78@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@148@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@148@01 g0@78@01)
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) g0@78@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|)))
; [eval] !((null in g1))
; [eval] (null in g1)
(declare-const n$1@151@01 $Ref)
(push) ; 4
; [eval] (n$1 in g1)
(assert (Set_in n$1@151@01 g1@79@01))
(pop) ; 4
(declare-fun inv@152@01 ($Ref) $Ref)
(declare-fun img@153@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@154@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@154@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@154@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@154@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef98|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n$11@151@01 $Ref) (n$12@151@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@151@01 g1@79@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@154@01  $FVF<next>) n$11@151@01) n$11@151@01))
      (and
        (Set_in n$12@151@01 g1@79@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@154@01  $FVF<next>) n$12@151@01) n$12@151@01))
      (= n$11@151@01 n$12@151@01))
    (= n$11@151@01 n$12@151@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@151@01 $Ref)) (!
  (=>
    (Set_in n$1@151@01 g1@79@01)
    (and (= (inv@152@01 n$1@151@01) n$1@151@01) (img@153@01 n$1@151@01)))
  :pattern ((Set_in n$1@151@01 g1@79@01))
  :pattern ((inv@152@01 n$1@151@01))
  :pattern ((img@153@01 n$1@151@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@153@01 r) (Set_in (inv@152@01 r) g1@79@01)) (= (inv@152@01 r) r))
  :pattern ((inv@152@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@152@01 r) g1@79@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@154@01  $FVF<next>) r) r))
  :pattern ((inv@152@01 r))
  :qid |quant-u-250|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@155@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r) (= r (inv@152@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (pTaken@155@01 r))
    $Perm.No)
  
  :qid |quant-u-252|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r) (= r (inv@152@01 r)))
    (= (- $Perm.Write (pTaken@155@01 r)) $Perm.No))
  
  :qid |quant-u-253|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@156@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@156@01  $FVF<next>)))
      (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r)))
    (=>
      (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r))
      (Set_in r ($FVF.domain_next (as sm@156@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@156@01  $FVF<next>))))
  :qid |qp.fvfDomDef101|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@156@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@156@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@156@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef100|)))
; [eval] (forall n$2: Ref ::(n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@157@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 5
; [then-branch: 27 | !(n$2@157@01 in g1@79@01) | live]
; [else-branch: 27 | n$2@157@01 in g1@79@01 | live]
(push) ; 6
; [then-branch: 27 | !(n$2@157@01 in g1@79@01)]
(assert (not (Set_in n$2@157@01 g1@79@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 27 | n$2@157@01 in g1@79@01]
(assert (Set_in n$2@157@01 g1@79@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef92|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) n$2@157@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$2@157@01) (Set_in (inv@83@01 n$2@157@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$2@157@01) (Set_in (inv@88@01 n$2@157@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (Set_in n$2@157@01 g1@79@01)
  (and
    (Set_in n$2@157@01 g1@79@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) n$2@157@01))))
(assert (or (Set_in n$2@157@01 g1@79@01) (not (Set_in n$2@157@01 g1@79@01))))
(push) ; 5
; [then-branch: 28 | n$2@157@01 in g1@79@01 && Lookup(next, sm@149@01, n$2@157@01) != Null | live]
; [else-branch: 28 | !(n$2@157@01 in g1@79@01 && Lookup(next, sm@149@01, n$2@157@01) != Null) | live]
(push) ; 6
; [then-branch: 28 | n$2@157@01 in g1@79@01 && Lookup(next, sm@149@01, n$2@157@01) != Null]
(assert (and
  (Set_in n$2@157@01 g1@79@01)
  (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef92|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) n$2@157@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$2@157@01) (Set_in (inv@83@01 n$2@157@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$2@157@01) (Set_in (inv@88@01 n$2@157@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 28 | !(n$2@157@01 in g1@79@01 && Lookup(next, sm@149@01, n$2@157@01) != Null)]
(assert (not
  (and
    (Set_in n$2@157@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (and
    (Set_in n$2@157@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null)))
  (and
    (Set_in n$2@157@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) n$2@157@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@157@01 g1@79@01)
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null))))
  (and
    (Set_in n$2@157@01 g1@79@01)
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$2@157@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@157@01 g1@79@01)
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) g1@79@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@157@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@157@01 g1@79@01)
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) g1@79@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|)))
; [eval] (g1 intersection g0) == Set[Ref]()
; [eval] (g1 intersection g0)
; [eval] Set[Ref]()
(push) ; 4
(assert (not (Set_equal (Set_intersection g1@79@01 g0@78@01) (as Set_empty  Set<$Ref>))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (Set_equal (Set_intersection g1@79@01 g0@78@01) (as Set_empty  Set<$Ref>)))
(assert (apply_TCFraming%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@147@01  $FVF<next>))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<next>To$Snap (as sm@156@01  $FVF<next>))
          ($Snap.combine $Snap.unit $Snap.unit)))))) g0@78@01 g1@79@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@144@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@144@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef87|)))
(assert (forall ((n@141@01 $Ref)) (!
  (=>
    (Set_in n@141@01 g0@78@01)
    (and (= (inv@142@01 n@141@01) n@141@01) (img@143@01 n@141@01)))
  :pattern ((Set_in n@141@01 g0@78@01))
  :pattern ((inv@142@01 n@141@01))
  :pattern ((img@143@01 n@141@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@143@01 r) (Set_in (inv@142@01 r) g0@78@01)) (= (inv@142@01 r) r))
  :pattern ((inv@142@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@147@01  $FVF<next>)))
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r)))
    (=>
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r))
      (Set_in r ($FVF.domain_next (as sm@147@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@147@01  $FVF<next>))))
  :qid |qp.fvfDomDef91|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@147@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@147@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@142@01 r) g0@78@01) (img@143@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@147@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@147@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@147@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@150@01  $FPM) r)
    (+
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resPrmSumDef95|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@150@01  $FPM) r))
  :qid |qp.resTrgDef96|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@154@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@154@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@154@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef98|)))
(assert (forall ((n$1@151@01 $Ref)) (!
  (=>
    (Set_in n$1@151@01 g1@79@01)
    (and (= (inv@152@01 n$1@151@01) n$1@151@01) (img@153@01 n$1@151@01)))
  :pattern ((Set_in n$1@151@01 g1@79@01))
  :pattern ((inv@152@01 n$1@151@01))
  :pattern ((img@153@01 n$1@151@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@153@01 r) (Set_in (inv@152@01 r) g1@79@01)) (= (inv@152@01 r) r))
  :pattern ((inv@152@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@156@01  $FVF<next>)))
      (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r)))
    (=>
      (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r))
      (Set_in r ($FVF.domain_next (as sm@156@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@156@01  $FVF<next>))))
  :qid |qp.fvfDomDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@152@01 r) g1@79@01) (img@153@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@156@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@156@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@156@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef100|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@142@01 r) g0@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@144@01  $FVF<next>) r) r))
    :pattern ((inv@142@01 r))
    :qid |quant-u-245|))
  (forall ((n$0@148@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@148@01 g0@78@01)
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$0@148@01) g0@78@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|))
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@152@01 r) g1@79@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@154@01  $FVF<next>) r) r))
    :pattern ((inv@152@01 r))
    :qid |quant-u-250|))
  (forall ((n$2@157@01 $Ref)) (!
    (=>
      (and
        (Set_in n$2@157@01 g1@79@01)
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$2@157@01) g1@79@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|))
  (Set_equal (Set_intersection g1@79@01 g0@78@01) (as Set_empty  Set<$Ref>))
  (apply_TCFraming%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@147@01  $FVF<next>))
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($SortWrappers.$FVF<next>To$Snap (as sm@156@01  $FVF<next>))
            ($Snap.combine $Snap.unit $Snap.unit)))))) g0@78@01 g1@79@01)))
(assert (apply_TCFraming ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@147@01  $FVF<next>))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<next>To$Snap (as sm@156@01  $FVF<next>))
          ($Snap.combine $Snap.unit $Snap.unit)))))) g0@78@01 g1@79@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] !((null in (g0 union g1)))
; [eval] (null in (g0 union g1))
; [eval] (g0 union g1)
(set-option :timeout 0)
(push) ; 3
(assert (not (not (Set_in $Ref.null (Set_union g0@78@01 g1@79@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (not (Set_in $Ref.null (Set_union g0@78@01 g1@79@01))))
(declare-const n$3@158@01 $Ref)
(push) ; 3
; [eval] (n$3 in (g0 union g1))
; [eval] (g0 union g1)
(assert (Set_in n$3@158@01 (Set_union g0@78@01 g1@79@01)))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@159@01 ($Ref) $Ref)
(declare-fun img@160@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$31@158@01 $Ref) (n$32@158@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$31@158@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$31@158@01) n$31@158@01))
      (and
        (Set_in n$32@158@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$32@158@01) n$32@158@01))
      (= n$31@158@01 n$32@158@01))
    (= n$31@158@01 n$32@158@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$3@158@01 $Ref)) (!
  (=>
    (Set_in n$3@158@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@159@01 n$3@158@01) n$3@158@01) (img@160@01 n$3@158@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$3@158@01) n$3@158@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@160@01 r) (Set_in (inv@159@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@159@01 r) r))
  :pattern ((inv@159@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@159@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
  :pattern ((inv@159@01 r))
  :qid |quant-u-255|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@161@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@159@01 r) (Set_union g0@78@01 g1@79@01))
      (img@160@01 r)
      (= r (inv@159@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@162@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@159@01 r) (Set_union g0@78@01 g1@79@01))
      (img@160@01 r)
      (= r (inv@159@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@161@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@161@01 r))
    $Perm.No)
  
  :qid |quant-u-257|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@159@01 r) (Set_union g0@78@01 g1@79@01))
      (img@160@01 r)
      (= r (inv@159@01 r)))
    (= (- $Perm.Write (pTaken@161@01 r)) $Perm.No))
  
  :qid |quant-u-258|))))
(check-sat)
; unknown
(pop) ; 3
; 0,07s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (pTaken@162@01 r))
    $Perm.No)
  
  :qid |quant-u-259|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@159@01 r) (Set_union g0@78@01 g1@79@01))
      (img@160@01 r)
      (= r (inv@159@01 r)))
    (= (- (- $Perm.Write (pTaken@161@01 r)) (pTaken@162@01 r)) $Perm.No))
  
  :qid |quant-u-260|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$4: Ref :: { (n$4.next in (g0 union g1)) } { (n$4 in (g0 union g1)), n$4.next } (n$4 in (g0 union g1)) && n$4.next != null ==> (n$4.next in (g0 union g1)))
(declare-const n$4@163@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$4 in (g0 union g1)) && n$4.next != null ==> (n$4.next in (g0 union g1))
; [eval] (n$4 in (g0 union g1)) && n$4.next != null
; [eval] (n$4 in (g0 union g1))
; [eval] (g0 union g1)
(push) ; 4
; [then-branch: 29 | !(n$4@163@01 in g0@78@01 ∪ g1@79@01) | live]
; [else-branch: 29 | n$4@163@01 in g0@78@01 ∪ g1@79@01 | live]
(push) ; 5
; [then-branch: 29 | !(n$4@163@01 in g0@78@01 ∪ g1@79@01)]
(assert (not (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 29 | n$4@163@01 in g0@78@01 ∪ g1@79@01]
(assert (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01)))
; [eval] n$4.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef92|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$4@163@01) (Set_in (inv@83@01 n$4@163@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$4@163@01) (Set_in (inv@88@01 n$4@163@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
  (and
    (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))))
(assert (or
  (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
  (not (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01)))))
(push) ; 4
; [then-branch: 30 | n$4@163@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@149@01, n$4@163@01) != Null | live]
; [else-branch: 30 | !(n$4@163@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@149@01, n$4@163@01) != Null) | live]
(push) ; 5
; [then-branch: 30 | n$4@163@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@149@01, n$4@163@01) != Null]
(assert (and
  (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
  (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null))))
; [eval] (n$4.next in (g0 union g1))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
    :qid |qp.fvfValDef92|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
      (=
        ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
    :qid |qp.fvfValDef93|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef94|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@84@01 n$4@163@01) (Set_in (inv@83@01 n$4@163@01) g0@78@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@89@01 n$4@163@01) (Set_in (inv@88@01 n$4@163@01) g1@79@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; [eval] (g0 union g1)
(pop) ; 5
(push) ; 5
; [else-branch: 30 | !(n$4@163@01 in g0@78@01 ∪ g1@79@01 && Lookup(next, sm@149@01, n$4@163@01) != Null)]
(assert (not
  (and
    (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
(assert (=>
  (and
    (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))
  (and
    (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null))))
  (and
    (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
    (not (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@149@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@149@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef94|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@163@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01)))
    (or
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (not (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))))
    (=>
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01)))
    (or
      (not
        (and
          (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
          (not
            (=
              ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01)
              $Ref.null))))
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) (Set_union g0@78@01 g1@79@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31-aux|)))
(assert (forall ((n$4@163@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01)))
    (or
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (not (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))))
    (=>
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01)))
    (or
      (not
        (and
          (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
          (not
            (=
              ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01)
              $Ref.null))))
      (and
        (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
        (not
          (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))))
  :pattern ((Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31-aux|)))
(push) ; 3
(assert (not (forall ((n$4@163@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$4@163@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01))
      (not
        (= ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in n$4@163@01 (Set_union g0@78@01 g1@79@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n$4@163@01) n$4@163@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@378@13@378@31|)))
; [eval] (forall u: Ref, v: Ref :: { (u in g0), (v in g1) } { (u in g0), exists_path($$((g0 union g1)), u, v) } { (v in g1), exists_path($$((g0 union g1)), u, v) } { exists_path($$((g0 union g1)), u, v) } (u in g0) && (v in g1) ==> !exists_path($$((g0 union g1)), u, v))
(declare-const u@164@01 $Ref)
(declare-const v@165@01 $Ref)
(push) ; 3
; [eval] (u in g0) && (v in g1) ==> !exists_path($$((g0 union g1)), u, v)
; [eval] (u in g0) && (v in g1)
; [eval] (u in g0)
(push) ; 4
; [then-branch: 31 | !(u@164@01 in g0@78@01) | live]
; [else-branch: 31 | u@164@01 in g0@78@01 | live]
(push) ; 5
; [then-branch: 31 | !(u@164@01 in g0@78@01)]
(assert (not (Set_in u@164@01 g0@78@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 31 | u@164@01 in g0@78@01]
(assert (Set_in u@164@01 g0@78@01))
; [eval] (v in g1)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in u@164@01 g0@78@01) (not (Set_in u@164@01 g0@78@01))))
(push) ; 4
; [then-branch: 32 | u@164@01 in g0@78@01 && v@165@01 in g1@79@01 | live]
; [else-branch: 32 | !(u@164@01 in g0@78@01 && v@165@01 in g1@79@01) | live]
(push) ; 5
; [then-branch: 32 | u@164@01 in g0@78@01 && v@165@01 in g1@79@01]
(assert (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
; [eval] !exists_path($$((g0 union g1)), u, v)
; [eval] exists_path($$((g0 union g1)), u, v)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 6
(declare-const n@166@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@166@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 7
(declare-fun inv@167@01 ($Ref) $Ref)
(declare-fun img@168@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@166@01 $Ref) (n2@166@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@166@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n1@166@01) n1@166@01))
      (and
        (Set_in n2@166@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n2@166@01) n2@166@01))
      (= n1@166@01 n2@166@01))
    (= n1@166@01 n2@166@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@166@01 $Ref)) (!
  (=>
    (Set_in n@166@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@167@01 n@166@01) n@166@01) (img@168@01 n@166@01)))
  :pattern ((Set_in n@166@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@167@01 n@166@01))
  :pattern ((img@168@01 n@166@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@167@01 r) r))
  :pattern ((inv@167@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
  :pattern ((inv@167@01 r))
  :qid |quant-u-262|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@169@01 ((r $Ref) (u@164@01 $Ref) (v@165@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
      (img@168@01 r)
      (= r (inv@167@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@170@01 ((r $Ref) (u@164@01 $Ref) (v@165@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
      (img@168@01 r)
      (= r (inv@167@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@169@01 r u@164@01 v@165@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@169@01 r u@164@01 v@165@01))
    $Perm.No)
  
  :qid |quant-u-264|))))
(check-sat)
; unknown
(pop) ; 7
; 0,07s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@169@01 r u@164@01 v@165@01) $Perm.No)
  
  :qid |quant-u-265|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
      (img@168@01 r)
      (= r (inv@167@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@169@01 r u@164@01 v@165@01))
      $Perm.No))
  
  :qid |quant-u-266|))))
(check-sat)
; unknown
(pop) ; 7
; 0,07s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (pTaken@170@01 r u@164@01 v@165@01))
    $Perm.No)
  
  :qid |quant-u-267|))))
(check-sat)
; unknown
(pop) ; 7
; 0,08s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@170@01 r u@164@01 v@165@01) $Perm.No)
  
  :qid |quant-u-268|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
      (img@168@01 r)
      (= r (inv@167@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@169@01 r u@164@01 v@165@01))
        (pTaken@170@01 r u@164@01 v@165@01))
      $Perm.No))
  
  :qid |quant-u-269|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@171@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r)))
    (=>
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>))))
  :qid |qp.fvfDomDef105|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef104|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((n@166@01 $Ref)) (!
  (=>
    (Set_in n@166@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@167@01 n@166@01) n@166@01) (img@168@01 n@166@01)))
  :pattern ((Set_in n@166@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@167@01 n@166@01))
  :pattern ((img@168@01 n@166@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@167@01 r) r))
  :pattern ((inv@167@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r)))
    (=>
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>))))
  :qid |qp.fvfDomDef105|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef104|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
    :pattern ((inv@167@01 r))
    :qid |quant-u-262|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 32 | !(u@164@01 in g0@78@01 && v@165@01 in g1@79@01)]
(assert (not (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((n@166@01 $Ref)) (!
  (=>
    (Set_in n@166@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@167@01 n@166@01) n@166@01) (img@168@01 n@166@01)))
  :pattern ((Set_in n@166@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@167@01 n@166@01))
  :pattern ((img@168@01 n@166@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@167@01 r) r))
  :pattern ((inv@167@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r)))
    (=>
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>))))
  :qid |qp.fvfDomDef105|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef104|)))
(assert (=>
  (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
  (and
    (Set_in u@164@01 g0@78@01)
    (Set_in v@165@01 g1@79@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
      :pattern ((inv@167@01 r))
      :qid |quant-u-262|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))))
; Joined path conditions
(assert (or
  (not (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
  (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@166@01 $Ref)) (!
  (=>
    (Set_in n@166@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@167@01 n@166@01) n@166@01) (img@168@01 n@166@01)))
  :pattern ((Set_in n@166@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@167@01 n@166@01))
  :pattern ((img@168@01 n@166@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@168@01 r) (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@167@01 r) r))
  :pattern ((inv@167@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r)))
    (=>
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@171@01  $FVF<next>))))
  :qid |qp.fvfDomDef105|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01)) (img@168@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@171@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@171@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef104|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (and
    (or (Set_in u@164@01 g0@78@01) (not (Set_in u@164@01 g0@78@01)))
    (=>
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
      (and
        (Set_in u@164@01 g0@78@01)
        (Set_in v@165@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
          :pattern ((inv@167@01 r))
          :qid |quant-u-262|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))))
  :pattern ((Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (and
    (or (Set_in u@164@01 g0@78@01) (not (Set_in u@164@01 g0@78@01)))
    (=>
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
      (and
        (Set_in u@164@01 g0@78@01)
        (Set_in v@165@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
          :pattern ((inv@167@01 r))
          :qid |quant-u-262|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))))
  :pattern ((Set_in u@164@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (and
    (or (Set_in u@164@01 g0@78@01) (not (Set_in u@164@01 g0@78@01)))
    (=>
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
      (and
        (Set_in u@164@01 g0@78@01)
        (Set_in v@165@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
          :pattern ((inv@167@01 r))
          :qid |quant-u-262|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))))
  :pattern ((Set_in v@165@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (and
    (or (Set_in u@164@01 g0@78@01) (not (Set_in u@164@01 g0@78@01)))
    (=>
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
      (and
        (Set_in u@164@01 g0@78@01)
        (Set_in v@165@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@167@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
          :pattern ((inv@167@01 r))
          :qid |quant-u-262|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91-aux|)))
(assert (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (=>
    (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
  :pattern ((Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
  :pattern ((Set_in u@164@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :pattern ((Set_in v@165@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91_precondition|)))
(push) ; 3
(assert (not (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (=>
    (and
      (=>
        (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
      (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01)))
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01)))
  :pattern ((Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
  :pattern ((Set_in u@164@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :pattern ((Set_in v@165@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(assert (forall ((u@164@01 $Ref) (v@165@01 $Ref)) (!
  (=>
    (and (Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
    (not
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01)))
  :pattern ((Set_in u@164@01 g0@78@01) (Set_in v@165@01 g1@79@01))
  :pattern ((Set_in u@164@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :pattern ((Set_in v@165@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@171@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@164@01 v@165@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@379@13@379@91|)))
; [eval] (forall u: Ref, v: Ref :: { (u in g0), (v in g0) } { (u in g0), exists_path($$(g0), u, v) } { (u in g0), exists_path($$((g0 union g1)), u, v) } { (v in g0), exists_path($$(g0), u, v) } { (v in g0), exists_path($$((g0 union g1)), u, v) } { exists_path($$(g0), u, v) } { exists_path($$((g0 union g1)), u, v) } (u in g0) && ((v in g0) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v))
(declare-const u@172@01 $Ref)
(declare-const v@173@01 $Ref)
(push) ; 3
; [eval] (u in g0) && ((v in g0) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v)
; [eval] (u in g0) && ((v in g0) && exists_path($$(g0), u, v))
; [eval] (u in g0)
(push) ; 4
; [then-branch: 33 | !(u@172@01 in g0@78@01) | live]
; [else-branch: 33 | u@172@01 in g0@78@01 | live]
(push) ; 5
; [then-branch: 33 | !(u@172@01 in g0@78@01)]
(assert (not (Set_in u@172@01 g0@78@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 33 | u@172@01 in g0@78@01]
(assert (Set_in u@172@01 g0@78@01))
; [eval] (v in g0)
(push) ; 6
; [then-branch: 34 | !(v@173@01 in g0@78@01) | live]
; [else-branch: 34 | v@173@01 in g0@78@01 | live]
(push) ; 7
; [then-branch: 34 | !(v@173@01 in g0@78@01)]
(assert (not (Set_in v@173@01 g0@78@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 34 | v@173@01 in g0@78@01]
(assert (Set_in v@173@01 g0@78@01))
; [eval] exists_path($$(g0), u, v)
; [eval] $$(g0)
(push) ; 8
(declare-const n@174@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@174@01 g0@78@01))
(pop) ; 9
(declare-fun inv@175@01 ($Ref) $Ref)
(declare-fun img@176@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@174@01 $Ref) (n2@174@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@174@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n1@174@01) n1@174@01))
      (and
        (Set_in n2@174@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) n2@174@01) n2@174@01))
      (= n1@174@01 n2@174@01))
    (= n1@174@01 n2@174@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@174@01 $Ref)) (!
  (=>
    (Set_in n@174@01 g0@78@01)
    (and (= (inv@175@01 n@174@01) n@174@01) (img@176@01 n@174@01)))
  :pattern ((Set_in n@174@01 g0@78@01))
  :pattern ((inv@175@01 n@174@01))
  :pattern ((img@176@01 n@174@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@176@01 r) (Set_in (inv@175@01 r) g0@78@01)) (= (inv@175@01 r) r))
  :pattern ((inv@175@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@175@01 r) g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
  :pattern ((inv@175@01 r))
  :qid |quant-u-271|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@177@01 ((r $Ref) (u@172@01 $Ref) (v@173@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r) (= r (inv@175@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@178@01 ((r $Ref) (u@172@01 $Ref) (v@173@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r) (= r (inv@175@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@177@01 r u@172@01 v@173@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@177@01 r u@172@01 v@173@01))
    $Perm.No)
  
  :qid |quant-u-273|))))
(check-sat)
; unknown
(pop) ; 9
; 0,17s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@177@01 r u@172@01 v@173@01) $Perm.No)
  
  :qid |quant-u-274|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r) (= r (inv@175@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@177@01 r u@172@01 v@173@01))
      $Perm.No))
  
  :qid |quant-u-275|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@179@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r)))
    (=>
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>))))
  :qid |qp.fvfDomDef109|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((n@174@01 $Ref)) (!
  (=>
    (Set_in n@174@01 g0@78@01)
    (and (= (inv@175@01 n@174@01) n@174@01) (img@176@01 n@174@01)))
  :pattern ((Set_in n@174@01 g0@78@01))
  :pattern ((inv@175@01 n@174@01))
  :pattern ((img@176@01 n@174@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@176@01 r) (Set_in (inv@175@01 r) g0@78@01)) (= (inv@175@01 r) r))
  :pattern ((inv@175@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r)))
    (=>
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>))))
  :qid |qp.fvfDomDef109|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@175@01 r) g0@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
    :pattern ((inv@175@01 r))
    :qid |quant-u-271|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((n@174@01 $Ref)) (!
  (=>
    (Set_in n@174@01 g0@78@01)
    (and (= (inv@175@01 n@174@01) n@174@01) (img@176@01 n@174@01)))
  :pattern ((Set_in n@174@01 g0@78@01))
  :pattern ((inv@175@01 n@174@01))
  :pattern ((img@176@01 n@174@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@176@01 r) (Set_in (inv@175@01 r) g0@78@01)) (= (inv@175@01 r) r))
  :pattern ((inv@175@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r)))
    (=>
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>))))
  :qid |qp.fvfDomDef109|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (=>
  (Set_in v@173@01 g0@78@01)
  (and
    (Set_in v@173@01 g0@78@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@175@01 r) g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
      :pattern ((inv@175@01 r))
      :qid |quant-u-271|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01))))
(assert (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((n@174@01 $Ref)) (!
  (=>
    (Set_in n@174@01 g0@78@01)
    (and (= (inv@175@01 n@174@01) n@174@01) (img@176@01 n@174@01)))
  :pattern ((Set_in n@174@01 g0@78@01))
  :pattern ((inv@175@01 n@174@01))
  :pattern ((img@176@01 n@174@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@176@01 r) (Set_in (inv@175@01 r) g0@78@01)) (= (inv@175@01 r) r))
  :pattern ((inv@175@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r)))
    (=>
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>))))
  :qid |qp.fvfDomDef109|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (=>
  (Set_in u@172@01 g0@78@01)
  (and
    (Set_in u@172@01 g0@78@01)
    (=>
      (Set_in v@173@01 g0@78@01)
      (and
        (Set_in v@173@01 g0@78@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@175@01 r) g0@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
          :pattern ((inv@175@01 r))
          :qid |quant-u-271|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
    (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01))))))
(assert (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 35 | u@172@01 in g0@78@01 && v@173@01 in g0@78@01 && exists_path[Bool]($$(sm@179@01, g0@78@01), u@172@01, v@173@01) | live]
; [else-branch: 35 | !(u@172@01 in g0@78@01 && v@173@01 in g0@78@01 && exists_path[Bool]($$(sm@179@01, g0@78@01), u@172@01, v@173@01)) | live]
(push) ; 5
; [then-branch: 35 | u@172@01 in g0@78@01 && v@173@01 in g0@78@01 && exists_path[Bool]($$(sm@179@01, g0@78@01), u@172@01, v@173@01)]
(assert (and
  (Set_in u@172@01 g0@78@01)
  (and
    (Set_in v@173@01 g0@78@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
; [eval] exists_path($$((g0 union g1)), u, v)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 6
(declare-const n@180@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@180@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 7
(declare-fun inv@181@01 ($Ref) $Ref)
(declare-fun img@182@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@183@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef112|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@180@01 $Ref) (n2@180@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@180@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) n1@180@01) n1@180@01))
      (and
        (Set_in n2@180@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) n2@180@01) n2@180@01))
      (= n1@180@01 n2@180@01))
    (= n1@180@01 n2@180@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@180@01 $Ref)) (!
  (=>
    (Set_in n@180@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@181@01 n@180@01) n@180@01) (img@182@01 n@180@01)))
  :pattern ((Set_in n@180@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@181@01 n@180@01))
  :pattern ((img@182@01 n@180@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@182@01 r) (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@181@01 r) r))
  :pattern ((inv@181@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
  :pattern ((inv@181@01 r))
  :qid |quant-u-277|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@184@01 ((r $Ref) (u@172@01 $Ref) (v@173@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
      (img@182@01 r)
      (= r (inv@181@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@185@01 ((r $Ref) (u@172@01 $Ref) (v@173@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
      (img@182@01 r)
      (= r (inv@181@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@184@01 r u@172@01 v@173@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@184@01 r u@172@01 v@173@01))
    $Perm.No)
  
  :qid |quant-u-279|))))
(check-sat)
; unknown
(pop) ; 7
; 0,15s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@184@01 r u@172@01 v@173@01) $Perm.No)
  
  :qid |quant-u-280|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
      (img@182@01 r)
      (= r (inv@181@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@184@01 r u@172@01 v@173@01))
      $Perm.No))
  
  :qid |quant-u-281|))))
(check-sat)
; unknown
(pop) ; 7
; 0,12s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (pTaken@185@01 r u@172@01 v@173@01))
    $Perm.No)
  
  :qid |quant-u-282|))))
(check-sat)
; unknown
(pop) ; 7
; 0,14s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@185@01 r u@172@01 v@173@01) $Perm.No)
  
  :qid |quant-u-283|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
      (img@182@01 r)
      (= r (inv@181@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@184@01 r u@172@01 v@173@01))
        (pTaken@185@01 r u@172@01 v@173@01))
      $Perm.No))
  
  :qid |quant-u-284|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@186@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r)))
    (=>
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>))))
  :qid |qp.fvfDomDef116|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef115|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef112|)))
(assert (forall ((n@180@01 $Ref)) (!
  (=>
    (Set_in n@180@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@181@01 n@180@01) n@180@01) (img@182@01 n@180@01)))
  :pattern ((Set_in n@180@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@181@01 n@180@01))
  :pattern ((img@182@01 n@180@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@182@01 r) (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@181@01 r) r))
  :pattern ((inv@181@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r)))
    (=>
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>))))
  :qid |qp.fvfDomDef116|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef115|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
    :pattern ((inv@181@01 r))
    :qid |quant-u-277|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 35 | !(u@172@01 in g0@78@01 && v@173@01 in g0@78@01 && exists_path[Bool]($$(sm@179@01, g0@78@01), u@172@01, v@173@01))]
(assert (not
  (and
    (Set_in u@172@01 g0@78@01)
    (and
      (Set_in v@173@01 g0@78@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef112|)))
(assert (forall ((n@180@01 $Ref)) (!
  (=>
    (Set_in n@180@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@181@01 n@180@01) n@180@01) (img@182@01 n@180@01)))
  :pattern ((Set_in n@180@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@181@01 n@180@01))
  :pattern ((img@182@01 n@180@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@182@01 r) (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@181@01 r) r))
  :pattern ((inv@181@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r)))
    (=>
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>))))
  :qid |qp.fvfDomDef116|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef115|)))
(assert (=>
  (and
    (Set_in u@172@01 g0@78@01)
    (and
      (Set_in v@173@01 g0@78@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
  (and
    (Set_in u@172@01 g0@78@01)
    (Set_in v@173@01 g0@78@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
      :pattern ((inv@181@01 r))
      :qid |quant-u-277|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
  (and
    (Set_in u@172@01 g0@78@01)
    (and
      (Set_in v@173@01 g0@78@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@174@01 $Ref)) (!
  (=>
    (Set_in n@174@01 g0@78@01)
    (and (= (inv@175@01 n@174@01) n@174@01) (img@176@01 n@174@01)))
  :pattern ((Set_in n@174@01 g0@78@01))
  :pattern ((inv@175@01 n@174@01))
  :pattern ((img@176@01 n@174@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@176@01 r) (Set_in (inv@175@01 r) g0@78@01)) (= (inv@175@01 r) r))
  :pattern ((inv@175@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r)))
    (=>
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@179@01  $FVF<next>))))
  :qid |qp.fvfDomDef109|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@175@01 r) g0@78@01) (img@176@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@179@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@179@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef108|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@183@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@183@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef112|)))
(assert (forall ((n@180@01 $Ref)) (!
  (=>
    (Set_in n@180@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@181@01 n@180@01) n@180@01) (img@182@01 n@180@01)))
  :pattern ((Set_in n@180@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@181@01 n@180@01))
  :pattern ((img@182@01 n@180@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@182@01 r) (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@181@01 r) r))
  :pattern ((inv@181@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r)))
    (=>
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@186@01  $FVF<next>))))
  :qid |qp.fvfDomDef116|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01)) (img@182@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@186@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@186@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef115|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((Set_in u@172@01 g0@78@01) (Set_in v@173@01 g0@78@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in u@172@01 g0@78@01)
        (=>
          (Set_in v@173@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@175@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@149@01  $FVF<next>) r) r))
              :pattern ((inv@175@01 r))
              :qid |quant-u-271|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@173@01 g0@78@01) (not (Set_in v@173@01 g0@78@01)))))
    (or (Set_in u@172@01 g0@78@01) (not (Set_in u@172@01 g0@78@01)))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      (and
        (Set_in u@172@01 g0@78@01)
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@181@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@183@01  $FVF<next>) r) r))
          :pattern ((inv@181@01 r))
          :qid |quant-u-277|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@172@01 g0@78@01)
          (and
            (Set_in v@173@01 g0@78@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117-aux|)))
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (and
    (=>
      (and (Set_in u@172@01 g0@78@01) (Set_in v@173@01 g0@78@01))
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01))
    (=>
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
  :pattern ((Set_in u@172@01 g0@78@01) (Set_in v@173@01 g0@78@01))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117_precondition|)))
(push) ; 3
(assert (not (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (=>
    (and
      (and
        (=>
          (and (Set_in u@172@01 g0@78@01) (Set_in v@173@01 g0@78@01))
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01))
        (=>
          (and
            (Set_in u@172@01 g0@78@01)
            (and
              (Set_in v@173@01 g0@78@01)
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
      (and
        (Set_in u@172@01 g0@78@01)
        (and
          (Set_in v@173@01 g0@78@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((Set_in u@172@01 g0@78@01) (Set_in v@173@01 g0@78@01))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117|))))
(check-sat)
; unsat
(pop) ; 3
; 0,05s
; (get-info :all-statistics)
(assert (forall ((u@172@01 $Ref) (v@173@01 $Ref)) (!
  (=>
    (and
      (Set_in u@172@01 g0@78@01)
      (and
        (Set_in v@173@01 g0@78@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01)))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((Set_in u@172@01 g0@78@01) (Set_in v@173@01 g0@78@01))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((Set_in u@172@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((Set_in v@173@01 g0@78@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@179@01  $FVF<next>)) g0@78@01) u@172@01 v@173@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@186@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@172@01 v@173@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@380@13@380@117|)))
; [eval] (forall u: Ref, v: Ref :: { (u in g1), (v in g1) } { (u in g1), exists_path($$(g0), u, v) } { (u in g1), exists_path($$((g0 union g1)), u, v) } { (v in g1), exists_path($$(g0), u, v) } { (v in g1), exists_path($$((g0 union g1)), u, v) } { exists_path($$(g0), u, v) } { exists_path($$((g0 union g1)), u, v) } (u in g1) && ((v in g1) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v))
(declare-const u@187@01 $Ref)
(declare-const v@188@01 $Ref)
(push) ; 3
; [eval] (u in g1) && ((v in g1) && exists_path($$(g0), u, v)) ==> exists_path($$((g0 union g1)), u, v)
; [eval] (u in g1) && ((v in g1) && exists_path($$(g0), u, v))
; [eval] (u in g1)
(push) ; 4
; [then-branch: 36 | !(u@187@01 in g1@79@01) | live]
; [else-branch: 36 | u@187@01 in g1@79@01 | live]
(push) ; 5
; [then-branch: 36 | !(u@187@01 in g1@79@01)]
(assert (not (Set_in u@187@01 g1@79@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 36 | u@187@01 in g1@79@01]
(assert (Set_in u@187@01 g1@79@01))
; [eval] (v in g1)
(push) ; 6
; [then-branch: 37 | !(v@188@01 in g1@79@01) | live]
; [else-branch: 37 | v@188@01 in g1@79@01 | live]
(push) ; 7
; [then-branch: 37 | !(v@188@01 in g1@79@01)]
(assert (not (Set_in v@188@01 g1@79@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 37 | v@188@01 in g1@79@01]
(assert (Set_in v@188@01 g1@79@01))
; [eval] exists_path($$(g0), u, v)
; [eval] $$(g0)
(push) ; 8
(declare-const n@189@01 $Ref)
(push) ; 9
; [eval] (n in refs)
(assert (Set_in n@189@01 g0@78@01))
(pop) ; 9
(declare-fun inv@190@01 ($Ref) $Ref)
(declare-fun img@191@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@192@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((n1@189@01 $Ref) (n2@189@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@189@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) n1@189@01) n1@189@01))
      (and
        (Set_in n2@189@01 g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) n2@189@01) n2@189@01))
      (= n1@189@01 n2@189@01))
    (= n1@189@01 n2@189@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@189@01 $Ref)) (!
  (=>
    (Set_in n@189@01 g0@78@01)
    (and (= (inv@190@01 n@189@01) n@189@01) (img@191@01 n@189@01)))
  :pattern ((Set_in n@189@01 g0@78@01))
  :pattern ((inv@190@01 n@189@01))
  :pattern ((img@191@01 n@189@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@191@01 r) (Set_in (inv@190@01 r) g0@78@01)) (= (inv@190@01 r) r))
  :pattern ((inv@190@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@190@01 r) g0@78@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
  :pattern ((inv@190@01 r))
  :qid |quant-u-286|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@193@01 ((r $Ref) (u@187@01 $Ref) (v@188@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r) (= r (inv@190@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@194@01 ((r $Ref) (u@187@01 $Ref) (v@188@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r) (= r (inv@190@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@193@01 r u@187@01 v@188@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@193@01 r u@187@01 v@188@01))
    $Perm.No)
  
  :qid |quant-u-288|))))
(check-sat)
; unknown
(pop) ; 9
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@193@01 r u@187@01 v@188@01) $Perm.No)
  
  :qid |quant-u-289|))))
(check-sat)
; unknown
(pop) ; 9
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r) (= r (inv@190@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@193@01 r u@187@01 v@188@01))
      $Perm.No))
  
  :qid |quant-u-290|))))
(check-sat)
; unsat
(pop) ; 9
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@195@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r)))
    (=>
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01))
(pop) ; 8
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert (forall ((n@189@01 $Ref)) (!
  (=>
    (Set_in n@189@01 g0@78@01)
    (and (= (inv@190@01 n@189@01) n@189@01) (img@191@01 n@189@01)))
  :pattern ((Set_in n@189@01 g0@78@01))
  :pattern ((inv@190@01 n@189@01))
  :pattern ((img@191@01 n@189@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@191@01 r) (Set_in (inv@190@01 r) g0@78@01)) (= (inv@190@01 r) r))
  :pattern ((inv@190@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r)))
    (=>
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@190@01 r) g0@78@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
    :pattern ((inv@190@01 r))
    :qid |quant-u-286|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert (forall ((n@189@01 $Ref)) (!
  (=>
    (Set_in n@189@01 g0@78@01)
    (and (= (inv@190@01 n@189@01) n@189@01) (img@191@01 n@189@01)))
  :pattern ((Set_in n@189@01 g0@78@01))
  :pattern ((inv@190@01 n@189@01))
  :pattern ((img@191@01 n@189@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@191@01 r) (Set_in (inv@190@01 r) g0@78@01)) (= (inv@190@01 r) r))
  :pattern ((inv@190@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r)))
    (=>
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert (=>
  (Set_in v@188@01 g1@79@01)
  (and
    (Set_in v@188@01 g1@79@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@190@01 r) g0@78@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
      :pattern ((inv@190@01 r))
      :qid |quant-u-286|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01))))
(assert (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert (forall ((n@189@01 $Ref)) (!
  (=>
    (Set_in n@189@01 g0@78@01)
    (and (= (inv@190@01 n@189@01) n@189@01) (img@191@01 n@189@01)))
  :pattern ((Set_in n@189@01 g0@78@01))
  :pattern ((inv@190@01 n@189@01))
  :pattern ((img@191@01 n@189@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@191@01 r) (Set_in (inv@190@01 r) g0@78@01)) (= (inv@190@01 r) r))
  :pattern ((inv@190@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r)))
    (=>
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert (=>
  (Set_in u@187@01 g1@79@01)
  (and
    (Set_in u@187@01 g1@79@01)
    (=>
      (Set_in v@188@01 g1@79@01)
      (and
        (Set_in v@188@01 g1@79@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@190@01 r) g0@78@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
          :pattern ((inv@190@01 r))
          :qid |quant-u-286|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
    (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01))))))
(assert (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 38 | u@187@01 in g1@79@01 && v@188@01 in g1@79@01 && exists_path[Bool]($$(sm@195@01, g0@78@01), u@187@01, v@188@01) | live]
; [else-branch: 38 | !(u@187@01 in g1@79@01 && v@188@01 in g1@79@01 && exists_path[Bool]($$(sm@195@01, g0@78@01), u@187@01, v@188@01)) | live]
(push) ; 5
; [then-branch: 38 | u@187@01 in g1@79@01 && v@188@01 in g1@79@01 && exists_path[Bool]($$(sm@195@01, g0@78@01), u@187@01, v@188@01)]
(assert (and
  (Set_in u@187@01 g1@79@01)
  (and
    (Set_in v@188@01 g1@79@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
; [eval] exists_path($$((g0 union g1)), u, v)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 6
(declare-const n@196@01 $Ref)
(push) ; 7
; [eval] (n in refs)
(assert (Set_in n@196@01 (Set_union g0@78@01 g1@79@01)))
(pop) ; 7
(declare-fun inv@197@01 ($Ref) $Ref)
(declare-fun img@198@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@199@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef126|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((n1@196@01 $Ref) (n2@196@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@196@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) n1@196@01) n1@196@01))
      (and
        (Set_in n2@196@01 (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) n2@196@01) n2@196@01))
      (= n1@196@01 n2@196@01))
    (= n1@196@01 n2@196@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@196@01 $Ref)) (!
  (=>
    (Set_in n@196@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@197@01 n@196@01) n@196@01) (img@198@01 n@196@01)))
  :pattern ((Set_in n@196@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@197@01 n@196@01))
  :pattern ((img@198@01 n@196@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@198@01 r) (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@197@01 r) r))
  :pattern ((inv@197@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
  :pattern ((inv@197@01 r))
  :qid |quant-u-292|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@200@01 ((r $Ref) (u@187@01 $Ref) (v@188@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
      (img@198@01 r)
      (= r (inv@197@01 r)))
    ($Perm.min
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@201@01 ((r $Ref) (u@187@01 $Ref) (v@188@01 $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
      (img@198@01 r)
      (= r (inv@197@01 r)))
    ($Perm.min
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@200@01 r u@187@01 v@188@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
        $Perm.Write
        $Perm.No)
      (pTaken@200@01 r u@187@01 v@188@01))
    $Perm.No)
  
  :qid |quant-u-294|))))
(check-sat)
; unknown
(pop) ; 7
; 0,31s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@200@01 r u@187@01 v@188@01) $Perm.No)
  
  :qid |quant-u-295|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
      (img@198@01 r)
      (= r (inv@197@01 r)))
    (=
      (- (/ (to_real 1) (to_real 2)) (pTaken@200@01 r u@187@01 v@188@01))
      $Perm.No))
  
  :qid |quant-u-296|))))
(check-sat)
; unknown
(pop) ; 7
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
        $Perm.Write
        $Perm.No)
      (pTaken@201@01 r u@187@01 v@188@01))
    $Perm.No)
  
  :qid |quant-u-297|))))
(check-sat)
; unknown
(pop) ; 7
; 0,32s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@201@01 r u@187@01 v@188@01) $Perm.No)
  
  :qid |quant-u-298|))))
(check-sat)
; unknown
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
      (img@198@01 r)
      (= r (inv@197@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@200@01 r u@187@01 v@188@01))
        (pTaken@201@01 r u@187@01 v@188@01))
      $Perm.No))
  
  :qid |quant-u-299|))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@202@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r)))
    (=>
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>))))
  :qid |qp.fvfDomDef130|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef129|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))
(pop) ; 6
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef126|)))
(assert (forall ((n@196@01 $Ref)) (!
  (=>
    (Set_in n@196@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@197@01 n@196@01) n@196@01) (img@198@01 n@196@01)))
  :pattern ((Set_in n@196@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@197@01 n@196@01))
  :pattern ((img@198@01 n@196@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@198@01 r) (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@197@01 r) r))
  :pattern ((inv@197@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r)))
    (=>
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>))))
  :qid |qp.fvfDomDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef129|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
    :pattern ((inv@197@01 r))
    :qid |quant-u-292|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 38 | !(u@187@01 in g1@79@01 && v@188@01 in g1@79@01 && exists_path[Bool]($$(sm@195@01, g0@78@01), u@187@01, v@188@01))]
(assert (not
  (and
    (Set_in u@187@01 g1@79@01)
    (and
      (Set_in v@188@01 g1@79@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef126|)))
(assert (forall ((n@196@01 $Ref)) (!
  (=>
    (Set_in n@196@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@197@01 n@196@01) n@196@01) (img@198@01 n@196@01)))
  :pattern ((Set_in n@196@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@197@01 n@196@01))
  :pattern ((img@198@01 n@196@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@198@01 r) (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@197@01 r) r))
  :pattern ((inv@197@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r)))
    (=>
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>))))
  :qid |qp.fvfDomDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef129|)))
(assert (=>
  (and
    (Set_in u@187@01 g1@79@01)
    (and
      (Set_in v@188@01 g1@79@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
  (and
    (Set_in u@187@01 g1@79@01)
    (Set_in v@188@01 g1@79@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
      :pattern ((inv@197@01 r))
      :qid |quant-u-292|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
  (and
    (Set_in u@187@01 g1@79@01)
    (and
      (Set_in v@188@01 g1@79@01)
      (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@192@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@192@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef119|)))
(assert (forall ((n@189@01 $Ref)) (!
  (=>
    (Set_in n@189@01 g0@78@01)
    (and (= (inv@190@01 n@189@01) n@189@01) (img@191@01 n@189@01)))
  :pattern ((Set_in n@189@01 g0@78@01))
  :pattern ((inv@190@01 n@189@01))
  :pattern ((img@191@01 n@189@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=> (and (img@191@01 r) (Set_in (inv@190@01 r) g0@78@01)) (= (inv@190@01 r) r))
  :pattern ((inv@190@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r)))
    (=>
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@195@01  $FVF<next>))))
  :qid |qp.fvfDomDef123|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@190@01 r) g0@78@01) (img@191@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@195@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@195@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef122|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef124|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01))
    (=
      ($FVF.lookup_next (as sm@199@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@199@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef126|)))
(assert (forall ((n@196@01 $Ref)) (!
  (=>
    (Set_in n@196@01 (Set_union g0@78@01 g1@79@01))
    (and (= (inv@197@01 n@196@01) n@196@01) (img@198@01 n@196@01)))
  :pattern ((Set_in n@196@01 (Set_union g0@78@01 g1@79@01)))
  :pattern ((inv@197@01 n@196@01))
  :pattern ((img@198@01 n@196@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@198@01 r) (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)))
    (= (inv@197@01 r) r))
  :pattern ((inv@197@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r)))
    (=>
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@202@01  $FVF<next>))))
  :qid |qp.fvfDomDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@84@01 r) (Set_in (inv@83@01 r) g0@78@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01)) (img@198@01 r))
      (and (img@89@01 r) (Set_in (inv@88@01 r) g1@79@01)))
    (=
      ($FVF.lookup_next (as sm@202@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@80@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@80@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@202@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef129|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((Set_in u@187@01 g1@79@01) (Set_in v@188@01 g1@79@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in u@187@01 g1@79@01)
        (=>
          (Set_in v@188@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (forall ((r $Ref)) (!
              (=>
                (Set_in (inv@190@01 r) g0@78@01)
                ($FVF.loc_next ($FVF.lookup_next (as sm@192@01  $FVF<next>) r) r))
              :pattern ((inv@190@01 r))
              :qid |quant-u-286|))
            ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01)))
        (or (Set_in v@188@01 g1@79@01) (not (Set_in v@188@01 g1@79@01)))))
    (or (Set_in u@187@01 g1@79@01) (not (Set_in u@187@01 g1@79@01)))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      (and
        (Set_in u@187@01 g1@79@01)
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@197@01 r) (Set_union g0@78@01 g1@79@01))
            ($FVF.loc_next ($FVF.lookup_next (as sm@199@01  $FVF<next>) r) r))
          :pattern ((inv@197@01 r))
          :qid |quant-u-292|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
    (or
      (not
        (and
          (Set_in u@187@01 g1@79@01)
          (and
            (Set_in v@188@01 g1@79@01)
            (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117-aux|)))
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (and
    (=>
      (and (Set_in u@187@01 g1@79@01) (Set_in v@188@01 g1@79@01))
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01))
    (=>
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
      ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
  :pattern ((Set_in u@187@01 g1@79@01) (Set_in v@188@01 g1@79@01))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117_precondition|)))
(push) ; 3
(assert (not (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (=>
    (and
      (and
        (=>
          (and (Set_in u@187@01 g1@79@01) (Set_in v@188@01 g1@79@01))
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01))
        (=>
          (and
            (Set_in u@187@01 g1@79@01)
            (and
              (Set_in v@188@01 g1@79@01)
              (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
          ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01))))
      (and
        (Set_in u@187@01 g1@79@01)
        (and
          (Set_in v@188@01 g1@79@01)
          (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((Set_in u@187@01 g1@79@01) (Set_in v@188@01 g1@79@01))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((u@187@01 $Ref) (v@188@01 $Ref)) (!
  (=>
    (and
      (Set_in u@187@01 g1@79@01)
      (and
        (Set_in v@188@01 g1@79@01)
        (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01)))
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((Set_in u@187@01 g1@79@01) (Set_in v@188@01 g1@79@01))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((Set_in u@187@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((Set_in v@188@01 g1@79@01) (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@195@01  $FVF<next>)) g0@78@01) u@187@01 v@188@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@202@01  $FVF<next>)) (Set_union g0@78@01 g1@79@01)) u@187@01 v@188@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@381@13@381@117|)))
(pop) ; 2
(pop) ; 1
; ---------- test_framing_sets ----------
(declare-const g0@203@01 Set<$Ref>)
(declare-const g1@204@01 Set<$Ref>)
(declare-const x0@205@01 $Ref)
(declare-const y0@206@01 $Ref)
(declare-const x1@207@01 $Ref)
(declare-const y1@208@01 $Ref)
(declare-const x@209@01 $Ref)
(declare-const g0@210@01 Set<$Ref>)
(declare-const g1@211@01 Set<$Ref>)
(declare-const x0@212@01 $Ref)
(declare-const y0@213@01 $Ref)
(declare-const x1@214@01 $Ref)
(declare-const y1@215@01 $Ref)
(declare-const x@216@01 $Ref)
(push) ; 1
(declare-const $t@217@01 $Snap)
(assert (= $t@217@01 ($Snap.combine ($Snap.first $t@217@01) ($Snap.second $t@217@01))))
(assert (= ($Snap.first $t@217@01) $Snap.unit))
; [eval] !((null in g0))
; [eval] (null in g0)
(assert (not (Set_in $Ref.null g0@210@01)))
(assert (=
  ($Snap.second $t@217@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@217@01))
    ($Snap.second ($Snap.second $t@217@01)))))
(declare-const n@218@01 $Ref)
(push) ; 2
; [eval] (n in g0)
(assert (Set_in n@218@01 g0@210@01))
(declare-const sm@219@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@220@01 ($Ref) $Ref)
(declare-fun img@221@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@218@01 $Ref) (n2@218@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@218@01 g0@210@01)
      (Set_in n2@218@01 g0@210@01)
      (= n1@218@01 n2@218@01))
    (= n1@218@01 n2@218@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@218@01 $Ref)) (!
  (=>
    (Set_in n@218@01 g0@210@01)
    (and (= (inv@220@01 n@218@01) n@218@01) (img@221@01 n@218@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) n@218@01) n@218@01))
  :qid |quant-u-301|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (= (inv@220@01 r) r))
  :pattern ((inv@220@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@218@01 $Ref)) (!
  (=> (Set_in n@218@01 g0@210@01) (not (= n@218@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) n@218@01) n@218@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@222@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@222@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef133|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@220@01 r) g0@210@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) r) r))
  :pattern ((inv@220@01 r))
  :qid |quant-u-302|)))
(assert (=
  ($Snap.second ($Snap.second $t@217@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@217@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@217@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g0) } { (n$0 in g0), n$0.next } (n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@223@01 $Ref)
(push) ; 2
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 3
; [then-branch: 39 | !(n$0@223@01 in g0@210@01) | live]
; [else-branch: 39 | n$0@223@01 in g0@210@01 | live]
(push) ; 4
; [then-branch: 39 | !(n$0@223@01 in g0@210@01)]
(assert (not (Set_in n$0@223@01 g0@210@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 39 | n$0@223@01 in g0@210@01]
(assert (Set_in n$0@223@01 g0@210@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@222@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef132|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef133|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01))
(push) ; 5
(assert (not (and (img@221@01 n$0@223@01) (Set_in (inv@220@01 n$0@223@01) g0@210@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@222@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef133|)))
(assert (=>
  (Set_in n$0@223@01 g0@210@01)
  (and
    (Set_in n$0@223@01 g0@210@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01))))
(assert (or (Set_in n$0@223@01 g0@210@01) (not (Set_in n$0@223@01 g0@210@01))))
(push) ; 3
; [then-branch: 40 | n$0@223@01 in g0@210@01 && Lookup(next, sm@222@01, n$0@223@01) != Null | live]
; [else-branch: 40 | !(n$0@223@01 in g0@210@01 && Lookup(next, sm@222@01, n$0@223@01) != Null) | live]
(push) ; 4
; [then-branch: 40 | n$0@223@01 in g0@210@01 && Lookup(next, sm@222@01, n$0@223@01) != Null]
(assert (and
  (Set_in n$0@223@01 g0@210@01)
  (not (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@222@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef132|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef133|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01))
(push) ; 5
(assert (not (and (img@221@01 n$0@223@01) (Set_in (inv@220@01 n$0@223@01) g0@210@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 40 | !(n$0@223@01 in g0@210@01 && Lookup(next, sm@222@01, n$0@223@01) != Null)]
(assert (not
  (and
    (Set_in n$0@223@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@222@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef133|)))
(assert (=>
  (and
    (Set_in n$0@223@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))
  (and
    (Set_in n$0@223@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@223@01 g0@210@01)
      (not
        (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null))))
  (and
    (Set_in n$0@223@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@222@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@222@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef133|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@223@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@223@01 g0@210@01)
      (and
        (Set_in n$0@223@01 g0@210@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01)))
    (or (Set_in n$0@223@01 g0@210@01) (not (Set_in n$0@223@01 g0@210@01)))
    (=>
      (and
        (Set_in n$0@223@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))
      (and
        (Set_in n$0@223@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01)))
    (or
      (not
        (and
          (Set_in n$0@223@01 g0@210@01)
          (not
            (=
              ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01)
              $Ref.null))))
      (and
        (Set_in n$0@223@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) g0@210@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@395@14@395@23-aux|)))
(assert (forall ((n$0@223@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@223@01 g0@210@01)
      (and
        (Set_in n$0@223@01 g0@210@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01)))
    (or (Set_in n$0@223@01 g0@210@01) (not (Set_in n$0@223@01 g0@210@01)))
    (=>
      (and
        (Set_in n$0@223@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))
      (and
        (Set_in n$0@223@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01)))
    (or
      (not
        (and
          (Set_in n$0@223@01 g0@210@01)
          (not
            (=
              ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01)
              $Ref.null))))
      (and
        (Set_in n$0@223@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))))
  :pattern ((Set_in n$0@223@01 g0@210@01) ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@395@14@395@23-aux|)))
(assert (forall ((n$0@223@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@223@01 g0@210@01)
      (not
        (= ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) g0@210@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) g0@210@01))
  :pattern ((Set_in n$0@223@01 g0@210@01) ($FVF.loc_next ($FVF.lookup_next (as sm@222@01  $FVF<next>) n$0@223@01) n$0@223@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@395@14@395@23|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@217@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@217@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@217@01))))
  $Snap.unit))
; [eval] !((null in g1))
; [eval] (null in g1)
(assert (not (Set_in $Ref.null g1@211@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))
(declare-const n$1@224@01 $Ref)
(push) ; 2
; [eval] (n$1 in g1)
(assert (Set_in n$1@224@01 g1@211@01))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@225@01 ($Ref) $Ref)
(declare-fun img@226@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n$11@224@01 $Ref) (n$12@224@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@224@01 g1@211@01)
      (Set_in n$12@224@01 g1@211@01)
      (= n$11@224@01 n$12@224@01))
    (= n$11@224@01 n$12@224@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@224@01 $Ref)) (!
  (=>
    (Set_in n$1@224@01 g1@211@01)
    (and (= (inv@225@01 n$1@224@01) n$1@224@01) (img@226@01 n$1@224@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) n$1@224@01) n$1@224@01))
  :qid |quant-u-304|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (= (inv@225@01 r) r))
  :pattern ((inv@225@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@224@01 $Ref)) (!
  (=> (Set_in n$1@224@01 g1@211@01) (not (= n$1@224@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) n$1@224@01) n$1@224@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 2
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$1@224@01 n@218@01)
    (=
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))))
  
  :qid |quant-u-305|))))
(check-sat)
; unknown
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
(declare-const sm@227@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@225@01 r) g1@211@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) r) r))
  :pattern ((inv@225@01 r))
  :qid |quant-u-306|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g1) } { (n$2 in g1), n$2.next } (n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@228@01 $Ref)
(set-option :timeout 0)
(push) ; 2
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 3
; [then-branch: 41 | !(n$2@228@01 in g1@211@01) | live]
; [else-branch: 41 | n$2@228@01 in g1@211@01 | live]
(push) ; 4
; [then-branch: 41 | !(n$2@228@01 in g1@211@01)]
(assert (not (Set_in n$2@228@01 g1@211@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 41 | n$2@228@01 in g1@211@01]
(assert (Set_in n$2@228@01 g1@211@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef134|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef135|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef136|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$2@228@01) (Set_in (inv@220@01 n$2@228@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$2@228@01) (Set_in (inv@225@01 n$2@228@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (=>
  (Set_in n$2@228@01 g1@211@01)
  (and
    (Set_in n$2@228@01 g1@211@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01))))
(assert (or (Set_in n$2@228@01 g1@211@01) (not (Set_in n$2@228@01 g1@211@01))))
(push) ; 3
; [then-branch: 42 | n$2@228@01 in g1@211@01 && Lookup(next, sm@227@01, n$2@228@01) != Null | live]
; [else-branch: 42 | !(n$2@228@01 in g1@211@01 && Lookup(next, sm@227@01, n$2@228@01) != Null) | live]
(push) ; 4
; [then-branch: 42 | n$2@228@01 in g1@211@01 && Lookup(next, sm@227@01, n$2@228@01) != Null]
(assert (and
  (Set_in n$2@228@01 g1@211@01)
  (not (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef134|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef135|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef136|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$2@228@01) (Set_in (inv@220@01 n$2@228@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$2@228@01) (Set_in (inv@225@01 n$2@228@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 42 | !(n$2@228@01 in g1@211@01 && Lookup(next, sm@227@01, n$2@228@01) != Null)]
(assert (not
  (and
    (Set_in n$2@228@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
(assert (=>
  (and
    (Set_in n$2@228@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))
  (and
    (Set_in n$2@228@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@228@01 g1@211@01)
      (not
        (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null))))
  (and
    (Set_in n$2@228@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@227@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@227@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef136|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@228@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@228@01 g1@211@01)
      (and
        (Set_in n$2@228@01 g1@211@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01)))
    (or (Set_in n$2@228@01 g1@211@01) (not (Set_in n$2@228@01 g1@211@01)))
    (=>
      (and
        (Set_in n$2@228@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))
      (and
        (Set_in n$2@228@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01)))
    (or
      (not
        (and
          (Set_in n$2@228@01 g1@211@01)
          (not
            (=
              ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01)
              $Ref.null))))
      (and
        (Set_in n$2@228@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) g1@211@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@396@14@396@23-aux|)))
(assert (forall ((n$2@228@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@228@01 g1@211@01)
      (and
        (Set_in n$2@228@01 g1@211@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01)))
    (or (Set_in n$2@228@01 g1@211@01) (not (Set_in n$2@228@01 g1@211@01)))
    (=>
      (and
        (Set_in n$2@228@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))
      (and
        (Set_in n$2@228@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01)))
    (or
      (not
        (and
          (Set_in n$2@228@01 g1@211@01)
          (not
            (=
              ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01)
              $Ref.null))))
      (and
        (Set_in n$2@228@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))))
  :pattern ((Set_in n$2@228@01 g1@211@01) ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@396@14@396@23-aux|)))
(assert (forall ((n$2@228@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@228@01 g1@211@01)
      (not
        (= ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) g1@211@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) g1@211@01))
  :pattern ((Set_in n$2@228@01 g1@211@01) ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n$2@228@01) n$2@228@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@396@14@396@23|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))
  $Snap.unit))
; [eval] (x0 in g0)
(assert (Set_in x0@212@01 g0@210@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))
  $Snap.unit))
; [eval] (y0 in g0)
(assert (Set_in y0@213@01 g0@210@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))
  $Snap.unit))
; [eval] (x1 in g1)
(assert (Set_in x1@214@01 g1@211@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))
  $Snap.unit))
; [eval] (y1 in g1)
(assert (Set_in y1@215@01 g1@211@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))
  $Snap.unit))
; [eval] (forall r: Ref :: { (r in g0), (r in g1) } (r in g0) ==> !((r in g1)))
(declare-const r@229@01 $Ref)
(push) ; 2
; [eval] (r in g0) ==> !((r in g1))
; [eval] (r in g0)
(push) ; 3
; [then-branch: 43 | r@229@01 in g0@210@01 | live]
; [else-branch: 43 | !(r@229@01 in g0@210@01) | live]
(push) ; 4
; [then-branch: 43 | r@229@01 in g0@210@01]
(assert (Set_in r@229@01 g0@210@01))
; [eval] !((r in g1))
; [eval] (r in g1)
(pop) ; 4
(push) ; 4
; [else-branch: 43 | !(r@229@01 in g0@210@01)]
(assert (not (Set_in r@229@01 g0@210@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r@229@01 g0@210@01)) (Set_in r@229@01 g0@210@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r@229@01 $Ref)) (!
  (or (not (Set_in r@229@01 g0@210@01)) (Set_in r@229@01 g0@210@01))
  :pattern ((Set_in r@229@01 g0@210@01) (Set_in r@229@01 g1@211@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@399@14@399@34-aux|)))
(assert (forall ((r@229@01 $Ref)) (!
  (=> (Set_in r@229@01 g0@210@01) (not (Set_in r@229@01 g1@211@01)))
  :pattern ((Set_in r@229@01 g0@210@01) (Set_in r@229@01 g1@211@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@399@14@399@34|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))))
  $Snap.unit))
; [eval] (forall r$0: Ref :: { (r$0 in g0), (r$0 in g1) } (r$0 in g1) ==> !((r$0 in g0)))
(declare-const r$0@230@01 $Ref)
(push) ; 2
; [eval] (r$0 in g1) ==> !((r$0 in g0))
; [eval] (r$0 in g1)
(push) ; 3
; [then-branch: 44 | r$0@230@01 in g1@211@01 | live]
; [else-branch: 44 | !(r$0@230@01 in g1@211@01) | live]
(push) ; 4
; [then-branch: 44 | r$0@230@01 in g1@211@01]
(assert (Set_in r$0@230@01 g1@211@01))
; [eval] !((r$0 in g0))
; [eval] (r$0 in g0)
(pop) ; 4
(push) ; 4
; [else-branch: 44 | !(r$0@230@01 in g1@211@01)]
(assert (not (Set_in r$0@230@01 g1@211@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r$0@230@01 g1@211@01)) (Set_in r$0@230@01 g1@211@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r$0@230@01 $Ref)) (!
  (or (not (Set_in r$0@230@01 g1@211@01)) (Set_in r$0@230@01 g1@211@01))
  :pattern ((Set_in r$0@230@01 g0@210@01) (Set_in r$0@230@01 g1@211@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@399@14@399@34-aux|)))
(assert (forall ((r$0@230@01 $Ref)) (!
  (=> (Set_in r$0@230@01 g1@211@01) (not (Set_in r$0@230@01 g0@210@01)))
  :pattern ((Set_in r$0@230@01 g0@210@01) (Set_in r$0@230@01 g1@211@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@399@14@399@34|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))))
  $Snap.unit))
; [eval] exists_path($$(g0), x0, y0)
; [eval] $$(g0)
(push) ; 2
(declare-const n@231@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@231@01 g0@210@01))
(pop) ; 3
(declare-fun inv@232@01 ($Ref) $Ref)
(declare-fun img@233@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@231@01 $Ref) (n2@231@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@231@01 g0@210@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n1@231@01) n1@231@01))
      (and
        (Set_in n2@231@01 g0@210@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) n2@231@01) n2@231@01))
      (= n1@231@01 n2@231@01))
    (= n1@231@01 n2@231@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@231@01 $Ref)) (!
  (=>
    (Set_in n@231@01 g0@210@01)
    (and (= (inv@232@01 n@231@01) n@231@01) (img@233@01 n@231@01)))
  :pattern ((Set_in n@231@01 g0@210@01))
  :pattern ((inv@232@01 n@231@01))
  :pattern ((img@233@01 n@231@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@233@01 r) (Set_in (inv@232@01 r) g0@210@01))
    (= (inv@232@01 r) r))
  :pattern ((inv@232@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@232@01 r) g0@210@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) r) r))
  :pattern ((inv@232@01 r))
  :qid |quant-u-308|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@234@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r) (= r (inv@232@01 r)))
    ($Perm.min
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@235@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r) (= r (inv@232@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@234@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (pTaken@234@01 r))
    $Perm.No)
  
  :qid |quant-u-310|))))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@234@01 r) $Perm.No)
  
  :qid |quant-u-311|))))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r) (= r (inv@232@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@234@01 r)) $Perm.No))
  
  :qid |quant-u-312|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@236@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@236@01  $FVF<next>)))
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r)))
    (=>
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r))
      (Set_in r ($FVF.domain_next (as sm@236@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@236@01  $FVF<next>))))
  :qid |qp.fvfDomDef140|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@236@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@236@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@236@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@236@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@236@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@236@01  $FVF<next>)) g0@210@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@231@01 $Ref)) (!
  (=>
    (Set_in n@231@01 g0@210@01)
    (and (= (inv@232@01 n@231@01) n@231@01) (img@233@01 n@231@01)))
  :pattern ((Set_in n@231@01 g0@210@01))
  :pattern ((inv@232@01 n@231@01))
  :pattern ((img@233@01 n@231@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@233@01 r) (Set_in (inv@232@01 r) g0@210@01))
    (= (inv@232@01 r) r))
  :pattern ((inv@232@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@236@01  $FVF<next>)))
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r)))
    (=>
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r))
      (Set_in r ($FVF.domain_next (as sm@236@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@236@01  $FVF<next>))))
  :qid |qp.fvfDomDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@236@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@236@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@232@01 r) g0@210@01) (img@233@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@236@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@236@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@236@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@232@01 r) g0@210@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@227@01  $FVF<next>) r) r))
    :pattern ((inv@232@01 r))
    :qid |quant-u-308|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@236@01  $FVF<next>)) g0@210@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@236@01  $FVF<next>)) g0@210@01) x0@212@01 y0@213@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))))))))))
  $Snap.unit))
; [eval] exists_path($$(g1), x1, y1)
; [eval] $$(g1)
(set-option :timeout 0)
(push) ; 2
(declare-const n@237@01 $Ref)
(push) ; 3
; [eval] (n in refs)
(assert (Set_in n@237@01 g1@211@01))
(pop) ; 3
(declare-fun inv@238@01 ($Ref) $Ref)
(declare-fun img@239@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@240@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@240@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@240@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@240@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@240@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@240@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@237@01 $Ref) (n2@237@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@237@01 g1@211@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@240@01  $FVF<next>) n1@237@01) n1@237@01))
      (and
        (Set_in n2@237@01 g1@211@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@240@01  $FVF<next>) n2@237@01) n2@237@01))
      (= n1@237@01 n2@237@01))
    (= n1@237@01 n2@237@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@237@01 $Ref)) (!
  (=>
    (Set_in n@237@01 g1@211@01)
    (and (= (inv@238@01 n@237@01) n@237@01) (img@239@01 n@237@01)))
  :pattern ((Set_in n@237@01 g1@211@01))
  :pattern ((inv@238@01 n@237@01))
  :pattern ((img@239@01 n@237@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@239@01 r) (Set_in (inv@238@01 r) g1@211@01))
    (= (inv@238@01 r) r))
  :pattern ((inv@238@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@238@01 r) g1@211@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@240@01  $FVF<next>) r) r))
  :pattern ((inv@238@01 r))
  :qid |quant-u-314|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@241@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r) (= r (inv@238@01 r)))
    ($Perm.min
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@242@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r) (= r (inv@238@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@241@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (pTaken@241@01 r))
    $Perm.No)
  
  :qid |quant-u-316|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@241@01 r) $Perm.No)
  
  :qid |quant-u-317|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r) (= r (inv@238@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@241@01 r)) $Perm.No))
  
  :qid |quant-u-318|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (pTaken@242@01 r))
    $Perm.No)
  
  :qid |quant-u-319|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@242@01 r) $Perm.No)
  
  :qid |quant-u-320|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r) (= r (inv@238@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@241@01 r)) (pTaken@242@01 r))
      $Perm.No))
  
  :qid |quant-u-321|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@243@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@243@01  $FVF<next>)))
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r)))
    (=>
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r))
      (Set_in r ($FVF.domain_next (as sm@243@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@243@01  $FVF<next>))))
  :qid |qp.fvfDomDef147|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@243@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@243@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef145|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef146|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@243@01  $FVF<next>)) g1@211@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@240@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@240@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@240@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@240@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef142|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@240@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef143|)))
(assert (forall ((n@237@01 $Ref)) (!
  (=>
    (Set_in n@237@01 g1@211@01)
    (and (= (inv@238@01 n@237@01) n@237@01) (img@239@01 n@237@01)))
  :pattern ((Set_in n@237@01 g1@211@01))
  :pattern ((inv@238@01 n@237@01))
  :pattern ((img@239@01 n@237@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@239@01 r) (Set_in (inv@238@01 r) g1@211@01))
    (= (inv@238@01 r) r))
  :pattern ((inv@238@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@243@01  $FVF<next>)))
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r)))
    (=>
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r))
      (Set_in r ($FVF.domain_next (as sm@243@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@243@01  $FVF<next>))))
  :qid |qp.fvfDomDef147|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@243@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@238@01 r) g1@211@01) (img@239@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@243@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef145|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@243@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef146|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@238@01 r) g1@211@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@240@01  $FVF<next>) r) r))
    :pattern ((inv@238@01 r))
    :qid |quant-u-314|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@243@01  $FVF<next>)) g1@211@01)))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@243@01  $FVF<next>)) g1@211@01) x1@214@01 y1@215@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@244@01 $Snap)
(assert (= $t@244@01 ($Snap.combine ($Snap.first $t@244@01) ($Snap.second $t@244@01))))
(assert (= ($Snap.first $t@244@01) $Snap.unit))
; [eval] !((null in (g1 union g0)))
; [eval] (null in (g1 union g0))
; [eval] (g1 union g0)
(assert (not (Set_in $Ref.null (Set_union g1@211@01 g0@210@01))))
(assert (=
  ($Snap.second $t@244@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@244@01))
    ($Snap.second ($Snap.second $t@244@01)))))
(declare-const n$3@245@01 $Ref)
(push) ; 3
; [eval] (n$3 in (g1 union g0))
; [eval] (g1 union g0)
(assert (Set_in n$3@245@01 (Set_union g1@211@01 g0@210@01)))
(declare-const sm@246@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@247@01 ($Ref) $Ref)
(declare-fun img@248@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$31@245@01 $Ref) (n$32@245@01 $Ref)) (!
  (=>
    (and
      (Set_in n$31@245@01 (Set_union g1@211@01 g0@210@01))
      (Set_in n$32@245@01 (Set_union g1@211@01 g0@210@01))
      (= n$31@245@01 n$32@245@01))
    (= n$31@245@01 n$32@245@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$3@245@01 $Ref)) (!
  (=>
    (Set_in n$3@245@01 (Set_union g1@211@01 g0@210@01))
    (and (= (inv@247@01 n$3@245@01) n$3@245@01) (img@248@01 n$3@245@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) n$3@245@01) n$3@245@01))
  :qid |quant-u-323|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (= (inv@247@01 r) r))
  :pattern ((inv@247@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$3@245@01 $Ref)) (!
  (=>
    (Set_in n$3@245@01 (Set_union g1@211@01 g0@210@01))
    (not (= n$3@245@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) n$3@245@01) n$3@245@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@249@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@249@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef150|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) r) r))
  :pattern ((inv@247@01 r))
  :qid |quant-u-324|)))
(assert (=
  ($Snap.second ($Snap.second $t@244@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@244@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@244@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@244@01))) $Snap.unit))
; [eval] (forall n$4: Ref :: { (n$4.next in (g1 union g0)) } { (n$4 in (g1 union g0)), n$4.next } (n$4 in (g1 union g0)) && n$4.next != null ==> (n$4.next in (g1 union g0)))
(declare-const n$4@250@01 $Ref)
(push) ; 3
; [eval] (n$4 in (g1 union g0)) && n$4.next != null ==> (n$4.next in (g1 union g0))
; [eval] (n$4 in (g1 union g0)) && n$4.next != null
; [eval] (n$4 in (g1 union g0))
; [eval] (g1 union g0)
(push) ; 4
; [then-branch: 45 | !(n$4@250@01 in g1@211@01 ∪ g0@210@01) | live]
; [else-branch: 45 | n$4@250@01 in g1@211@01 ∪ g0@210@01 | live]
(push) ; 5
; [then-branch: 45 | !(n$4@250@01 in g1@211@01 ∪ g0@210@01)]
(assert (not (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 45 | n$4@250@01 in g1@211@01 ∪ g0@210@01]
(assert (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01)))
; [eval] n$4.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@248@01 r)
        (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
      (=
        ($FVF.lookup_next (as sm@249@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
    :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
    :qid |qp.fvfValDef149|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef150|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01))
(push) ; 6
(assert (not (and
  (img@248@01 n$4@250@01)
  (Set_in (inv@247@01 n$4@250@01) (Set_union g1@211@01 g0@210@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@249@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef150|)))
(assert (=>
  (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
  (and
    (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01))))
(assert (or
  (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
  (not (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01)))))
(push) ; 4
; [then-branch: 46 | n$4@250@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@249@01, n$4@250@01) != Null | live]
; [else-branch: 46 | !(n$4@250@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@249@01, n$4@250@01) != Null) | live]
(push) ; 5
; [then-branch: 46 | n$4@250@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@249@01, n$4@250@01) != Null]
(assert (and
  (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
  (not (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null))))
; [eval] (n$4.next in (g1 union g0))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@248@01 r)
        (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
      (=
        ($FVF.lookup_next (as sm@249@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
    :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
    :qid |qp.fvfValDef149|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef150|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01))
(push) ; 6
(assert (not (and
  (img@248@01 n$4@250@01)
  (Set_in (inv@247@01 n$4@250@01) (Set_union g1@211@01 g0@210@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; [eval] (g1 union g0)
(pop) ; 5
(push) ; 5
; [else-branch: 46 | !(n$4@250@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@249@01, n$4@250@01) != Null)]
(assert (not
  (and
    (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@249@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef150|)))
(assert (=>
  (and
    (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))
  (and
    (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
      (not
        (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null))))
  (and
    (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@249@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@249@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef150|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@250@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01)))
    (or
      (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
      (not (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))))
    (=>
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01)))
    (or
      (not
        (and
          (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
          (not
            (=
              ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01)
              $Ref.null))))
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) (Set_union g1@211@01 g0@210@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31-aux|)))
(assert (forall ((n$4@250@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01)))
    (or
      (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
      (not (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))))
    (=>
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01)))
    (or
      (not
        (and
          (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
          (not
            (=
              ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01)
              $Ref.null))))
      (and
        (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))))
  :pattern ((Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31-aux|)))
(assert (forall ((n$4@250@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01))
      (not
        (= ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) (Set_union g1@211@01 g0@210@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) (Set_union g1@211@01 g0@210@01)))
  :pattern ((Set_in n$4@250@01 (Set_union g1@211@01 g0@210@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n$4@250@01) n$4@250@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@244@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@244@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@244@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@244@01))))
  $Snap.unit))
; [eval] exists_path($$((g0 union g1)), x1, y1)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(declare-const n@251@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@251@01 (Set_union g0@210@01 g1@211@01)))
(pop) ; 4
(declare-fun inv@252@01 ($Ref) $Ref)
(declare-fun img@253@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@251@01 $Ref) (n2@251@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@251@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n1@251@01) n1@251@01))
      (and
        (Set_in n2@251@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) n2@251@01) n2@251@01))
      (= n1@251@01 n2@251@01))
    (= n1@251@01 n2@251@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@251@01 $Ref)) (!
  (=>
    (Set_in n@251@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@252@01 n@251@01) n@251@01) (img@253@01 n@251@01)))
  :pattern ((Set_in n@251@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@252@01 n@251@01))
  :pattern ((img@253@01 n@251@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@253@01 r) (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@252@01 r) r))
  :pattern ((inv@252@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) r) r))
  :pattern ((inv@252@01 r))
  :qid |quant-u-326|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@254@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
      (img@253@01 r)
      (= r (inv@252@01 r)))
    ($Perm.min
      (ite
        (and
          (img@248@01 r)
          (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@248@01 r)
          (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@254@01 r))
    $Perm.No)
  
  :qid |quant-u-328|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@254@01 r) $Perm.No)
  
  :qid |quant-u-329|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
      (img@253@01 r)
      (= r (inv@252@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@254@01 r)) $Perm.No))
  
  :qid |quant-u-330|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@255@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@255@01  $FVF<next>)))
      (and
        (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
        (img@253@01 r)))
    (=>
      (and
        (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
        (img@253@01 r))
      (Set_in r ($FVF.domain_next (as sm@255@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@255@01  $FVF<next>))))
  :qid |qp.fvfDomDef153|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
        (img@253@01 r))
      (and
        (img@248@01 r)
        (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01))))
    (=
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef151|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef152|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@255@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@251@01 $Ref)) (!
  (=>
    (Set_in n@251@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@252@01 n@251@01) n@251@01) (img@253@01 n@251@01)))
  :pattern ((Set_in n@251@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@252@01 n@251@01))
  :pattern ((img@253@01 n@251@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@253@01 r) (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@252@01 r) r))
  :pattern ((inv@252@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@255@01  $FVF<next>)))
      (and
        (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
        (img@253@01 r)))
    (=>
      (and
        (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
        (img@253@01 r))
      (Set_in r ($FVF.domain_next (as sm@255@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@255@01  $FVF<next>))))
  :qid |qp.fvfDomDef153|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
        (img@253@01 r))
      (and
        (img@248@01 r)
        (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01))))
    (=
      ($FVF.lookup_next (as sm@255@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef151|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@255@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef152|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@252@01 r) (Set_union g0@210@01 g1@211@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@249@01  $FVF<next>) r) r))
    :pattern ((inv@252@01 r))
    :qid |quant-u-326|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@255@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01))))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@255@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)) x1@214@01 y1@215@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@244@01))))
  $Snap.unit))
; [eval] exists_path($$((g0 union g1)), x0, y0)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(set-option :timeout 0)
(push) ; 3
(declare-const n@256@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@256@01 (Set_union g0@210@01 g1@211@01)))
(pop) ; 4
(declare-fun inv@257@01 ($Ref) $Ref)
(declare-fun img@258@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@259@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@259@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@259@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@259@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef155|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@256@01 $Ref) (n2@256@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@256@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@259@01  $FVF<next>) n1@256@01) n1@256@01))
      (and
        (Set_in n2@256@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@259@01  $FVF<next>) n2@256@01) n2@256@01))
      (= n1@256@01 n2@256@01))
    (= n1@256@01 n2@256@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@256@01 $Ref)) (!
  (=>
    (Set_in n@256@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@257@01 n@256@01) n@256@01) (img@258@01 n@256@01)))
  :pattern ((Set_in n@256@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@257@01 n@256@01))
  :pattern ((img@258@01 n@256@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@258@01 r) (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@257@01 r) r))
  :pattern ((inv@257@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@259@01  $FVF<next>) r) r))
  :pattern ((inv@257@01 r))
  :qid |quant-u-332|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@260@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
      (img@258@01 r)
      (= r (inv@257@01 r)))
    ($Perm.min
      (ite
        (and
          (img@248@01 r)
          (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@248@01 r)
          (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@260@01 r))
    $Perm.No)
  
  :qid |quant-u-334|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@260@01 r) $Perm.No)
  
  :qid |quant-u-335|))))
(check-sat)
; unknown
(pop) ; 4
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
      (img@258@01 r)
      (= r (inv@257@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@260@01 r)) $Perm.No))
  
  :qid |quant-u-336|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@261@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@261@01  $FVF<next>)))
      (and
        (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
        (img@258@01 r)))
    (=>
      (and
        (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
        (img@258@01 r))
      (Set_in r ($FVF.domain_next (as sm@261@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@261@01  $FVF<next>))))
  :qid |qp.fvfDomDef158|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
        (img@258@01 r))
      (and
        (img@248@01 r)
        (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01))))
    (=
      ($FVF.lookup_next (as sm@261@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@261@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@261@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef157|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@261@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@248@01 r) (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@259@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@259@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@259@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef155|)))
(assert (forall ((n@256@01 $Ref)) (!
  (=>
    (Set_in n@256@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@257@01 n@256@01) n@256@01) (img@258@01 n@256@01)))
  :pattern ((Set_in n@256@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@257@01 n@256@01))
  :pattern ((img@258@01 n@256@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@258@01 r) (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@257@01 r) r))
  :pattern ((inv@257@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@261@01  $FVF<next>)))
      (and
        (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
        (img@258@01 r)))
    (=>
      (and
        (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
        (img@258@01 r))
      (Set_in r ($FVF.domain_next (as sm@261@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@261@01  $FVF<next>))))
  :qid |qp.fvfDomDef158|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
        (img@258@01 r))
      (and
        (img@248@01 r)
        (Set_in (inv@247@01 r) (Set_union g1@211@01 g0@210@01))))
    (=
      ($FVF.lookup_next (as sm@261@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r)))
  :pattern (($FVF.lookup_next (as sm@261@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@244@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@261@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef157|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@257@01 r) (Set_union g0@210@01 g1@211@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@259@01  $FVF<next>) r) r))
    :pattern ((inv@257@01 r))
    :qid |quant-u-332|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@261@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01))))
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@261@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)) x0@212@01 y0@213@01))
(pop) ; 2
(set-option :timeout 0)
(push) ; 2
; [exec]
; inhale apply_TCFraming(g0, g1)
(declare-const $t@262@01 $Snap)
(assert (= $t@262@01 $Snap.unit))
; [eval] apply_TCFraming(g0, g1)
(push) ; 3
; [eval] !((null in g0))
; [eval] (null in g0)
(declare-const n@263@01 $Ref)
(push) ; 4
; [eval] (n in g0)
(assert (Set_in n@263@01 g0@210@01))
(pop) ; 4
(declare-fun inv@264@01 ($Ref) $Ref)
(declare-fun img@265@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@266@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@266@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@266@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef159|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@266@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@266@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@266@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef161|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@263@01 $Ref) (n2@263@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@263@01 g0@210@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@266@01  $FVF<next>) n1@263@01) n1@263@01))
      (and
        (Set_in n2@263@01 g0@210@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@266@01  $FVF<next>) n2@263@01) n2@263@01))
      (= n1@263@01 n2@263@01))
    (= n1@263@01 n2@263@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@263@01 $Ref)) (!
  (=>
    (Set_in n@263@01 g0@210@01)
    (and (= (inv@264@01 n@263@01) n@263@01) (img@265@01 n@263@01)))
  :pattern ((Set_in n@263@01 g0@210@01))
  :pattern ((inv@264@01 n@263@01))
  :pattern ((img@265@01 n@263@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@265@01 r) (Set_in (inv@264@01 r) g0@210@01))
    (= (inv@264@01 r) r))
  :pattern ((inv@264@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@264@01 r) g0@210@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@266@01  $FVF<next>) r) r))
  :pattern ((inv@264@01 r))
  :qid |quant-u-338|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@267@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r) (= r (inv@264@01 r)))
    ($Perm.min
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@268@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r) (= r (inv@264@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@267@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (pTaken@267@01 r))
    $Perm.No)
  
  :qid |quant-u-340|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r) (= r (inv@264@01 r)))
    (= (- $Perm.Write (pTaken@267@01 r)) $Perm.No))
  
  :qid |quant-u-341|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@269@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@269@01  $FVF<next>)))
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r)))
    (=>
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r))
      (Set_in r ($FVF.domain_next (as sm@269@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@269@01  $FVF<next>))))
  :qid |qp.fvfDomDef165|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@269@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@269@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@269@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@269@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@269@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
; [eval] (forall n$0: Ref ::(n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@270@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 5
; [then-branch: 47 | !(n$0@270@01 in g0@210@01) | live]
; [else-branch: 47 | n$0@270@01 in g0@210@01 | live]
(push) ; 6
; [then-branch: 47 | !(n$0@270@01 in g0@210@01)]
(assert (not (Set_in n$0@270@01 g0@210@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 47 | n$0@270@01 in g0@210@01]
(assert (Set_in n$0@270@01 g0@210@01))
; [eval] n$0.next != null
(declare-const sm@271@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(declare-const pm@272@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@272@01  $FPM) r)
    (+
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resPrmSumDef169|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resTrgDef170|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) n$0@270@01))
(push) ; 7
(assert (not (< $Perm.No ($FVF.perm_next (as pm@272@01  $FPM) n$0@270@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@272@01  $FPM) r)
    (+
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resPrmSumDef169|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resTrgDef170|)))
(assert (=>
  (Set_in n$0@270@01 g0@210@01)
  (and
    (Set_in n$0@270@01 g0@210@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) n$0@270@01))))
(assert (or (Set_in n$0@270@01 g0@210@01) (not (Set_in n$0@270@01 g0@210@01))))
(push) ; 5
; [then-branch: 48 | n$0@270@01 in g0@210@01 && Lookup(next, sm@271@01, n$0@270@01) != Null | live]
; [else-branch: 48 | !(n$0@270@01 in g0@210@01 && Lookup(next, sm@271@01, n$0@270@01) != Null) | live]
(push) ; 6
; [then-branch: 48 | n$0@270@01 in g0@210@01 && Lookup(next, sm@271@01, n$0@270@01) != Null]
(assert (and
  (Set_in n$0@270@01 g0@210@01)
  (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef166|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef167|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef168|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) n$0@270@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$0@270@01) (Set_in (inv@220@01 n$0@270@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$0@270@01) (Set_in (inv@225@01 n$0@270@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 48 | !(n$0@270@01 in g0@210@01 && Lookup(next, sm@271@01, n$0@270@01) != Null)]
(assert (not
  (and
    (Set_in n$0@270@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (=>
  (and
    (Set_in n$0@270@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null)))
  (and
    (Set_in n$0@270@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) n$0@270@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@270@01 g0@210@01)
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null))))
  (and
    (Set_in n$0@270@01 g0@210@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@272@01  $FPM) r)
    (+
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resPrmSumDef169|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resTrgDef170|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$0@270@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@270@01 g0@210@01)
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) g0@210@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@270@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@270@01 g0@210@01)
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) g0@210@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|)))
; [eval] !((null in g1))
; [eval] (null in g1)
(declare-const n$1@273@01 $Ref)
(push) ; 4
; [eval] (n$1 in g1)
(assert (Set_in n$1@273@01 g1@211@01))
(pop) ; 4
(declare-fun inv@274@01 ($Ref) $Ref)
(declare-fun img@275@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@276@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@276@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@276@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef171|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@276@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef172|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n$11@273@01 $Ref) (n$12@273@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@273@01 g1@211@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@276@01  $FVF<next>) n$11@273@01) n$11@273@01))
      (and
        (Set_in n$12@273@01 g1@211@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@276@01  $FVF<next>) n$12@273@01) n$12@273@01))
      (= n$11@273@01 n$12@273@01))
    (= n$11@273@01 n$12@273@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@273@01 $Ref)) (!
  (=>
    (Set_in n$1@273@01 g1@211@01)
    (and (= (inv@274@01 n$1@273@01) n$1@273@01) (img@275@01 n$1@273@01)))
  :pattern ((Set_in n$1@273@01 g1@211@01))
  :pattern ((inv@274@01 n$1@273@01))
  :pattern ((img@275@01 n$1@273@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@275@01 r) (Set_in (inv@274@01 r) g1@211@01))
    (= (inv@274@01 r) r))
  :pattern ((inv@274@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@274@01 r) g1@211@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@276@01  $FVF<next>) r) r))
  :pattern ((inv@274@01 r))
  :qid |quant-u-343|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@277@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r) (= r (inv@274@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (pTaken@277@01 r))
    $Perm.No)
  
  :qid |quant-u-345|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r) (= r (inv@274@01 r)))
    (= (- $Perm.Write (pTaken@277@01 r)) $Perm.No))
  
  :qid |quant-u-346|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@278@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@278@01  $FVF<next>)))
      (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r)))
    (=>
      (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r))
      (Set_in r ($FVF.domain_next (as sm@278@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@278@01  $FVF<next>))))
  :qid |qp.fvfDomDef175|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef174|)))
; [eval] (forall n$2: Ref ::(n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@279@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 5
; [then-branch: 49 | !(n$2@279@01 in g1@211@01) | live]
; [else-branch: 49 | n$2@279@01 in g1@211@01 | live]
(push) ; 6
; [then-branch: 49 | !(n$2@279@01 in g1@211@01)]
(assert (not (Set_in n$2@279@01 g1@211@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 49 | n$2@279@01 in g1@211@01]
(assert (Set_in n$2@279@01 g1@211@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef166|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef167|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef168|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) n$2@279@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$2@279@01) (Set_in (inv@220@01 n$2@279@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$2@279@01) (Set_in (inv@225@01 n$2@279@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (=>
  (Set_in n$2@279@01 g1@211@01)
  (and
    (Set_in n$2@279@01 g1@211@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) n$2@279@01))))
(assert (or (Set_in n$2@279@01 g1@211@01) (not (Set_in n$2@279@01 g1@211@01))))
(push) ; 5
; [then-branch: 50 | n$2@279@01 in g1@211@01 && Lookup(next, sm@271@01, n$2@279@01) != Null | live]
; [else-branch: 50 | !(n$2@279@01 in g1@211@01 && Lookup(next, sm@271@01, n$2@279@01) != Null) | live]
(push) ; 6
; [then-branch: 50 | n$2@279@01 in g1@211@01 && Lookup(next, sm@271@01, n$2@279@01) != Null]
(assert (and
  (Set_in n$2@279@01 g1@211@01)
  (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef166|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef167|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef168|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) n$2@279@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$2@279@01) (Set_in (inv@220@01 n$2@279@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$2@279@01) (Set_in (inv@225@01 n$2@279@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 50 | !(n$2@279@01 in g1@211@01 && Lookup(next, sm@271@01, n$2@279@01) != Null)]
(assert (not
  (and
    (Set_in n$2@279@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (=>
  (and
    (Set_in n$2@279@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null)))
  (and
    (Set_in n$2@279@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) n$2@279@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@279@01 g1@211@01)
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null))))
  (and
    (Set_in n$2@279@01 g1@211@01)
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$2@279@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@279@01 g1@211@01)
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) g1@211@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@279@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@279@01 g1@211@01)
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) g1@211@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|)))
; [eval] (g1 intersection g0) == Set[Ref]()
; [eval] (g1 intersection g0)
; [eval] Set[Ref]()
(push) ; 4
(assert (not (Set_equal (Set_intersection g1@211@01 g0@210@01) (as Set_empty  Set<$Ref>))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (Set_equal (Set_intersection g1@211@01 g0@210@01) (as Set_empty  Set<$Ref>)))
(assert (apply_TCFraming%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@269@01  $FVF<next>))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<next>To$Snap (as sm@278@01  $FVF<next>))
          ($Snap.combine $Snap.unit $Snap.unit)))))) g0@210@01 g1@211@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@266@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@266@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef159|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@266@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@266@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@266@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef161|)))
(assert (forall ((n@263@01 $Ref)) (!
  (=>
    (Set_in n@263@01 g0@210@01)
    (and (= (inv@264@01 n@263@01) n@263@01) (img@265@01 n@263@01)))
  :pattern ((Set_in n@263@01 g0@210@01))
  :pattern ((inv@264@01 n@263@01))
  :pattern ((img@265@01 n@263@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@265@01 r) (Set_in (inv@264@01 r) g0@210@01))
    (= (inv@264@01 r) r))
  :pattern ((inv@264@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@269@01  $FVF<next>)))
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r)))
    (=>
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r))
      (Set_in r ($FVF.domain_next (as sm@269@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@269@01  $FVF<next>))))
  :qid |qp.fvfDomDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@269@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@269@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@264@01 r) g0@210@01) (img@265@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@269@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@269@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@269@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef164|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@272@01  $FPM) r)
    (+
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resPrmSumDef169|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@272@01  $FPM) r))
  :qid |qp.resTrgDef170|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@276@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@276@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef171|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@276@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef172|)))
(assert (forall ((n$1@273@01 $Ref)) (!
  (=>
    (Set_in n$1@273@01 g1@211@01)
    (and (= (inv@274@01 n$1@273@01) n$1@273@01) (img@275@01 n$1@273@01)))
  :pattern ((Set_in n$1@273@01 g1@211@01))
  :pattern ((inv@274@01 n$1@273@01))
  :pattern ((img@275@01 n$1@273@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@275@01 r) (Set_in (inv@274@01 r) g1@211@01))
    (= (inv@274@01 r) r))
  :pattern ((inv@274@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@278@01  $FVF<next>)))
      (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r)))
    (=>
      (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r))
      (Set_in r ($FVF.domain_next (as sm@278@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@278@01  $FVF<next>))))
  :qid |qp.fvfDomDef175|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@274@01 r) g1@211@01) (img@275@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@278@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@278@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef174|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@264@01 r) g0@210@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@266@01  $FVF<next>) r) r))
    :pattern ((inv@264@01 r))
    :qid |quant-u-338|))
  (forall ((n$0@270@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@270@01 g0@210@01)
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$0@270@01) g0@210@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|))
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@274@01 r) g1@211@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@276@01  $FVF<next>) r) r))
    :pattern ((inv@274@01 r))
    :qid |quant-u-343|))
  (forall ((n$2@279@01 $Ref)) (!
    (=>
      (and
        (Set_in n$2@279@01 g1@211@01)
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$2@279@01) g1@211@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|))
  (Set_equal (Set_intersection g1@211@01 g0@210@01) (as Set_empty  Set<$Ref>))
  (apply_TCFraming%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@269@01  $FVF<next>))
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($SortWrappers.$FVF<next>To$Snap (as sm@278@01  $FVF<next>))
            ($Snap.combine $Snap.unit $Snap.unit)))))) g0@210@01 g1@211@01)))
(assert (apply_TCFraming ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@269@01  $FVF<next>))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<next>To$Snap (as sm@278@01  $FVF<next>))
          ($Snap.combine $Snap.unit $Snap.unit)))))) g0@210@01 g1@211@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] !((null in (g1 union g0)))
; [eval] (null in (g1 union g0))
; [eval] (g1 union g0)
(set-option :timeout 0)
(push) ; 3
(assert (not (not (Set_in $Ref.null (Set_union g1@211@01 g0@210@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (not (Set_in $Ref.null (Set_union g1@211@01 g0@210@01))))
(declare-const n$3@280@01 $Ref)
(push) ; 3
; [eval] (n$3 in (g1 union g0))
; [eval] (g1 union g0)
(assert (Set_in n$3@280@01 (Set_union g1@211@01 g0@210@01)))
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@281@01 ($Ref) $Ref)
(declare-fun img@282@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$31@280@01 $Ref) (n$32@280@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$31@280@01 (Set_union g1@211@01 g0@210@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$31@280@01) n$31@280@01))
      (and
        (Set_in n$32@280@01 (Set_union g1@211@01 g0@210@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$32@280@01) n$32@280@01))
      (= n$31@280@01 n$32@280@01))
    (= n$31@280@01 n$32@280@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$3@280@01 $Ref)) (!
  (=>
    (Set_in n$3@280@01 (Set_union g1@211@01 g0@210@01))
    (and (= (inv@281@01 n$3@280@01) n$3@280@01) (img@282@01 n$3@280@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$3@280@01) n$3@280@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@282@01 r) (Set_in (inv@281@01 r) (Set_union g1@211@01 g0@210@01)))
    (= (inv@281@01 r) r))
  :pattern ((inv@281@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@281@01 r) (Set_union g1@211@01 g0@210@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r))
  :pattern ((inv@281@01 r))
  :qid |quant-u-348|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@283@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@281@01 r) (Set_union g1@211@01 g0@210@01))
      (img@282@01 r)
      (= r (inv@281@01 r)))
    ($Perm.min
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@284@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@281@01 r) (Set_union g1@211@01 g0@210@01))
      (img@282@01 r)
      (= r (inv@281@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@283@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (pTaken@283@01 r))
    $Perm.No)
  
  :qid |quant-u-350|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@281@01 r) (Set_union g1@211@01 g0@210@01))
      (img@282@01 r)
      (= r (inv@281@01 r)))
    (= (- $Perm.Write (pTaken@283@01 r)) $Perm.No))
  
  :qid |quant-u-351|))))
(check-sat)
; unknown
(pop) ; 3
; 0,12s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (pTaken@284@01 r))
    $Perm.No)
  
  :qid |quant-u-352|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@281@01 r) (Set_union g1@211@01 g0@210@01))
      (img@282@01 r)
      (= r (inv@281@01 r)))
    (= (- (- $Perm.Write (pTaken@283@01 r)) (pTaken@284@01 r)) $Perm.No))
  
  :qid |quant-u-353|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$4: Ref :: { (n$4.next in (g1 union g0)) } { (n$4 in (g1 union g0)), n$4.next } (n$4 in (g1 union g0)) && n$4.next != null ==> (n$4.next in (g1 union g0)))
(declare-const n$4@285@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$4 in (g1 union g0)) && n$4.next != null ==> (n$4.next in (g1 union g0))
; [eval] (n$4 in (g1 union g0)) && n$4.next != null
; [eval] (n$4 in (g1 union g0))
; [eval] (g1 union g0)
(push) ; 4
; [then-branch: 51 | !(n$4@285@01 in g1@211@01 ∪ g0@210@01) | live]
; [else-branch: 51 | n$4@285@01 in g1@211@01 ∪ g0@210@01 | live]
(push) ; 5
; [then-branch: 51 | !(n$4@285@01 in g1@211@01 ∪ g0@210@01)]
(assert (not (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 51 | n$4@285@01 in g1@211@01 ∪ g0@210@01]
(assert (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01)))
; [eval] n$4.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef166|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef167|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef168|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$4@285@01) (Set_in (inv@220@01 n$4@285@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$4@285@01) (Set_in (inv@225@01 n$4@285@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (=>
  (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
  (and
    (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))))
(assert (or
  (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
  (not (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01)))))
(push) ; 4
; [then-branch: 52 | n$4@285@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@271@01, n$4@285@01) != Null | live]
; [else-branch: 52 | !(n$4@285@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@271@01, n$4@285@01) != Null) | live]
(push) ; 5
; [then-branch: 52 | n$4@285@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@271@01, n$4@285@01) != Null]
(assert (and
  (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
  (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null))))
; [eval] (n$4.next in (g1 union g0))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
    :qid |qp.fvfValDef166|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
      (=
        ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
    :qid |qp.fvfValDef167|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef168|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@221@01 n$4@285@01) (Set_in (inv@220@01 n$4@285@01) g0@210@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@226@01 n$4@285@01) (Set_in (inv@225@01 n$4@285@01) g1@211@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; [eval] (g1 union g0)
(pop) ; 5
(push) ; 5
; [else-branch: 52 | !(n$4@285@01 in g1@211@01 ∪ g0@210@01 && Lookup(next, sm@271@01, n$4@285@01) != Null)]
(assert (not
  (and
    (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
(assert (=>
  (and
    (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))
  (and
    (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null))))
  (and
    (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
    (not (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef166|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@271@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@271@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef168|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@285@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01)))
    (or
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (not (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))))
    (=>
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01)))
    (or
      (not
        (and
          (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
          (not
            (=
              ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01)
              $Ref.null))))
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) (Set_union g1@211@01 g0@210@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31-aux|)))
(assert (forall ((n$4@285@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01)))
    (or
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (not (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))))
    (=>
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01)))
    (or
      (not
        (and
          (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
          (not
            (=
              ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01)
              $Ref.null))))
      (and
        (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
        (not
          (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))))
  :pattern ((Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31-aux|)))
(push) ; 3
(assert (not (forall ((n$4@285@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) (Set_union g1@211@01 g0@210@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) (Set_union g1@211@01 g0@210@01)))
  :pattern ((Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$4@285@01 $Ref)) (!
  (=>
    (and
      (Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01))
      (not
        (= ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) (Set_union g1@211@01 g0@210@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) (Set_union g1@211@01 g0@210@01)))
  :pattern ((Set_in n$4@285@01 (Set_union g1@211@01 g0@210@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n$4@285@01) n$4@285@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@403@13@403@31|)))
; [eval] exists_path($$((g0 union g1)), x1, y1)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(declare-const n@286@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@286@01 (Set_union g0@210@01 g1@211@01)))
(pop) ; 4
(declare-fun inv@287@01 ($Ref) $Ref)
(declare-fun img@288@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@286@01 $Ref) (n2@286@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@286@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n1@286@01) n1@286@01))
      (and
        (Set_in n2@286@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) n2@286@01) n2@286@01))
      (= n1@286@01 n2@286@01))
    (= n1@286@01 n2@286@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r))
  :pattern ((inv@287@01 r))
  :qid |quant-u-355|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@289@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
      (img@288@01 r)
      (= r (inv@287@01 r)))
    ($Perm.min
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@290@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
      (img@288@01 r)
      (= r (inv@287@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@289@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (pTaken@289@01 r))
    $Perm.No)
  
  :qid |quant-u-357|))))
(check-sat)
; unknown
(pop) ; 4
; 0,33s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@289@01 r) $Perm.No)
  
  :qid |quant-u-358|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
      (img@288@01 r)
      (= r (inv@287@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@289@01 r)) $Perm.No))
  
  :qid |quant-u-359|))))
(check-sat)
; unknown
(pop) ; 4
; 0,38s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (pTaken@290@01 r))
    $Perm.No)
  
  :qid |quant-u-360|))))
(check-sat)
; unknown
(pop) ; 4
; 0,33s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@290@01 r) $Perm.No)
  
  :qid |quant-u-361|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
      (img@288@01 r)
      (= r (inv@287@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@289@01 r)) (pTaken@290@01 r))
      $Perm.No))
  
  :qid |quant-u-362|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@291@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef179|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef178|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@286@01 $Ref)) (!
  (=>
    (Set_in n@286@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@287@01 n@286@01) n@286@01) (img@288@01 n@286@01)))
  :pattern ((Set_in n@286@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@287@01 n@286@01))
  :pattern ((img@288@01 n@286@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@288@01 r) (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@287@01 r) r))
  :pattern ((inv@287@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r)))
    (=>
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r))
      (Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@291@01  $FVF<next>))))
  :qid |qp.fvfDomDef179|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
        (img@288@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@291@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@291@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef178|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@287@01 r) (Set_union g0@210@01 g1@211@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@271@01  $FVF<next>) r) r))
    :pattern ((inv@287@01 r))
    :qid |quant-u-355|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01))))
(set-option :timeout 0)
(push) ; 3
(assert (not (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)) x1@214@01 y1@215@01)))
(check-sat)
; unsat
(pop) ; 3
; 0,39s
; (get-info :all-statistics)
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@291@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)) x1@214@01 y1@215@01))
; [eval] exists_path($$((g0 union g1)), x0, y0)
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(declare-const n@292@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@292@01 (Set_union g0@210@01 g1@211@01)))
(pop) ; 4
(declare-fun inv@293@01 ($Ref) $Ref)
(declare-fun img@294@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@295@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@292@01 $Ref) (n2@292@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@292@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) n1@292@01) n1@292@01))
      (and
        (Set_in n2@292@01 (Set_union g0@210@01 g1@211@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) n2@292@01) n2@292@01))
      (= n1@292@01 n2@292@01))
    (= n1@292@01 n2@292@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
  :pattern ((inv@293@01 r))
  :qid |quant-u-364|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@296@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
      (img@294@01 r)
      (= r (inv@293@01 r)))
    ($Perm.min
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@297@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
      (img@294@01 r)
      (= r (inv@293@01 r)))
    ($Perm.min
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@296@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
        $Perm.Write
        $Perm.No)
      (pTaken@296@01 r))
    $Perm.No)
  
  :qid |quant-u-366|))))
(check-sat)
; unknown
(pop) ; 4
; 0,52s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@296@01 r) $Perm.No)
  
  :qid |quant-u-367|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
      (img@294@01 r)
      (= r (inv@293@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@296@01 r)) $Perm.No))
  
  :qid |quant-u-368|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
        $Perm.Write
        $Perm.No)
      (pTaken@297@01 r))
    $Perm.No)
  
  :qid |quant-u-369|))))
(check-sat)
; unknown
(pop) ; 4
; 0,47s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@297@01 r) $Perm.No)
  
  :qid |quant-u-370|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
      (img@294@01 r)
      (= r (inv@293@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@296@01 r)) (pTaken@297@01 r))
      $Perm.No))
  
  :qid |quant-u-371|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@298@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@298@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@298@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@298@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@298@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@298@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@298@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@298@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@298@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@298@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01))
    (=
      ($FVF.lookup_next (as sm@295@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@295@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef182|)))
(assert (forall ((n@292@01 $Ref)) (!
  (=>
    (Set_in n@292@01 (Set_union g0@210@01 g1@211@01))
    (and (= (inv@293@01 n@292@01) n@292@01) (img@294@01 n@292@01)))
  :pattern ((Set_in n@292@01 (Set_union g0@210@01 g1@211@01)))
  :pattern ((inv@293@01 n@292@01))
  :pattern ((img@294@01 n@292@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@294@01 r) (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01)))
    (= (inv@293@01 r) r))
  :pattern ((inv@293@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@298@01  $FVF<next>)))
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r)))
    (=>
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r))
      (Set_in r ($FVF.domain_next (as sm@298@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@298@01  $FVF<next>))))
  :qid |qp.fvfDomDef186|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r))
      (and (img@221@01 r) (Set_in (inv@220@01 r) g0@210@01)))
    (=
      ($FVF.lookup_next (as sm@298@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r)))
  :pattern (($FVF.lookup_next (as sm@298@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r))
  :qid |qp.fvfValDef183|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
        (img@294@01 r))
      (and (img@226@01 r) (Set_in (inv@225@01 r) g1@211@01)))
    (=
      ($FVF.lookup_next (as sm@298@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@298@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@217@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@217@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@298@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef185|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@293@01 r) (Set_union g0@210@01 g1@211@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@295@01  $FVF<next>) r) r))
    :pattern ((inv@293@01 r))
    :qid |quant-u-364|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@298@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01))))
(set-option :timeout 0)
(push) ; 3
(assert (not (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@298@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)) x0@212@01 y0@213@01)))
(check-sat)
; unsat
(pop) ; 3
; 0,51s
; (get-info :all-statistics)
(assert (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@298@01  $FVF<next>)) (Set_union g0@210@01 g1@211@01)) x0@212@01 y0@213@01))
(pop) ; 2
(pop) ; 1
; ---------- test_union ----------
(declare-const g0@299@01 Set<$Ref>)
(declare-const g1@300@01 Set<$Ref>)
(declare-const x0@301@01 $Ref)
(declare-const x1@302@01 $Ref)
(declare-const x@303@01 $Ref)
(declare-const g0@304@01 Set<$Ref>)
(declare-const g1@305@01 Set<$Ref>)
(declare-const x0@306@01 $Ref)
(declare-const x1@307@01 $Ref)
(declare-const x@308@01 $Ref)
(push) ; 1
(declare-const $t@309@01 $Snap)
(assert (= $t@309@01 ($Snap.combine ($Snap.first $t@309@01) ($Snap.second $t@309@01))))
(assert (= ($Snap.first $t@309@01) $Snap.unit))
; [eval] !((null in g0))
; [eval] (null in g0)
(assert (not (Set_in $Ref.null g0@304@01)))
(assert (=
  ($Snap.second $t@309@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@309@01))
    ($Snap.second ($Snap.second $t@309@01)))))
(declare-const n@310@01 $Ref)
(push) ; 2
; [eval] (n in g0)
(assert (Set_in n@310@01 g0@304@01))
(declare-const sm@311@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@312@01 ($Ref) $Ref)
(declare-fun img@313@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n1@310@01 $Ref) (n2@310@01 $Ref)) (!
  (=>
    (and
      (Set_in n1@310@01 g0@304@01)
      (Set_in n2@310@01 g0@304@01)
      (= n1@310@01 n2@310@01))
    (= n1@310@01 n2@310@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@310@01 $Ref)) (!
  (=>
    (Set_in n@310@01 g0@304@01)
    (and (= (inv@312@01 n@310@01) n@310@01) (img@313@01 n@310@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) n@310@01) n@310@01))
  :qid |quant-u-373|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (= (inv@312@01 r) r))
  :pattern ((inv@312@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n@310@01 $Ref)) (!
  (=> (Set_in n@310@01 g0@304@01) (not (= n@310@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) n@310@01) n@310@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@314@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef188|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef189|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@312@01 r) g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) r) r))
  :pattern ((inv@312@01 r))
  :qid |quant-u-374|)))
(assert (=
  ($Snap.second ($Snap.second $t@309@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@309@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@309@01))) $Snap.unit))
; [eval] (forall n$0: Ref :: { (n$0.next in g0) } { (n$0 in g0), n$0.next } (n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@315@01 $Ref)
(push) ; 2
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 3
; [then-branch: 53 | !(n$0@315@01 in g0@304@01) | live]
; [else-branch: 53 | n$0@315@01 in g0@304@01 | live]
(push) ; 4
; [then-branch: 53 | !(n$0@315@01 in g0@304@01)]
(assert (not (Set_in n$0@315@01 g0@304@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 53 | n$0@315@01 in g0@304@01]
(assert (Set_in n$0@315@01 g0@304@01))
; [eval] n$0.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef188|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef189|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01))
(push) ; 5
(assert (not (and (img@313@01 n$0@315@01) (Set_in (inv@312@01 n$0@315@01) g0@304@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef188|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef189|)))
(assert (=>
  (Set_in n$0@315@01 g0@304@01)
  (and
    (Set_in n$0@315@01 g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01))))
(assert (or (Set_in n$0@315@01 g0@304@01) (not (Set_in n$0@315@01 g0@304@01))))
(push) ; 3
; [then-branch: 54 | n$0@315@01 in g0@304@01 && Lookup(next, sm@314@01, n$0@315@01) != Null | live]
; [else-branch: 54 | !(n$0@315@01 in g0@304@01 && Lookup(next, sm@314@01, n$0@315@01) != Null) | live]
(push) ; 4
; [then-branch: 54 | n$0@315@01 in g0@304@01 && Lookup(next, sm@314@01, n$0@315@01) != Null]
(assert (and
  (Set_in n$0@315@01 g0@304@01)
  (not (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef188|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef189|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01))
(push) ; 5
(assert (not (and (img@313@01 n$0@315@01) (Set_in (inv@312@01 n$0@315@01) g0@304@01))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 54 | !(n$0@315@01 in g0@304@01 && Lookup(next, sm@314@01, n$0@315@01) != Null)]
(assert (not
  (and
    (Set_in n$0@315@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef188|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef189|)))
(assert (=>
  (and
    (Set_in n$0@315@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))
  (and
    (Set_in n$0@315@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@315@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null))))
  (and
    (Set_in n$0@315@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@314@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef188|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@314@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef189|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$0@315@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@315@01 g0@304@01)
      (and
        (Set_in n$0@315@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01)))
    (or (Set_in n$0@315@01 g0@304@01) (not (Set_in n$0@315@01 g0@304@01)))
    (=>
      (and
        (Set_in n$0@315@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))
      (and
        (Set_in n$0@315@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01)))
    (or
      (not
        (and
          (Set_in n$0@315@01 g0@304@01)
          (not
            (=
              ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01)
              $Ref.null))))
      (and
        (Set_in n$0@315@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) g0@304@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@411@14@411@23-aux|)))
(assert (forall ((n$0@315@01 $Ref)) (!
  (and
    (=>
      (Set_in n$0@315@01 g0@304@01)
      (and
        (Set_in n$0@315@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01)))
    (or (Set_in n$0@315@01 g0@304@01) (not (Set_in n$0@315@01 g0@304@01)))
    (=>
      (and
        (Set_in n$0@315@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))
      (and
        (Set_in n$0@315@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01)))
    (or
      (not
        (and
          (Set_in n$0@315@01 g0@304@01)
          (not
            (=
              ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01)
              $Ref.null))))
      (and
        (Set_in n$0@315@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))))
  :pattern ((Set_in n$0@315@01 g0@304@01) ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@411@14@411@23-aux|)))
(assert (forall ((n$0@315@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@315@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) g0@304@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) g0@304@01))
  :pattern ((Set_in n$0@315@01 g0@304@01) ($FVF.loc_next ($FVF.lookup_next (as sm@314@01  $FVF<next>) n$0@315@01) n$0@315@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@411@14@411@23|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@309@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@309@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@309@01))))
  $Snap.unit))
; [eval] !((null in g1))
; [eval] (null in g1)
(assert (not (Set_in $Ref.null g1@305@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))
(declare-const n$1@316@01 $Ref)
(push) ; 2
; [eval] (n$1 in g1)
(assert (Set_in n$1@316@01 g1@305@01))
; Definitional axioms for snapshot map values
(pop) ; 2
(declare-fun inv@317@01 ($Ref) $Ref)
(declare-fun img@318@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((n$11@316@01 $Ref) (n$12@316@01 $Ref)) (!
  (=>
    (and
      (Set_in n$11@316@01 g1@305@01)
      (Set_in n$12@316@01 g1@305@01)
      (= n$11@316@01 n$12@316@01))
    (= n$11@316@01 n$12@316@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@316@01 $Ref)) (!
  (=>
    (Set_in n$1@316@01 g1@305@01)
    (and (= (inv@317@01 n$1@316@01) n$1@316@01) (img@318@01 n$1@316@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) n$1@316@01) n$1@316@01))
  :qid |quant-u-376|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (= (inv@317@01 r) r))
  :pattern ((inv@317@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$1@316@01 $Ref)) (!
  (=> (Set_in n$1@316@01 g1@305@01) (not (= n$1@316@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) n$1@316@01) n$1@316@01))
  :qid |next-permImpliesNonNull|)))
(push) ; 2
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (and
    (= n$1@316@01 n@310@01)
    (=
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))))
  
  :qid |quant-u-377|))))
(check-sat)
; unknown
(pop) ; 2
; 0,01s
; (get-info :all-statistics)
(declare-const sm@319@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef191|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef192|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@317@01 r) g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
  :pattern ((inv@317@01 r))
  :qid |quant-u-378|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))
  $Snap.unit))
; [eval] (forall n$2: Ref :: { (n$2.next in g1) } { (n$2 in g1), n$2.next } (n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@320@01 $Ref)
(set-option :timeout 0)
(push) ; 2
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 3
; [then-branch: 55 | !(n$2@320@01 in g1@305@01) | live]
; [else-branch: 55 | n$2@320@01 in g1@305@01 | live]
(push) ; 4
; [then-branch: 55 | !(n$2@320@01 in g1@305@01)]
(assert (not (Set_in n$2@320@01 g1@305@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 55 | n$2@320@01 in g1@305@01]
(assert (Set_in n$2@320@01 g1@305@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef190|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef191|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef192|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$2@320@01) (Set_in (inv@312@01 n$2@320@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$2@320@01) (Set_in (inv@317@01 n$2@320@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef191|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef192|)))
(assert (=>
  (Set_in n$2@320@01 g1@305@01)
  (and
    (Set_in n$2@320@01 g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01))))
(assert (or (Set_in n$2@320@01 g1@305@01) (not (Set_in n$2@320@01 g1@305@01))))
(push) ; 3
; [then-branch: 56 | n$2@320@01 in g1@305@01 && Lookup(next, sm@319@01, n$2@320@01) != Null | live]
; [else-branch: 56 | !(n$2@320@01 in g1@305@01 && Lookup(next, sm@319@01, n$2@320@01) != Null) | live]
(push) ; 4
; [then-branch: 56 | n$2@320@01 in g1@305@01 && Lookup(next, sm@319@01, n$2@320@01) != Null]
(assert (and
  (Set_in n$2@320@01 g1@305@01)
  (not (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef190|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef191|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef192|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$2@320@01) (Set_in (inv@312@01 n$2@320@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$2@320@01) (Set_in (inv@317@01 n$2@320@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0,00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 56 | !(n$2@320@01 in g1@305@01 && Lookup(next, sm@319@01, n$2@320@01) != Null)]
(assert (not
  (and
    (Set_in n$2@320@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef191|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef192|)))
(assert (=>
  (and
    (Set_in n$2@320@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))
  (and
    (Set_in n$2@320@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@320@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null))))
  (and
    (Set_in n$2@320@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef190|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@319@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef191|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@319@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef192|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$2@320@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@320@01 g1@305@01)
      (and
        (Set_in n$2@320@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01)))
    (or (Set_in n$2@320@01 g1@305@01) (not (Set_in n$2@320@01 g1@305@01)))
    (=>
      (and
        (Set_in n$2@320@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))
      (and
        (Set_in n$2@320@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01)))
    (or
      (not
        (and
          (Set_in n$2@320@01 g1@305@01)
          (not
            (=
              ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01)
              $Ref.null))))
      (and
        (Set_in n$2@320@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@411@27@411@36-aux|)))
(assert (forall ((n$2@320@01 $Ref)) (!
  (and
    (=>
      (Set_in n$2@320@01 g1@305@01)
      (and
        (Set_in n$2@320@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01)))
    (or (Set_in n$2@320@01 g1@305@01) (not (Set_in n$2@320@01 g1@305@01)))
    (=>
      (and
        (Set_in n$2@320@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))
      (and
        (Set_in n$2@320@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01)))
    (or
      (not
        (and
          (Set_in n$2@320@01 g1@305@01)
          (not
            (=
              ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01)
              $Ref.null))))
      (and
        (Set_in n$2@320@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))))
  :pattern ((Set_in n$2@320@01 g1@305@01) ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@411@27@411@36-aux|)))
(assert (forall ((n$2@320@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@320@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) g1@305@01))
  :pattern ((Set_in ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) g1@305@01))
  :pattern ((Set_in n$2@320@01 g1@305@01) ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n$2@320@01) n$2@320@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@411@27@411@36|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))
  $Snap.unit))
; [eval] (x0 in g0)
(assert (Set_in x0@306@01 g0@304@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))
  $Snap.unit))
; [eval] (x1 in g1)
(assert (Set_in x1@307@01 g1@305@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))
  $Snap.unit))
; [eval] (forall r: Ref :: { (r in g0), (r in g1) } (r in g0) ==> !((r in g1)))
(declare-const r@321@01 $Ref)
(push) ; 2
; [eval] (r in g0) ==> !((r in g1))
; [eval] (r in g0)
(push) ; 3
; [then-branch: 57 | r@321@01 in g0@304@01 | live]
; [else-branch: 57 | !(r@321@01 in g0@304@01) | live]
(push) ; 4
; [then-branch: 57 | r@321@01 in g0@304@01]
(assert (Set_in r@321@01 g0@304@01))
; [eval] !((r in g1))
; [eval] (r in g1)
(pop) ; 4
(push) ; 4
; [else-branch: 57 | !(r@321@01 in g0@304@01)]
(assert (not (Set_in r@321@01 g0@304@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r@321@01 g0@304@01)) (Set_in r@321@01 g0@304@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r@321@01 $Ref)) (!
  (or (not (Set_in r@321@01 g0@304@01)) (Set_in r@321@01 g0@304@01))
  :pattern ((Set_in r@321@01 g0@304@01) (Set_in r@321@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@414@14@414@34-aux|)))
(assert (forall ((r@321@01 $Ref)) (!
  (=> (Set_in r@321@01 g0@304@01) (not (Set_in r@321@01 g1@305@01)))
  :pattern ((Set_in r@321@01 g0@304@01) (Set_in r@321@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@414@14@414@34|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))
  $Snap.unit))
; [eval] (forall r$0: Ref :: { (r$0 in g0), (r$0 in g1) } (r$0 in g1) ==> !((r$0 in g0)))
(declare-const r$0@322@01 $Ref)
(push) ; 2
; [eval] (r$0 in g1) ==> !((r$0 in g0))
; [eval] (r$0 in g1)
(push) ; 3
; [then-branch: 58 | r$0@322@01 in g1@305@01 | live]
; [else-branch: 58 | !(r$0@322@01 in g1@305@01) | live]
(push) ; 4
; [then-branch: 58 | r$0@322@01 in g1@305@01]
(assert (Set_in r$0@322@01 g1@305@01))
; [eval] !((r$0 in g0))
; [eval] (r$0 in g0)
(pop) ; 4
(push) ; 4
; [else-branch: 58 | !(r$0@322@01 in g1@305@01)]
(assert (not (Set_in r$0@322@01 g1@305@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r$0@322@01 g1@305@01)) (Set_in r$0@322@01 g1@305@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r$0@322@01 $Ref)) (!
  (or (not (Set_in r$0@322@01 g1@305@01)) (Set_in r$0@322@01 g1@305@01))
  :pattern ((Set_in r$0@322@01 g0@304@01) (Set_in r$0@322@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@414@14@414@34-aux|)))
(assert (forall ((r$0@322@01 $Ref)) (!
  (=> (Set_in r$0@322@01 g1@305@01) (not (Set_in r$0@322@01 g0@304@01)))
  :pattern ((Set_in r$0@322@01 g0@304@01) (Set_in r$0@322@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@414@14@414@34|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))
  $Snap.unit))
; [eval] (forall n$3: Ref :: { (n$3 in g0) } { exists_path($$(g0), x0, n$3) } (n$3 in g0) ==> exists_path($$(g0), x0, n$3))
(declare-const n$3@323@01 $Ref)
(push) ; 2
; [eval] (n$3 in g0) ==> exists_path($$(g0), x0, n$3)
; [eval] (n$3 in g0)
(push) ; 3
; [then-branch: 59 | n$3@323@01 in g0@304@01 | live]
; [else-branch: 59 | !(n$3@323@01 in g0@304@01) | live]
(push) ; 4
; [then-branch: 59 | n$3@323@01 in g0@304@01]
(assert (Set_in n$3@323@01 g0@304@01))
; [eval] exists_path($$(g0), x0, n$3)
; [eval] $$(g0)
(push) ; 5
(declare-const n@324@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@324@01 g0@304@01))
(pop) ; 6
(declare-fun inv@325@01 ($Ref) $Ref)
(declare-fun img@326@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@324@01 $Ref) (n2@324@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@324@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n1@324@01) n1@324@01))
      (and
        (Set_in n2@324@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n2@324@01) n2@324@01))
      (= n1@324@01 n2@324@01))
    (= n1@324@01 n2@324@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@324@01 $Ref)) (!
  (=>
    (Set_in n@324@01 g0@304@01)
    (and (= (inv@325@01 n@324@01) n@324@01) (img@326@01 n@324@01)))
  :pattern ((Set_in n@324@01 g0@304@01))
  :pattern ((inv@325@01 n@324@01))
  :pattern ((img@326@01 n@324@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@326@01 r) (Set_in (inv@325@01 r) g0@304@01))
    (= (inv@325@01 r) r))
  :pattern ((inv@325@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@325@01 r) g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
  :pattern ((inv@325@01 r))
  :qid |quant-u-380|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@327@01 ((r $Ref) (n$3@323@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r) (= r (inv@325@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@328@01 ((r $Ref) (n$3@323@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r) (= r (inv@325@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@327@01 r n$3@323@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@327@01 r n$3@323@01))
    $Perm.No)
  
  :qid |quant-u-382|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@327@01 r n$3@323@01) $Perm.No)
  
  :qid |quant-u-383|))))
(check-sat)
; unknown
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r) (= r (inv@325@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@327@01 r n$3@323@01)) $Perm.No))
  
  :qid |quant-u-384|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@329@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r)))
    (=>
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@324@01 $Ref)) (!
  (=>
    (Set_in n@324@01 g0@304@01)
    (and (= (inv@325@01 n@324@01) n@324@01) (img@326@01 n@324@01)))
  :pattern ((Set_in n@324@01 g0@304@01))
  :pattern ((inv@325@01 n@324@01))
  :pattern ((img@326@01 n@324@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@326@01 r) (Set_in (inv@325@01 r) g0@304@01))
    (= (inv@325@01 r) r))
  :pattern ((inv@325@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r)))
    (=>
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@325@01 r) g0@304@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
    :pattern ((inv@325@01 r))
    :qid |quant-u-380|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 59 | !(n$3@323@01 in g0@304@01)]
(assert (not (Set_in n$3@323@01 g0@304@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@324@01 $Ref)) (!
  (=>
    (Set_in n@324@01 g0@304@01)
    (and (= (inv@325@01 n@324@01) n@324@01) (img@326@01 n@324@01)))
  :pattern ((Set_in n@324@01 g0@304@01))
  :pattern ((inv@325@01 n@324@01))
  :pattern ((img@326@01 n@324@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@326@01 r) (Set_in (inv@325@01 r) g0@304@01))
    (= (inv@325@01 r) r))
  :pattern ((inv@325@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r)))
    (=>
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
(assert (=>
  (Set_in n$3@323@01 g0@304@01)
  (and
    (Set_in n$3@323@01 g0@304@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@325@01 r) g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
      :pattern ((inv@325@01 r))
      :qid |quant-u-380|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01))))
; Joined path conditions
(assert (or (not (Set_in n$3@323@01 g0@304@01)) (Set_in n$3@323@01 g0@304@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@324@01 $Ref)) (!
  (=>
    (Set_in n@324@01 g0@304@01)
    (and (= (inv@325@01 n@324@01) n@324@01) (img@326@01 n@324@01)))
  :pattern ((Set_in n@324@01 g0@304@01))
  :pattern ((inv@325@01 n@324@01))
  :pattern ((img@326@01 n@324@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@326@01 r) (Set_in (inv@325@01 r) g0@304@01))
    (= (inv@325@01 r) r))
  :pattern ((inv@325@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r)))
    (=>
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@329@01  $FVF<next>))))
  :qid |qp.fvfDomDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@325@01 r) g0@304@01) (img@326@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@329@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@329@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef195|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$3@323@01 $Ref)) (!
  (and
    (=>
      (Set_in n$3@323@01 g0@304@01)
      (and
        (Set_in n$3@323@01 g0@304@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@325@01 r) g0@304@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
          :pattern ((inv@325@01 r))
          :qid |quant-u-380|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01)))
    (or (not (Set_in n$3@323@01 g0@304@01)) (Set_in n$3@323@01 g0@304@01)))
  :pattern ((Set_in n$3@323@01 g0@304@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@415@14@415@35-aux|)))
(assert (forall ((n$3@323@01 $Ref)) (!
  (and
    (=>
      (Set_in n$3@323@01 g0@304@01)
      (and
        (Set_in n$3@323@01 g0@304@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@325@01 r) g0@304@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
          :pattern ((inv@325@01 r))
          :qid |quant-u-380|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01)))
    (or (not (Set_in n$3@323@01 g0@304@01)) (Set_in n$3@323@01 g0@304@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01) x0@306@01 n$3@323@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@415@14@415@35-aux|)))
(assert (forall ((n$3@323@01 $Ref)) (!
  (=>
    (Set_in n$3@323@01 g0@304@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01) x0@306@01 n$3@323@01))
  :pattern ((Set_in n$3@323@01 g0@304@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@329@01  $FVF<next>)) g0@304@01) x0@306@01 n$3@323@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@415@14@415@35|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))))
  $Snap.unit))
; [eval] (forall n$4: Ref :: { (n$4 in g1) } { exists_path($$(g1), x1, n$4) } (n$4 in g1) ==> exists_path($$(g1), x1, n$4))
(declare-const n$4@330@01 $Ref)
(push) ; 2
; [eval] (n$4 in g1) ==> exists_path($$(g1), x1, n$4)
; [eval] (n$4 in g1)
(push) ; 3
; [then-branch: 60 | n$4@330@01 in g1@305@01 | live]
; [else-branch: 60 | !(n$4@330@01 in g1@305@01) | live]
(push) ; 4
; [then-branch: 60 | n$4@330@01 in g1@305@01]
(assert (Set_in n$4@330@01 g1@305@01))
; [eval] exists_path($$(g1), x1, n$4)
; [eval] $$(g1)
(push) ; 5
(declare-const n@331@01 $Ref)
(push) ; 6
; [eval] (n in refs)
(assert (Set_in n@331@01 g1@305@01))
(pop) ; 6
(declare-fun inv@332@01 ($Ref) $Ref)
(declare-fun img@333@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((n1@331@01 $Ref) (n2@331@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@331@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n1@331@01) n1@331@01))
      (and
        (Set_in n2@331@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n2@331@01) n2@331@01))
      (= n1@331@01 n2@331@01))
    (= n1@331@01 n2@331@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@331@01 $Ref)) (!
  (=>
    (Set_in n@331@01 g1@305@01)
    (and (= (inv@332@01 n@331@01) n@331@01) (img@333@01 n@331@01)))
  :pattern ((Set_in n@331@01 g1@305@01))
  :pattern ((inv@332@01 n@331@01))
  :pattern ((img@333@01 n@331@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@333@01 r) (Set_in (inv@332@01 r) g1@305@01))
    (= (inv@332@01 r) r))
  :pattern ((inv@332@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@332@01 r) g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
  :pattern ((inv@332@01 r))
  :qid |quant-u-386|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@334@01 ((r $Ref) (n$4@330@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r) (= r (inv@332@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@335@01 ((r $Ref) (n$4@330@01 $Ref)) $Perm
  (ite
    (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r) (= r (inv@332@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@334@01 r n$4@330@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@334@01 r n$4@330@01))
    $Perm.No)
  
  :qid |quant-u-388|))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@334@01 r n$4@330@01) $Perm.No)
  
  :qid |quant-u-389|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r) (= r (inv@332@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@334@01 r n$4@330@01)) $Perm.No))
  
  :qid |quant-u-390|))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@335@01 r n$4@330@01))
    $Perm.No)
  
  :qid |quant-u-391|))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@335@01 r n$4@330@01) $Perm.No)
  
  :qid |quant-u-392|))))
(check-sat)
; unknown
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r) (= r (inv@332@01 r)))
    (=
      (-
        (- (/ (to_real 1) (to_real 2)) (pTaken@334@01 r n$4@330@01))
        (pTaken@335@01 r n$4@330@01))
      $Perm.No))
  
  :qid |quant-u-393|))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@336@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r)))
    (=>
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>))))
  :qid |qp.fvfDomDef200|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef199|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01))
(pop) ; 5
; Joined path conditions
(assert (forall ((n@331@01 $Ref)) (!
  (=>
    (Set_in n@331@01 g1@305@01)
    (and (= (inv@332@01 n@331@01) n@331@01) (img@333@01 n@331@01)))
  :pattern ((Set_in n@331@01 g1@305@01))
  :pattern ((inv@332@01 n@331@01))
  :pattern ((img@333@01 n@331@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@333@01 r) (Set_in (inv@332@01 r) g1@305@01))
    (= (inv@332@01 r) r))
  :pattern ((inv@332@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r)))
    (=>
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>))))
  :qid |qp.fvfDomDef200|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef199|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@332@01 r) g1@305@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
    :pattern ((inv@332@01 r))
    :qid |quant-u-386|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01)))
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 60 | !(n$4@330@01 in g1@305@01)]
(assert (not (Set_in n$4@330@01 g1@305@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (forall ((n@331@01 $Ref)) (!
  (=>
    (Set_in n@331@01 g1@305@01)
    (and (= (inv@332@01 n@331@01) n@331@01) (img@333@01 n@331@01)))
  :pattern ((Set_in n@331@01 g1@305@01))
  :pattern ((inv@332@01 n@331@01))
  :pattern ((img@333@01 n@331@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@333@01 r) (Set_in (inv@332@01 r) g1@305@01))
    (= (inv@332@01 r) r))
  :pattern ((inv@332@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r)))
    (=>
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>))))
  :qid |qp.fvfDomDef200|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef199|)))
(assert (=>
  (Set_in n$4@330@01 g1@305@01)
  (and
    (Set_in n$4@330@01 g1@305@01)
    (forall ((r $Ref)) (!
      (=>
        (Set_in (inv@332@01 r) g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
      :pattern ((inv@332@01 r))
      :qid |quant-u-386|))
    ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01))))
; Joined path conditions
(assert (or (not (Set_in n$4@330@01 g1@305@01)) (Set_in n$4@330@01 g1@305@01)))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
(assert (forall ((n@331@01 $Ref)) (!
  (=>
    (Set_in n@331@01 g1@305@01)
    (and (= (inv@332@01 n@331@01) n@331@01) (img@333@01 n@331@01)))
  :pattern ((Set_in n@331@01 g1@305@01))
  :pattern ((inv@332@01 n@331@01))
  :pattern ((img@333@01 n@331@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@333@01 r) (Set_in (inv@332@01 r) g1@305@01))
    (= (inv@332@01 r) r))
  :pattern ((inv@332@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r)))
    (=>
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@336@01  $FVF<next>))))
  :qid |qp.fvfDomDef200|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@332@01 r) g1@305@01) (img@333@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@336@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@336@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef199|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$4@330@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@330@01 g1@305@01)
      (and
        (Set_in n$4@330@01 g1@305@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@332@01 r) g1@305@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
          :pattern ((inv@332@01 r))
          :qid |quant-u-386|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01)))
    (or (not (Set_in n$4@330@01 g1@305@01)) (Set_in n$4@330@01 g1@305@01)))
  :pattern ((Set_in n$4@330@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@416@14@416@35-aux|)))
(assert (forall ((n$4@330@01 $Ref)) (!
  (and
    (=>
      (Set_in n$4@330@01 g1@305@01)
      (and
        (Set_in n$4@330@01 g1@305@01)
        (forall ((r $Ref)) (!
          (=>
            (Set_in (inv@332@01 r) g1@305@01)
            ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
          :pattern ((inv@332@01 r))
          :qid |quant-u-386|))
        ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01)))
    (or (not (Set_in n$4@330@01 g1@305@01)) (Set_in n$4@330@01 g1@305@01)))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01) x1@307@01 n$4@330@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@416@14@416@35-aux|)))
(assert (forall ((n$4@330@01 $Ref)) (!
  (=>
    (Set_in n$4@330@01 g1@305@01)
    (exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01) x1@307@01 n$4@330@01))
  :pattern ((Set_in n$4@330@01 g1@305@01))
  :pattern ((exists_path<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@336@01  $FVF<next>)) g1@305@01) x1@307@01 n$4@330@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@416@14@416@35|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))))
  $Snap.unit))
; [eval] acyclic_list_segment(g0)
(push) ; 2
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n@337@01 $Ref)
(push) ; 3
; [eval] (n in g)
(assert (Set_in n@337@01 g0@304@01))
(pop) ; 3
(declare-fun inv@338@01 ($Ref) $Ref)
(declare-fun img@339@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@337@01 $Ref) (n2@337@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@337@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n1@337@01) n1@337@01))
      (and
        (Set_in n2@337@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) n2@337@01) n2@337@01))
      (= n1@337@01 n2@337@01))
    (= n1@337@01 n2@337@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@337@01 $Ref)) (!
  (=>
    (Set_in n@337@01 g0@304@01)
    (and (= (inv@338@01 n@337@01) n@337@01) (img@339@01 n@337@01)))
  :pattern ((Set_in n@337@01 g0@304@01))
  :pattern ((inv@338@01 n@337@01))
  :pattern ((img@339@01 n@337@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@339@01 r) (Set_in (inv@338@01 r) g0@304@01))
    (= (inv@338@01 r) r))
  :pattern ((inv@338@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@338@01 r) g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
  :pattern ((inv@338@01 r))
  :qid |quant-u-395|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@340@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r) (= r (inv@338@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@341@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r) (= r (inv@338@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@340@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@340@01 r))
    $Perm.No)
  
  :qid |quant-u-397|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r) (= r (inv@338@01 r)))
    (= (- $Perm.Write (pTaken@340@01 r)) $Perm.No))
  
  :qid |quant-u-398|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@342@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@342@01  $FVF<next>)))
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r)))
    (=>
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r))
      (Set_in r ($FVF.domain_next (as sm@342@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@342@01  $FVF<next>))))
  :qid |qp.fvfDomDef204|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@342@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@342@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@342@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@342@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@342@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef203|)))
; [eval] (forall n$0: Ref ::(n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@343@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 4
; [then-branch: 61 | !(n$0@343@01 in g0@304@01) | live]
; [else-branch: 61 | n$0@343@01 in g0@304@01 | live]
(push) ; 5
; [then-branch: 61 | !(n$0@343@01 in g0@304@01)]
(assert (not (Set_in n$0@343@01 g0@304@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 61 | n$0@343@01 in g0@304@01]
(assert (Set_in n$0@343@01 g0@304@01))
; [eval] n$0.next != null
(declare-const sm@344@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef207|)))
(declare-const pm@345@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@345@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resPrmSumDef208|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resTrgDef209|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) n$0@343@01))
(push) ; 6
(assert (not (< $Perm.No ($FVF.perm_next (as pm@345@01  $FPM) n$0@343@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef207|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@345@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resPrmSumDef208|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resTrgDef209|)))
(assert (=>
  (Set_in n$0@343@01 g0@304@01)
  (and
    (Set_in n$0@343@01 g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) n$0@343@01))))
(assert (or (Set_in n$0@343@01 g0@304@01) (not (Set_in n$0@343@01 g0@304@01))))
(push) ; 4
; [then-branch: 62 | n$0@343@01 in g0@304@01 && Lookup(next, sm@344@01, n$0@343@01) != Null | live]
; [else-branch: 62 | !(n$0@343@01 in g0@304@01 && Lookup(next, sm@344@01, n$0@343@01) != Null) | live]
(push) ; 5
; [then-branch: 62 | n$0@343@01 in g0@304@01 && Lookup(next, sm@344@01, n$0@343@01) != Null]
(assert (and
  (Set_in n$0@343@01 g0@304@01)
  (not (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef205|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef206|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef207|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) n$0@343@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$0@343@01) (Set_in (inv@312@01 n$0@343@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$0@343@01) (Set_in (inv@317@01 n$0@343@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 62 | !(n$0@343@01 in g0@304@01 && Lookup(next, sm@344@01, n$0@343@01) != Null)]
(assert (not
  (and
    (Set_in n$0@343@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef207|)))
(assert (=>
  (and
    (Set_in n$0@343@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null)))
  (and
    (Set_in n$0@343@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) n$0@343@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@343@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null))))
  (and
    (Set_in n$0@343@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef207|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@345@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resPrmSumDef208|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resTrgDef209|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 3
(assert (not (forall ((n$0@343@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@343@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) g0@304@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@343@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@343@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) g0@304@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|)))
(assert (acyclic_list_segment%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@342@01  $FVF<next>))
    $Snap.unit)) g0@304@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@337@01 $Ref)) (!
  (=>
    (Set_in n@337@01 g0@304@01)
    (and (= (inv@338@01 n@337@01) n@337@01) (img@339@01 n@337@01)))
  :pattern ((Set_in n@337@01 g0@304@01))
  :pattern ((inv@338@01 n@337@01))
  :pattern ((img@339@01 n@337@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@339@01 r) (Set_in (inv@338@01 r) g0@304@01))
    (= (inv@338@01 r) r))
  :pattern ((inv@338@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@342@01  $FVF<next>)))
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r)))
    (=>
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r))
      (Set_in r ($FVF.domain_next (as sm@342@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@342@01  $FVF<next>))))
  :qid |qp.fvfDomDef204|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@342@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@342@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@338@01 r) g0@304@01) (img@339@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@342@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@342@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef202|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@342@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef203|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef205|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@344@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef206|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@344@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef207|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@345@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resPrmSumDef208|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@345@01  $FPM) r))
  :qid |qp.resTrgDef209|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@338@01 r) g0@304@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@319@01  $FVF<next>) r) r))
    :pattern ((inv@338@01 r))
    :qid |quant-u-395|))
  (forall ((n$0@343@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@343@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@344@01  $FVF<next>) n$0@343@01) g0@304@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))
  (acyclic_list_segment%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@342@01  $FVF<next>))
      $Snap.unit)) g0@304@01)))
(assert (acyclic_list_segment ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@342@01  $FVF<next>))
    $Snap.unit)) g0@304@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))))))))))
  $Snap.unit))
; [eval] acyclic_list_segment(g1)
(push) ; 2
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n@346@01 $Ref)
(push) ; 3
; [eval] (n in g)
(assert (Set_in n@346@01 g1@305@01))
(pop) ; 3
(declare-fun inv@347@01 ($Ref) $Ref)
(declare-fun img@348@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n1@346@01 $Ref) (n2@346@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@346@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) n1@346@01) n1@346@01))
      (and
        (Set_in n2@346@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) n2@346@01) n2@346@01))
      (= n1@346@01 n2@346@01))
    (= n1@346@01 n2@346@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@346@01 $Ref)) (!
  (=>
    (Set_in n@346@01 g1@305@01)
    (and (= (inv@347@01 n@346@01) n@346@01) (img@348@01 n@346@01)))
  :pattern ((Set_in n@346@01 g1@305@01))
  :pattern ((inv@347@01 n@346@01))
  :pattern ((img@348@01 n@346@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@348@01 r) (Set_in (inv@347@01 r) g1@305@01))
    (= (inv@347@01 r) r))
  :pattern ((inv@347@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@347@01 r) g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) r) r))
  :pattern ((inv@347@01 r))
  :qid |quant-u-400|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@349@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r) (= r (inv@347@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@350@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r) (= r (inv@347@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@349@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@349@01 r))
    $Perm.No)
  
  :qid |quant-u-402|))))
(check-sat)
; unknown
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@349@01 r) $Perm.No)
  
  :qid |quant-u-403|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r) (= r (inv@347@01 r)))
    (= (- $Perm.Write (pTaken@349@01 r)) $Perm.No))
  
  :qid |quant-u-404|))))
(check-sat)
; unknown
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@350@01 r))
    $Perm.No)
  
  :qid |quant-u-405|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r) (= r (inv@347@01 r)))
    (= (- (- $Perm.Write (pTaken@349@01 r)) (pTaken@350@01 r)) $Perm.No))
  
  :qid |quant-u-406|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@351@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@351@01  $FVF<next>)))
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r)))
    (=>
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r))
      (Set_in r ($FVF.domain_next (as sm@351@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@351@01  $FVF<next>))))
  :qid |qp.fvfDomDef213|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@351@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@351@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@351@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@351@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef211|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@351@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef212|)))
; [eval] (forall n$0: Ref ::(n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@352@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 4
; [then-branch: 63 | !(n$0@352@01 in g1@305@01) | live]
; [else-branch: 63 | n$0@352@01 in g1@305@01 | live]
(push) ; 5
; [then-branch: 63 | !(n$0@352@01 in g1@305@01)]
(assert (not (Set_in n$0@352@01 g1@305@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 63 | n$0@352@01 in g1@305@01]
(assert (Set_in n$0@352@01 g1@305@01))
; [eval] n$0.next != null
(declare-const sm@353@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(declare-const pm@354@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@354@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resPrmSumDef217|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resTrgDef218|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) n$0@352@01))
(push) ; 6
(assert (not (< $Perm.No ($FVF.perm_next (as pm@354@01  $FPM) n$0@352@01))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@354@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resPrmSumDef217|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resTrgDef218|)))
(assert (=>
  (Set_in n$0@352@01 g1@305@01)
  (and
    (Set_in n$0@352@01 g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) n$0@352@01))))
(assert (or (Set_in n$0@352@01 g1@305@01) (not (Set_in n$0@352@01 g1@305@01))))
(push) ; 4
; [then-branch: 64 | n$0@352@01 in g1@305@01 && Lookup(next, sm@353@01, n$0@352@01) != Null | live]
; [else-branch: 64 | !(n$0@352@01 in g1@305@01 && Lookup(next, sm@353@01, n$0@352@01) != Null) | live]
(push) ; 5
; [then-branch: 64 | n$0@352@01 in g1@305@01 && Lookup(next, sm@353@01, n$0@352@01) != Null]
(assert (and
  (Set_in n$0@352@01 g1@305@01)
  (not (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef214|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef215|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef216|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) n$0@352@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$0@352@01) (Set_in (inv@312@01 n$0@352@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$0@352@01) (Set_in (inv@317@01 n$0@352@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(push) ; 5
; [else-branch: 64 | !(n$0@352@01 in g1@305@01 && Lookup(next, sm@353@01, n$0@352@01) != Null)]
(assert (not
  (and
    (Set_in n$0@352@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (=>
  (and
    (Set_in n$0@352@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null)))
  (and
    (Set_in n$0@352@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) n$0@352@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@352@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null))))
  (and
    (Set_in n$0@352@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@354@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resPrmSumDef217|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resTrgDef218|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 3
(assert (not (forall ((n$0@352@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@352@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) g1@305@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@352@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@352@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) g1@305@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|)))
(assert (acyclic_list_segment%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@351@01  $FVF<next>))
    $Snap.unit)) g1@305@01))
(pop) ; 2
; Joined path conditions
(assert (forall ((n@346@01 $Ref)) (!
  (=>
    (Set_in n@346@01 g1@305@01)
    (and (= (inv@347@01 n@346@01) n@346@01) (img@348@01 n@346@01)))
  :pattern ((Set_in n@346@01 g1@305@01))
  :pattern ((inv@347@01 n@346@01))
  :pattern ((img@348@01 n@346@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@348@01 r) (Set_in (inv@347@01 r) g1@305@01))
    (= (inv@347@01 r) r))
  :pattern ((inv@347@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@351@01  $FVF<next>)))
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r)))
    (=>
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r))
      (Set_in r ($FVF.domain_next (as sm@351@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@351@01  $FVF<next>))))
  :qid |qp.fvfDomDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@351@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@351@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef210|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@347@01 r) g1@305@01) (img@348@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@351@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@351@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef211|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@351@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef212|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@353@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef215|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@353@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef216|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@354@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resPrmSumDef217|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@354@01  $FPM) r))
  :qid |qp.resTrgDef218|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@347@01 r) g1@305@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@344@01  $FVF<next>) r) r))
    :pattern ((inv@347@01 r))
    :qid |quant-u-400|))
  (forall ((n$0@352@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@352@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@353@01  $FVF<next>) n$0@352@01) g1@305@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))
  (acyclic_list_segment%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@351@01  $FVF<next>))
      $Snap.unit)) g1@305@01)))
(assert (acyclic_list_segment ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@351@01  $FVF<next>))
    $Snap.unit)) g1@305@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@355@01 $Snap)
(assert (= $t@355@01 ($Snap.combine ($Snap.first $t@355@01) ($Snap.second $t@355@01))))
(assert (= ($Snap.first $t@355@01) $Snap.unit))
; [eval] !((null in (g0 union g1)))
; [eval] (null in (g0 union g1))
; [eval] (g0 union g1)
(assert (not (Set_in $Ref.null (Set_union g0@304@01 g1@305@01))))
(assert (=
  ($Snap.second $t@355@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@355@01))
    ($Snap.second ($Snap.second $t@355@01)))))
(declare-const n$5@356@01 $Ref)
(push) ; 3
; [eval] (n$5 in (g0 union g1))
; [eval] (g0 union g1)
(assert (Set_in n$5@356@01 (Set_union g0@304@01 g1@305@01)))
(declare-const sm@357@01 $FVF<next>)
; Definitional axioms for snapshot map values
(pop) ; 3
(declare-fun inv@358@01 ($Ref) $Ref)
(declare-fun img@359@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$51@356@01 $Ref) (n$52@356@01 $Ref)) (!
  (=>
    (and
      (Set_in n$51@356@01 (Set_union g0@304@01 g1@305@01))
      (Set_in n$52@356@01 (Set_union g0@304@01 g1@305@01))
      (= n$51@356@01 n$52@356@01))
    (= n$51@356@01 n$52@356@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$5@356@01 $Ref)) (!
  (=>
    (Set_in n$5@356@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@358@01 n$5@356@01) n$5@356@01) (img@359@01 n$5@356@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$5@356@01) n$5@356@01))
  :qid |quant-u-408|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@358@01 r) r))
  :pattern ((inv@358@01 r))
  :qid |next-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((n$5@356@01 $Ref)) (!
  (=>
    (Set_in n$5@356@01 (Set_union g0@304@01 g1@305@01))
    (not (= n$5@356@01 $Ref.null)))
  :pattern (($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$5@356@01) n$5@356@01))
  :qid |next-permImpliesNonNull|)))
(declare-const sm@360@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) r) r))
  :pattern ((inv@358@01 r))
  :qid |quant-u-409|)))
(assert (=
  ($Snap.second ($Snap.second $t@355@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@355@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@355@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@355@01))) $Snap.unit))
; [eval] (forall n$6: Ref :: { (n$6.next in (g0 union g1)) } { (n$6 in (g0 union g1)), n$6.next } (n$6 in (g0 union g1)) && n$6.next != null ==> (n$6.next in (g0 union g1)))
(declare-const n$6@361@01 $Ref)
(push) ; 3
; [eval] (n$6 in (g0 union g1)) && n$6.next != null ==> (n$6.next in (g0 union g1))
; [eval] (n$6 in (g0 union g1)) && n$6.next != null
; [eval] (n$6 in (g0 union g1))
; [eval] (g0 union g1)
(push) ; 4
; [then-branch: 65 | !(n$6@361@01 in g0@304@01 ∪ g1@305@01) | live]
; [else-branch: 65 | n$6@361@01 in g0@304@01 ∪ g1@305@01 | live]
(push) ; 5
; [then-branch: 65 | !(n$6@361@01 in g0@304@01 ∪ g1@305@01)]
(assert (not (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 65 | n$6@361@01 in g0@304@01 ∪ g1@305@01]
(assert (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01)))
; [eval] n$6.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@359@01 r)
        (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
      (=
        ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
    :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
    :qid |qp.fvfValDef220|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef221|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01))
(push) ; 6
(assert (not (and
  (img@359@01 n$6@361@01)
  (Set_in (inv@358@01 n$6@361@01) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (=>
  (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
  (and
    (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01))))
(assert (or
  (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
  (not (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01)))))
(push) ; 4
; [then-branch: 66 | n$6@361@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@360@01, n$6@361@01) != Null | live]
; [else-branch: 66 | !(n$6@361@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@360@01, n$6@361@01) != Null) | live]
(push) ; 5
; [then-branch: 66 | n$6@361@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@360@01, n$6@361@01) != Null]
(assert (and
  (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
  (not (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null))))
; [eval] (n$6.next in (g0 union g1))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and
        (img@359@01 r)
        (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
      (=
        ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
    :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
    :qid |qp.fvfValDef220|))
  (forall ((r $Ref)) (!
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
    :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef221|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01))
(push) ; 6
(assert (not (and
  (img@359@01 n$6@361@01)
  (Set_in (inv@358@01 n$6@361@01) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0,00s
; (get-info :all-statistics)
; [eval] (g0 union g1)
(pop) ; 5
(push) ; 5
; [else-branch: 66 | !(n$6@361@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@360@01, n$6@361@01) != Null)]
(assert (not
  (and
    (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
(assert (=>
  (and
    (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))
  (and
    (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null))))
  (and
    (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@360@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@360@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef221|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$6@361@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01)))
    (or
      (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
      (not (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))))
    (=>
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01)))
    (or
      (not
        (and
          (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
          (not
            (=
              ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01)
              $Ref.null))))
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) (Set_union g0@304@01 g1@305@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31-aux|)))
(assert (forall ((n$6@361@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01)))
    (or
      (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
      (not (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))))
    (=>
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01)))
    (or
      (not
        (and
          (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
          (not
            (=
              ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01)
              $Ref.null))))
      (and
        (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))))
  :pattern ((Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31-aux|)))
(assert (forall ((n$6@361@01 $Ref)) (!
  (=>
    (and
      (Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) (Set_union g0@304@01 g1@305@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) (Set_union g0@304@01 g1@305@01)))
  :pattern ((Set_in n$6@361@01 (Set_union g0@304@01 g1@305@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$6@361@01) n$6@361@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@355@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@355@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@355@01))))
  $Snap.unit))
; [eval] is_global_sroot((g0 union g1), Set(x0, x1))
; [eval] (g0 union g1)
; [eval] Set(x0, x1)
(push) ; 3
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$0@362@01 $Ref)
(push) ; 4
; [eval] (n$0 in g)
(assert (Set_in n$0@362@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@363@01 ($Ref) $Ref)
(declare-fun img@364@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n$01@362@01 $Ref) (n$02@362@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$01@362@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$01@362@01) n$01@362@01))
      (and
        (Set_in n$02@362@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) n$02@362@01) n$02@362@01))
      (= n$01@362@01 n$02@362@01))
    (= n$01@362@01 n$02@362@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$0@362@01 $Ref)) (!
  (=>
    (Set_in n$0@362@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@363@01 n$0@362@01) n$0@362@01) (img@364@01 n$0@362@01)))
  :pattern ((Set_in n$0@362@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@363@01 n$0@362@01))
  :pattern ((img@364@01 n$0@362@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@364@01 r) (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@363@01 r) r))
  :pattern ((inv@363@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) r) r))
  :pattern ((inv@363@01 r))
  :qid |quant-u-411|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@365@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
      (img@364@01 r)
      (= r (inv@363@01 r)))
    ($Perm.min
      (ite
        (and
          (img@359@01 r)
          (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@359@01 r)
          (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@365@01 r))
    $Perm.No)
  
  :qid |quant-u-413|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
      (img@364@01 r)
      (= r (inv@363@01 r)))
    (= (- $Perm.Write (pTaken@365@01 r)) $Perm.No))
  
  :qid |quant-u-414|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@366@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))
      (and
        (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
        (img@364@01 r)))
    (=>
      (and
        (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
        (img@364@01 r))
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
        (img@364@01 r))
      (and
        (img@359@01 r)
        (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01))))
    (=
      ($FVF.lookup_next (as sm@366@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
; [eval] (forall n$1: Ref ::(n$1 in g) && n$1.next != null ==> (n$1.next in g))
(declare-const n$1@367@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$1 in g) && n$1.next != null ==> (n$1.next in g)
; [eval] (n$1 in g) && n$1.next != null
; [eval] (n$1 in g)
(push) ; 5
; [then-branch: 67 | !(n$1@367@01 in g0@304@01 ∪ g1@305@01) | live]
; [else-branch: 67 | n$1@367@01 in g0@304@01 ∪ g1@305@01 | live]
(push) ; 6
; [then-branch: 67 | !(n$1@367@01 in g0@304@01 ∪ g1@305@01)]
(assert (not (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 67 | n$1@367@01 in g0@304@01 ∪ g1@305@01]
(assert (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01)))
; [eval] n$1.next != null
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) n$1@367@01))
(push) ; 7
(assert (not (and
  (img@359@01 n$1@367@01)
  (Set_in (inv@358@01 n$1@367@01) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
  (and
    (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) n$1@367@01))))
(assert (or
  (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
  (not (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01)))))
(push) ; 5
; [then-branch: 68 | n$1@367@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$1@367@01) != Null | live]
; [else-branch: 68 | !(n$1@367@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$1@367@01) != Null) | live]
(push) ; 6
; [then-branch: 68 | n$1@367@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$1@367@01) != Null]
(assert (and
  (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
      $Ref.null))))
; [eval] (n$1.next in g)
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) n$1@367@01))
(push) ; 7
(assert (not (and
  (img@359@01 n$1@367@01)
  (Set_in (inv@358@01 n$1@367@01) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 68 | !(n$1@367@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$1@367@01) != Null)]
(assert (not
  (and
    (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
        $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (and
    (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
        $Ref.null)))
  (and
    (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
        $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) n$1@367@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
      (not
        (=
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
          $Ref.null))))
  (and
    (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
        $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$1@367@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
      (not
        (=
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
          $Ref.null)))
    (Set_in ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@305@14@305@22|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$1@367@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
      (not
        (=
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
          $Ref.null)))
    (Set_in ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@305@14@305@22|)))
; [eval] (roots subset g)
(push) ; 4
(assert (not (Set_subset (Set_unionone (Set_singleton x0@306@01) x1@307@01) (Set_union g0@304@01 g1@305@01))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (Set_subset (Set_unionone (Set_singleton x0@306@01) x1@307@01) (Set_union g0@304@01 g1@305@01)))
(assert (is_global_sroot%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>))
    ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n$0@362@01 $Ref)) (!
  (=>
    (Set_in n$0@362@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@363@01 n$0@362@01) n$0@362@01) (img@364@01 n$0@362@01)))
  :pattern ((Set_in n$0@362@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@363@01 n$0@362@01))
  :pattern ((img@364@01 n$0@362@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@364@01 r) (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@363@01 r) r))
  :pattern ((inv@363@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))
      (and
        (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
        (img@364@01 r)))
    (=>
      (and
        (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
        (img@364@01 r))
      (Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@366@01  $FVF<next>))))
  :qid |qp.fvfDomDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
        (img@364@01 r))
      (and
        (img@359@01 r)
        (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01))))
    (=
      ($FVF.lookup_next (as sm@366@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef222|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@366@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef223|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@363@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@360@01  $FVF<next>) r) r))
    :pattern ((inv@363@01 r))
    :qid |quant-u-411|))
  (forall ((n$1@367@01 $Ref)) (!
    (=>
      (and
        (Set_in n$1@367@01 (Set_union g0@304@01 g1@305@01))
        (not
          (=
            ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01)
            $Ref.null)))
      (Set_in ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$1@367@01) (Set_union g0@304@01 g1@305@01)))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@305@14@305@22|))
  (Set_subset (Set_unionone (Set_singleton x0@306@01) x1@307@01) (Set_union g0@304@01 g1@305@01))
  (is_global_sroot%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>))
      ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01))))
(assert (is_global_sroot ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@366@01  $FVF<next>))
    ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01)))))
  $Snap.unit))
; [eval] acyclic_list_segment((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n@368@01 $Ref)
(push) ; 4
; [eval] (n in g)
(assert (Set_in n@368@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@369@01 ($Ref) $Ref)
(declare-fun img@370@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@371@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@371@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@371@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@371@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef226|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@368@01 $Ref) (n2@368@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@368@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@371@01  $FVF<next>) n1@368@01) n1@368@01))
      (and
        (Set_in n2@368@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@371@01  $FVF<next>) n2@368@01) n2@368@01))
      (= n1@368@01 n2@368@01))
    (= n1@368@01 n2@368@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@368@01 $Ref)) (!
  (=>
    (Set_in n@368@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@369@01 n@368@01) n@368@01) (img@370@01 n@368@01)))
  :pattern ((Set_in n@368@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@369@01 n@368@01))
  :pattern ((img@370@01 n@368@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@370@01 r) (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@369@01 r) r))
  :pattern ((inv@369@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@371@01  $FVF<next>) r) r))
  :pattern ((inv@369@01 r))
  :qid |quant-u-416|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@372@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
      (img@370@01 r)
      (= r (inv@369@01 r)))
    ($Perm.min
      (ite
        (and
          (img@359@01 r)
          (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@359@01 r)
          (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
        $Perm.Write
        $Perm.No)
      (pTaken@372@01 r))
    $Perm.No)
  
  :qid |quant-u-418|))))
(check-sat)
; unsat
(pop) ; 4
; 0,03s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
      (img@370@01 r)
      (= r (inv@369@01 r)))
    (= (- $Perm.Write (pTaken@372@01 r)) $Perm.No))
  
  :qid |quant-u-419|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@373@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@373@01  $FVF<next>)))
      (and
        (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
        (img@370@01 r)))
    (=>
      (and
        (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
        (img@370@01 r))
      (Set_in r ($FVF.domain_next (as sm@373@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@373@01  $FVF<next>))))
  :qid |qp.fvfDomDef229|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
        (img@370@01 r))
      (and
        (img@359@01 r)
        (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01))))
    (=
      ($FVF.lookup_next (as sm@373@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@373@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@373@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef228|)))
; [eval] (forall n$0: Ref ::(n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@374@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 5
; [then-branch: 69 | !(n$0@374@01 in g0@304@01 ∪ g1@305@01) | live]
; [else-branch: 69 | n$0@374@01 in g0@304@01 ∪ g1@305@01 | live]
(push) ; 6
; [then-branch: 69 | !(n$0@374@01 in g0@304@01 ∪ g1@305@01)]
(assert (not (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 69 | n$0@374@01 in g0@304@01 ∪ g1@305@01]
(assert (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01)))
; [eval] n$0.next != null
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) n$0@374@01))
(push) ; 7
(assert (not (and
  (img@359@01 n$0@374@01)
  (Set_in (inv@358@01 n$0@374@01) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
  (and
    (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) n$0@374@01))))
(assert (or
  (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
  (not (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01)))))
(push) ; 5
; [then-branch: 70 | n$0@374@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$0@374@01) != Null | live]
; [else-branch: 70 | !(n$0@374@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$0@374@01) != Null) | live]
(push) ; 6
; [then-branch: 70 | n$0@374@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$0@374@01) != Null]
(assert (and
  (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
  (not
    (=
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
      $Ref.null))))
; [eval] (n$0.next in g)
(assert ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) n$0@374@01))
(push) ; 7
(assert (not (and
  (img@359@01 n$0@374@01)
  (Set_in (inv@358@01 n$0@374@01) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 70 | !(n$0@374@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, First:(Second:($t@355@01)), n$0@374@01) != Null)]
(assert (not
  (and
    (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
        $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (and
    (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
        $Ref.null)))
  (and
    (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
        $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) n$0@374@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
      (not
        (=
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
          $Ref.null))))
  (and
    (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
    (not
      (=
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
        $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$0@374@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
      (not
        (=
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
          $Ref.null)))
    (Set_in ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@374@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
      (not
        (=
          ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
          $Ref.null)))
    (Set_in ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|)))
(assert (acyclic_list_segment%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@373@01  $FVF<next>))
    $Snap.unit)) (Set_union g0@304@01 g1@305@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@359@01 r) (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@371@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@371@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@371@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef226|)))
(assert (forall ((n@368@01 $Ref)) (!
  (=>
    (Set_in n@368@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@369@01 n@368@01) n@368@01) (img@370@01 n@368@01)))
  :pattern ((Set_in n@368@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@369@01 n@368@01))
  :pattern ((img@370@01 n@368@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@370@01 r) (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@369@01 r) r))
  :pattern ((inv@369@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@373@01  $FVF<next>)))
      (and
        (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
        (img@370@01 r)))
    (=>
      (and
        (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
        (img@370@01 r))
      (Set_in r ($FVF.domain_next (as sm@373@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@373@01  $FVF<next>))))
  :qid |qp.fvfDomDef229|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
        (img@370@01 r))
      (and
        (img@359@01 r)
        (Set_in (inv@358@01 r) (Set_union g0@304@01 g1@305@01))))
    (=
      ($FVF.lookup_next (as sm@373@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r)))
  :pattern (($FVF.lookup_next (as sm@373@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) r) r)
  :pattern (($FVF.lookup_next (as sm@373@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef228|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@369@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@371@01  $FVF<next>) r) r))
    :pattern ((inv@369@01 r))
    :qid |quant-u-416|))
  (forall ((n$0@374@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@374@01 (Set_union g0@304@01 g1@305@01))
        (not
          (=
            ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01)
            $Ref.null)))
      (Set_in ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@355@01))) n$0@374@01) (Set_union g0@304@01 g1@305@01)))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))
  (acyclic_list_segment%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@373@01  $FVF<next>))
      $Snap.unit)) (Set_union g0@304@01 g1@305@01))))
(assert (acyclic_list_segment ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@373@01  $FVF<next>))
    $Snap.unit)) (Set_union g0@304@01 g1@305@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01))))))
  $Snap.unit))
; [eval] (forall r$1: Ref :: { (r$1 in g0), (r$1 in g1) } (r$1 in g0) ==> !((r$1 in g1)))
(declare-const r$1@375@01 $Ref)
(push) ; 3
; [eval] (r$1 in g0) ==> !((r$1 in g1))
; [eval] (r$1 in g0)
(push) ; 4
; [then-branch: 71 | r$1@375@01 in g0@304@01 | live]
; [else-branch: 71 | !(r$1@375@01 in g0@304@01) | live]
(push) ; 5
; [then-branch: 71 | r$1@375@01 in g0@304@01]
(assert (Set_in r$1@375@01 g0@304@01))
; [eval] !((r$1 in g1))
; [eval] (r$1 in g1)
(pop) ; 5
(push) ; 5
; [else-branch: 71 | !(r$1@375@01 in g0@304@01)]
(assert (not (Set_in r$1@375@01 g0@304@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r$1@375@01 g0@304@01)) (Set_in r$1@375@01 g0@304@01)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r$1@375@01 $Ref)) (!
  (or (not (Set_in r$1@375@01 g0@304@01)) (Set_in r$1@375@01 g0@304@01))
  :pattern ((Set_in r$1@375@01 g0@304@01) (Set_in r$1@375@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@427@13@427@33-aux|)))
(assert (forall ((r$1@375@01 $Ref)) (!
  (=> (Set_in r$1@375@01 g0@304@01) (not (Set_in r$1@375@01 g1@305@01)))
  :pattern ((Set_in r$1@375@01 g0@304@01) (Set_in r$1@375@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@427@13@427@33|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@355@01))))))
  $Snap.unit))
; [eval] (forall r$2: Ref :: { (r$2 in g0), (r$2 in g1) } (r$2 in g1) ==> !((r$2 in g0)))
(declare-const r$2@376@01 $Ref)
(push) ; 3
; [eval] (r$2 in g1) ==> !((r$2 in g0))
; [eval] (r$2 in g1)
(push) ; 4
; [then-branch: 72 | r$2@376@01 in g1@305@01 | live]
; [else-branch: 72 | !(r$2@376@01 in g1@305@01) | live]
(push) ; 5
; [then-branch: 72 | r$2@376@01 in g1@305@01]
(assert (Set_in r$2@376@01 g1@305@01))
; [eval] !((r$2 in g0))
; [eval] (r$2 in g0)
(pop) ; 5
(push) ; 5
; [else-branch: 72 | !(r$2@376@01 in g1@305@01)]
(assert (not (Set_in r$2@376@01 g1@305@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (Set_in r$2@376@01 g1@305@01)) (Set_in r$2@376@01 g1@305@01)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((r$2@376@01 $Ref)) (!
  (or (not (Set_in r$2@376@01 g1@305@01)) (Set_in r$2@376@01 g1@305@01))
  :pattern ((Set_in r$2@376@01 g0@304@01) (Set_in r$2@376@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@427@13@427@33-aux|)))
(assert (forall ((r$2@376@01 $Ref)) (!
  (=> (Set_in r$2@376@01 g1@305@01) (not (Set_in r$2@376@01 g0@304@01)))
  :pattern ((Set_in r$2@376@01 g0@304@01) (Set_in r$2@376@01 g1@305@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@427@13@427@33|)))
(pop) ; 2
(push) ; 2
; [exec]
; inhale apply_TCFraming(g0, g1)
(declare-const $t@377@01 $Snap)
(assert (= $t@377@01 $Snap.unit))
; [eval] apply_TCFraming(g0, g1)
(push) ; 3
; [eval] !((null in g0))
; [eval] (null in g0)
(declare-const n@378@01 $Ref)
(push) ; 4
; [eval] (n in g0)
(assert (Set_in n@378@01 g0@304@01))
(pop) ; 4
(declare-fun inv@379@01 ($Ref) $Ref)
(declare-fun img@380@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@378@01 $Ref) (n2@378@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@378@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) n1@378@01) n1@378@01))
      (and
        (Set_in n2@378@01 g0@304@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) n2@378@01) n2@378@01))
      (= n1@378@01 n2@378@01))
    (= n1@378@01 n2@378@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@378@01 $Ref)) (!
  (=>
    (Set_in n@378@01 g0@304@01)
    (and (= (inv@379@01 n@378@01) n@378@01) (img@380@01 n@378@01)))
  :pattern ((Set_in n@378@01 g0@304@01))
  :pattern ((inv@379@01 n@378@01))
  :pattern ((img@380@01 n@378@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@380@01 r) (Set_in (inv@379@01 r) g0@304@01))
    (= (inv@379@01 r) r))
  :pattern ((inv@379@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@379@01 r) g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) r) r))
  :pattern ((inv@379@01 r))
  :qid |quant-u-421|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@381@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r) (= r (inv@379@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@382@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r) (= r (inv@379@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@381@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@381@01 r))
    $Perm.No)
  
  :qid |quant-u-423|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r) (= r (inv@379@01 r)))
    (= (- $Perm.Write (pTaken@381@01 r)) $Perm.No))
  
  :qid |quant-u-424|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@383@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@383@01  $FVF<next>)))
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r)))
    (=>
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r))
      (Set_in r ($FVF.domain_next (as sm@383@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@383@01  $FVF<next>))))
  :qid |qp.fvfDomDef233|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@383@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@383@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef230|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@383@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@383@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef231|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@383@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef232|)))
; [eval] (forall n$0: Ref ::(n$0 in g0) && n$0.next != null ==> (n$0.next in g0))
(declare-const n$0@384@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$0 in g0) && n$0.next != null ==> (n$0.next in g0)
; [eval] (n$0 in g0) && n$0.next != null
; [eval] (n$0 in g0)
(push) ; 5
; [then-branch: 73 | !(n$0@384@01 in g0@304@01) | live]
; [else-branch: 73 | n$0@384@01 in g0@304@01 | live]
(push) ; 6
; [then-branch: 73 | !(n$0@384@01 in g0@304@01)]
(assert (not (Set_in n$0@384@01 g0@304@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 73 | n$0@384@01 in g0@304@01]
(assert (Set_in n$0@384@01 g0@304@01))
; [eval] n$0.next != null
(declare-const sm@385@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(declare-const pm@386@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@386@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resPrmSumDef237|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resTrgDef238|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) n$0@384@01))
(push) ; 7
(assert (not (< $Perm.No ($FVF.perm_next (as pm@386@01  $FPM) n$0@384@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@386@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resPrmSumDef237|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resTrgDef238|)))
(assert (=>
  (Set_in n$0@384@01 g0@304@01)
  (and
    (Set_in n$0@384@01 g0@304@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) n$0@384@01))))
(assert (or (Set_in n$0@384@01 g0@304@01) (not (Set_in n$0@384@01 g0@304@01))))
(push) ; 5
; [then-branch: 74 | n$0@384@01 in g0@304@01 && Lookup(next, sm@385@01, n$0@384@01) != Null | live]
; [else-branch: 74 | !(n$0@384@01 in g0@304@01 && Lookup(next, sm@385@01, n$0@384@01) != Null) | live]
(push) ; 6
; [then-branch: 74 | n$0@384@01 in g0@304@01 && Lookup(next, sm@385@01, n$0@384@01) != Null]
(assert (and
  (Set_in n$0@384@01 g0@304@01)
  (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null))))
; [eval] (n$0.next in g0)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef234|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef235|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef236|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) n$0@384@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$0@384@01) (Set_in (inv@312@01 n$0@384@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$0@384@01) (Set_in (inv@317@01 n$0@384@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 74 | !(n$0@384@01 in g0@304@01 && Lookup(next, sm@385@01, n$0@384@01) != Null)]
(assert (not
  (and
    (Set_in n$0@384@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(assert (=>
  (and
    (Set_in n$0@384@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null)))
  (and
    (Set_in n$0@384@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) n$0@384@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@384@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null))))
  (and
    (Set_in n$0@384@01 g0@304@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@386@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resPrmSumDef237|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resTrgDef238|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$0@384@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@384@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) g0@304@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$0@384@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@384@01 g0@304@01)
      (not
        (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) g0@304@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|)))
; [eval] !((null in g1))
; [eval] (null in g1)
(declare-const n$1@387@01 $Ref)
(push) ; 4
; [eval] (n$1 in g1)
(assert (Set_in n$1@387@01 g1@305@01))
(pop) ; 4
(declare-fun inv@388@01 ($Ref) $Ref)
(declare-fun img@389@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@390@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef239|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef240|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n$11@387@01 $Ref) (n$12@387@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$11@387@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@390@01  $FVF<next>) n$11@387@01) n$11@387@01))
      (and
        (Set_in n$12@387@01 g1@305@01)
        ($FVF.loc_next ($FVF.lookup_next (as sm@390@01  $FVF<next>) n$12@387@01) n$12@387@01))
      (= n$11@387@01 n$12@387@01))
    (= n$11@387@01 n$12@387@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$1@387@01 $Ref)) (!
  (=>
    (Set_in n$1@387@01 g1@305@01)
    (and (= (inv@388@01 n$1@387@01) n$1@387@01) (img@389@01 n$1@387@01)))
  :pattern ((Set_in n$1@387@01 g1@305@01))
  :pattern ((inv@388@01 n$1@387@01))
  :pattern ((img@389@01 n$1@387@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@389@01 r) (Set_in (inv@388@01 r) g1@305@01))
    (= (inv@388@01 r) r))
  :pattern ((inv@388@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@388@01 r) g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@390@01  $FVF<next>) r) r))
  :pattern ((inv@388@01 r))
  :qid |quant-u-426|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@391@01 ((r $Ref)) $Perm
  (ite
    (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r) (= r (inv@388@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@391@01 r))
    $Perm.No)
  
  :qid |quant-u-428|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r) (= r (inv@388@01 r)))
    (= (- $Perm.Write (pTaken@391@01 r)) $Perm.No))
  
  :qid |quant-u-429|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@392@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@392@01  $FVF<next>)))
      (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r)))
    (=>
      (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r))
      (Set_in r ($FVF.domain_next (as sm@392@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@392@01  $FVF<next>))))
  :qid |qp.fvfDomDef243|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@392@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef241|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef242|)))
; [eval] (forall n$2: Ref ::(n$2 in g1) && n$2.next != null ==> (n$2.next in g1))
(declare-const n$2@393@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$2 in g1) && n$2.next != null ==> (n$2.next in g1)
; [eval] (n$2 in g1) && n$2.next != null
; [eval] (n$2 in g1)
(push) ; 5
; [then-branch: 75 | !(n$2@393@01 in g1@305@01) | live]
; [else-branch: 75 | n$2@393@01 in g1@305@01 | live]
(push) ; 6
; [then-branch: 75 | !(n$2@393@01 in g1@305@01)]
(assert (not (Set_in n$2@393@01 g1@305@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 75 | n$2@393@01 in g1@305@01]
(assert (Set_in n$2@393@01 g1@305@01))
; [eval] n$2.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef234|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef235|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef236|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) n$2@393@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$2@393@01) (Set_in (inv@312@01 n$2@393@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$2@393@01) (Set_in (inv@317@01 n$2@393@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(assert (=>
  (Set_in n$2@393@01 g1@305@01)
  (and
    (Set_in n$2@393@01 g1@305@01)
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) n$2@393@01))))
(assert (or (Set_in n$2@393@01 g1@305@01) (not (Set_in n$2@393@01 g1@305@01))))
(push) ; 5
; [then-branch: 76 | n$2@393@01 in g1@305@01 && Lookup(next, sm@385@01, n$2@393@01) != Null | live]
; [else-branch: 76 | !(n$2@393@01 in g1@305@01 && Lookup(next, sm@385@01, n$2@393@01) != Null) | live]
(push) ; 6
; [then-branch: 76 | n$2@393@01 in g1@305@01 && Lookup(next, sm@385@01, n$2@393@01) != Null]
(assert (and
  (Set_in n$2@393@01 g1@305@01)
  (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null))))
; [eval] (n$2.next in g1)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef234|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef235|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef236|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) n$2@393@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$2@393@01) (Set_in (inv@312@01 n$2@393@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$2@393@01) (Set_in (inv@317@01 n$2@393@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,00s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 76 | !(n$2@393@01 in g1@305@01 && Lookup(next, sm@385@01, n$2@393@01) != Null)]
(assert (not
  (and
    (Set_in n$2@393@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(assert (=>
  (and
    (Set_in n$2@393@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null)))
  (and
    (Set_in n$2@393@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) n$2@393@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$2@393@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null))))
  (and
    (Set_in n$2@393@01 g1@305@01)
    (not (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$2@393@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@393@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) g1@305@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (forall ((n$2@393@01 $Ref)) (!
  (=>
    (and
      (Set_in n$2@393@01 g1@305@01)
      (not
        (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) g1@305@01))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|)))
; [eval] (g1 intersection g0) == Set[Ref]()
; [eval] (g1 intersection g0)
; [eval] Set[Ref]()
(push) ; 4
(assert (not (Set_equal (Set_intersection g1@305@01 g0@304@01) (as Set_empty  Set<$Ref>))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
(assert (Set_equal (Set_intersection g1@305@01 g0@304@01) (as Set_empty  Set<$Ref>)))
(assert (apply_TCFraming%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@383@01  $FVF<next>))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<next>To$Snap (as sm@392@01  $FVF<next>))
          ($Snap.combine $Snap.unit $Snap.unit)))))) g0@304@01 g1@305@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@378@01 $Ref)) (!
  (=>
    (Set_in n@378@01 g0@304@01)
    (and (= (inv@379@01 n@378@01) n@378@01) (img@380@01 n@378@01)))
  :pattern ((Set_in n@378@01 g0@304@01))
  :pattern ((inv@379@01 n@378@01))
  :pattern ((img@380@01 n@378@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@380@01 r) (Set_in (inv@379@01 r) g0@304@01))
    (= (inv@379@01 r) r))
  :pattern ((inv@379@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@383@01  $FVF<next>)))
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r)))
    (=>
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r))
      (Set_in r ($FVF.domain_next (as sm@383@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@383@01  $FVF<next>))))
  :qid |qp.fvfDomDef233|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@383@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@383@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef230|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@379@01 r) g0@304@01) (img@380@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@383@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@383@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef231|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@383@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef232|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@385@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef235|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@385@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef236|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@386@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resPrmSumDef237|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@386@01  $FPM) r))
  :qid |qp.resTrgDef238|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@390@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef239|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@390@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef240|)))
(assert (forall ((n$1@387@01 $Ref)) (!
  (=>
    (Set_in n$1@387@01 g1@305@01)
    (and (= (inv@388@01 n$1@387@01) n$1@387@01) (img@389@01 n$1@387@01)))
  :pattern ((Set_in n$1@387@01 g1@305@01))
  :pattern ((inv@388@01 n$1@387@01))
  :pattern ((img@389@01 n$1@387@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@389@01 r) (Set_in (inv@388@01 r) g1@305@01))
    (= (inv@388@01 r) r))
  :pattern ((inv@388@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@392@01  $FVF<next>)))
      (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r)))
    (=>
      (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r))
      (Set_in r ($FVF.domain_next (as sm@392@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@392@01  $FVF<next>))))
  :qid |qp.fvfDomDef243|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and (Set_in (inv@388@01 r) g1@305@01) (img@389@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@392@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef241|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r)
  :pattern (($FVF.lookup_next (as sm@392@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef242|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@379@01 r) g0@304@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@353@01  $FVF<next>) r) r))
    :pattern ((inv@379@01 r))
    :qid |quant-u-421|))
  (forall ((n$0@384@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@384@01 g0@304@01)
        (not
          (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$0@384@01) g0@304@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@14@359@23|))
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@388@01 r) g1@305@01)
      ($FVF.loc_next ($FVF.lookup_next (as sm@390@01  $FVF<next>) r) r))
    :pattern ((inv@388@01 r))
    :qid |quant-u-426|))
  (forall ((n$2@393@01 $Ref)) (!
    (=>
      (and
        (Set_in n$2@393@01 g1@305@01)
        (not
          (= ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@385@01  $FVF<next>) n$2@393@01) g1@305@01))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@359@27@359@36|))
  (Set_equal (Set_intersection g1@305@01 g0@304@01) (as Set_empty  Set<$Ref>))
  (apply_TCFraming%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@383@01  $FVF<next>))
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($SortWrappers.$FVF<next>To$Snap (as sm@392@01  $FVF<next>))
            ($Snap.combine $Snap.unit $Snap.unit)))))) g0@304@01 g1@305@01)))
(assert (apply_TCFraming ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@383@01  $FVF<next>))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($SortWrappers.$FVF<next>To$Snap (as sm@392@01  $FVF<next>))
          ($Snap.combine $Snap.unit $Snap.unit)))))) g0@304@01 g1@305@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert acyclic_graph($$((g0 union g1)))
; [eval] acyclic_graph($$((g0 union g1)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(set-option :timeout 0)
(push) ; 3
(declare-const n@394@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@394@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@395@01 ($Ref) $Ref)
(declare-fun img@396@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@394@01 $Ref) (n2@394@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@394@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n1@394@01) n1@394@01))
      (and
        (Set_in n2@394@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) n2@394@01) n2@394@01))
      (= n1@394@01 n2@394@01))
    (= n1@394@01 n2@394@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@394@01 $Ref)) (!
  (=>
    (Set_in n@394@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@395@01 n@394@01) n@394@01) (img@396@01 n@394@01)))
  :pattern ((Set_in n@394@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@395@01 n@394@01))
  :pattern ((img@396@01 n@394@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@396@01 r) (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@395@01 r) r))
  :pattern ((inv@395@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) r) r))
  :pattern ((inv@395@01 r))
  :qid |quant-u-431|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@397@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
      (img@396@01 r)
      (= r (inv@395@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@398@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
      (img@396@01 r)
      (= r (inv@395@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@397@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@397@01 r))
    $Perm.No)
  
  :qid |quant-u-433|))))
(check-sat)
; unknown
(pop) ; 4
; 0,51s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@397@01 r) $Perm.No)
  
  :qid |quant-u-434|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
      (img@396@01 r)
      (= r (inv@395@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@397@01 r)) $Perm.No))
  
  :qid |quant-u-435|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@398@01 r))
    $Perm.No)
  
  :qid |quant-u-436|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@398@01 r) $Perm.No)
  
  :qid |quant-u-437|))))
(check-sat)
; unknown
(pop) ; 4
; 0,02s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
      (img@396@01 r)
      (= r (inv@395@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@397@01 r)) (pTaken@398@01 r))
      $Perm.No))
  
  :qid |quant-u-438|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@399@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@399@01  $FVF<next>)))
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r)))
    (=>
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r))
      (Set_in r ($FVF.domain_next (as sm@399@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@399@01  $FVF<next>))))
  :qid |qp.fvfDomDef247|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@399@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@399@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@399@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@399@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef245|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@399@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef246|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@399@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@394@01 $Ref)) (!
  (=>
    (Set_in n@394@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@395@01 n@394@01) n@394@01) (img@396@01 n@394@01)))
  :pattern ((Set_in n@394@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@395@01 n@394@01))
  :pattern ((img@396@01 n@394@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@396@01 r) (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@395@01 r) r))
  :pattern ((inv@395@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@399@01  $FVF<next>)))
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r)))
    (=>
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r))
      (Set_in r ($FVF.domain_next (as sm@399@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@399@01  $FVF<next>))))
  :qid |qp.fvfDomDef247|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@399@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@399@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
        (img@396@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@399@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@399@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef245|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@399@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef246|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@395@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@385@01  $FVF<next>) r) r))
    :pattern ((inv@395@01 r))
    :qid |quant-u-431|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@399@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01))))
(set-option :timeout 0)
(push) ; 3
(assert (not (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@399@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,36s
; (get-info :all-statistics)
(assert (acyclic_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@399@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01))))
; [exec]
; assert func_graph($$((g0 union g1)))
; [eval] func_graph($$((g0 union g1)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(declare-const n@400@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@400@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@401@01 ($Ref) $Ref)
(declare-fun img@402@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@403@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef248|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef249|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef250|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@400@01 $Ref) (n2@400@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@400@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@403@01  $FVF<next>) n1@400@01) n1@400@01))
      (and
        (Set_in n2@400@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@403@01  $FVF<next>) n2@400@01) n2@400@01))
      (= n1@400@01 n2@400@01))
    (= n1@400@01 n2@400@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@400@01 $Ref)) (!
  (=>
    (Set_in n@400@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@401@01 n@400@01) n@400@01) (img@402@01 n@400@01)))
  :pattern ((Set_in n@400@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@401@01 n@400@01))
  :pattern ((img@402@01 n@400@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@402@01 r) (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@401@01 r) r))
  :pattern ((inv@401@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@403@01  $FVF<next>) r) r))
  :pattern ((inv@401@01 r))
  :qid |quant-u-440|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@404@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
      (img@402@01 r)
      (= r (inv@401@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@405@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
      (img@402@01 r)
      (= r (inv@401@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@404@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@404@01 r))
    $Perm.No)
  
  :qid |quant-u-442|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@404@01 r) $Perm.No)
  
  :qid |quant-u-443|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
      (img@402@01 r)
      (= r (inv@401@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@404@01 r)) $Perm.No))
  
  :qid |quant-u-444|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@405@01 r))
    $Perm.No)
  
  :qid |quant-u-445|))))
(check-sat)
; unknown
(pop) ; 4
; 0,51s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@405@01 r) $Perm.No)
  
  :qid |quant-u-446|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
      (img@402@01 r)
      (= r (inv@401@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@404@01 r)) (pTaken@405@01 r))
      $Perm.No))
  
  :qid |quant-u-447|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@406@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@406@01  $FVF<next>)))
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r)))
    (=>
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r))
      (Set_in r ($FVF.domain_next (as sm@406@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@406@01  $FVF<next>))))
  :qid |qp.fvfDomDef254|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@406@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@406@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef251|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@406@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@406@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef252|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@406@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef253|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@406@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef248|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@403@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef249|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@403@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef250|)))
(assert (forall ((n@400@01 $Ref)) (!
  (=>
    (Set_in n@400@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@401@01 n@400@01) n@400@01) (img@402@01 n@400@01)))
  :pattern ((Set_in n@400@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@401@01 n@400@01))
  :pattern ((img@402@01 n@400@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@402@01 r) (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@401@01 r) r))
  :pattern ((inv@401@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@406@01  $FVF<next>)))
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r)))
    (=>
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r))
      (Set_in r ($FVF.domain_next (as sm@406@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@406@01  $FVF<next>))))
  :qid |qp.fvfDomDef254|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@406@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@406@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef251|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
        (img@402@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@406@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@406@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef252|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@406@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef253|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@401@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@403@01  $FVF<next>) r) r))
    :pattern ((inv@401@01 r))
    :qid |quant-u-440|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@406@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01))))
(set-option :timeout 0)
(push) ; 3
(assert (not (func_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@406@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
(assert (func_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@406@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01))))
; [exec]
; assert unshared_graph($$((g0 union g1)))
; [eval] unshared_graph($$((g0 union g1)))
; [eval] $$((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(declare-const n@407@01 $Ref)
(push) ; 4
; [eval] (n in refs)
(assert (Set_in n@407@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@408@01 ($Ref) $Ref)
(declare-fun img@409@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(declare-const sm@410@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@410@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@410@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@410@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@410@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef256|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@410@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef257|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@407@01 $Ref) (n2@407@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@407@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@410@01  $FVF<next>) n1@407@01) n1@407@01))
      (and
        (Set_in n2@407@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@410@01  $FVF<next>) n2@407@01) n2@407@01))
      (= n1@407@01 n2@407@01))
    (= n1@407@01 n2@407@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@407@01 $Ref)) (!
  (=>
    (Set_in n@407@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@408@01 n@407@01) n@407@01) (img@409@01 n@407@01)))
  :pattern ((Set_in n@407@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@408@01 n@407@01))
  :pattern ((img@409@01 n@407@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@409@01 r) (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@408@01 r) r))
  :pattern ((inv@408@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@410@01  $FVF<next>) r) r))
  :pattern ((inv@408@01 r))
  :qid |quant-u-449|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@411@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
      (img@409@01 r)
      (= r (inv@408@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (/ (to_real 1) (to_real 2)))
    $Perm.No))
(define-fun pTaken@412@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
      (img@409@01 r)
      (= r (inv@408@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- (/ (to_real 1) (to_real 2)) (pTaken@411@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@411@01 r))
    $Perm.No)
  
  :qid |quant-u-451|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@411@01 r) $Perm.No)
  
  :qid |quant-u-452|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
      (img@409@01 r)
      (= r (inv@408@01 r)))
    (= (- (/ (to_real 1) (to_real 2)) (pTaken@411@01 r)) $Perm.No))
  
  :qid |quant-u-453|))))
(check-sat)
; unknown
(pop) ; 4
; 0,52s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@412@01 r))
    $Perm.No)
  
  :qid |quant-u-454|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@412@01 r) $Perm.No)
  
  :qid |quant-u-455|))))
(check-sat)
; unknown
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
      (img@409@01 r)
      (= r (inv@408@01 r)))
    (=
      (- (- (/ (to_real 1) (to_real 2)) (pTaken@411@01 r)) (pTaken@412@01 r))
      $Perm.No))
  
  :qid |quant-u-456|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@413@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@413@01  $FVF<next>)))
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r)))
    (=>
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r))
      (Set_in r ($FVF.domain_next (as sm@413@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@413@01  $FVF<next>))))
  :qid |qp.fvfDomDef261|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@413@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@413@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef258|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@413@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@413@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef259|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@413@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef260|)))
(assert ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@413@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@410@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@410@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@410@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@410@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef256|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@410@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef257|)))
(assert (forall ((n@407@01 $Ref)) (!
  (=>
    (Set_in n@407@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@408@01 n@407@01) n@407@01) (img@409@01 n@407@01)))
  :pattern ((Set_in n@407@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@408@01 n@407@01))
  :pattern ((img@409@01 n@407@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@409@01 r) (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@408@01 r) r))
  :pattern ((inv@408@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@413@01  $FVF<next>)))
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r)))
    (=>
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r))
      (Set_in r ($FVF.domain_next (as sm@413@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@413@01  $FVF<next>))))
  :qid |qp.fvfDomDef261|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@413@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@413@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef258|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
        (img@409@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@413@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@413@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef259|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@413@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef260|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@408@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@410@01  $FVF<next>) r) r))
    :pattern ((inv@408@01 r))
    :qid |quant-u-449|))
  ($$%precondition ($SortWrappers.$FVF<next>To$Snap (as sm@413@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01))))
(set-option :timeout 0)
(push) ; 3
(assert (not (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@413@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,99s
; (get-info :all-statistics)
(assert (unshared_graph<Bool> ($$ ($SortWrappers.$FVF<next>To$Snap (as sm@413@01  $FVF<next>)) (Set_union g0@304@01 g1@305@01))))
; [eval] !((null in (g0 union g1)))
; [eval] (null in (g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
(assert (not (not (Set_in $Ref.null (Set_union g0@304@01 g1@305@01)))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(assert (not (Set_in $Ref.null (Set_union g0@304@01 g1@305@01))))
(declare-const n$5@414@01 $Ref)
(push) ; 3
; [eval] (n$5 in (g0 union g1))
; [eval] (g0 union g1)
(assert (Set_in n$5@414@01 (Set_union g0@304@01 g1@305@01)))
(declare-const sm@415@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef262|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef264|)))
(pop) ; 3
(declare-fun inv@416@01 ($Ref) $Ref)
(declare-fun img@417@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef262|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@415@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef263|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@415@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef264|)))
; Nested auxiliary terms: non-globals
(declare-const sm@418@01 $FVF<next>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef266|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef267|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((n$51@414@01 $Ref) (n$52@414@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$51@414@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$51@414@01) n$51@414@01))
      (and
        (Set_in n$52@414@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$52@414@01) n$52@414@01))
      (= n$51@414@01 n$52@414@01))
    (= n$51@414@01 n$52@414@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$5@414@01 $Ref)) (!
  (=>
    (Set_in n$5@414@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@416@01 n$5@414@01) n$5@414@01) (img@417@01 n$5@414@01)))
  :pattern (($FVF.loc_next ($FVF.lookup_next (as sm@415@01  $FVF<next>) n$5@414@01) n$5@414@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@417@01 r) (Set_in (inv@416@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@416@01 r) r))
  :pattern ((inv@416@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@416@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) r) r))
  :pattern ((inv@416@01 r))
  :qid |quant-u-458|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@419@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@416@01 r) (Set_union g0@304@01 g1@305@01))
      (img@417@01 r)
      (= r (inv@416@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@420@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@416@01 r) (Set_union g0@304@01 g1@305@01))
      (img@417@01 r)
      (= r (inv@416@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@419@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@419@01 r))
    $Perm.No)
  
  :qid |quant-u-460|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@416@01 r) (Set_union g0@304@01 g1@305@01))
      (img@417@01 r)
      (= r (inv@416@01 r)))
    (= (- $Perm.Write (pTaken@419@01 r)) $Perm.No))
  
  :qid |quant-u-461|))))
(check-sat)
; unknown
(pop) ; 3
; 0,51s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@420@01 r))
    $Perm.No)
  
  :qid |quant-u-462|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@416@01 r) (Set_union g0@304@01 g1@305@01))
      (img@417@01 r)
      (= r (inv@416@01 r)))
    (= (- (- $Perm.Write (pTaken@419@01 r)) (pTaken@420@01 r)) $Perm.No))
  
  :qid |quant-u-463|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall n$6: Ref :: { (n$6.next in (g0 union g1)) } { (n$6 in (g0 union g1)), n$6.next } (n$6 in (g0 union g1)) && n$6.next != null ==> (n$6.next in (g0 union g1)))
(declare-const n$6@421@01 $Ref)
(set-option :timeout 0)
(push) ; 3
; [eval] (n$6 in (g0 union g1)) && n$6.next != null ==> (n$6.next in (g0 union g1))
; [eval] (n$6 in (g0 union g1)) && n$6.next != null
; [eval] (n$6 in (g0 union g1))
; [eval] (g0 union g1)
(push) ; 4
; [then-branch: 77 | !(n$6@421@01 in g0@304@01 ∪ g1@305@01) | live]
; [else-branch: 77 | n$6@421@01 in g0@304@01 ∪ g1@305@01 | live]
(push) ; 5
; [then-branch: 77 | !(n$6@421@01 in g0@304@01 ∪ g1@305@01)]
(assert (not (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 77 | n$6@421@01 in g0@304@01 ∪ g1@305@01]
(assert (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01)))
; [eval] n$6.next != null
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef265|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef266|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef267|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$6@421@01) (Set_in (inv@312@01 n$6@421@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$6@421@01) (Set_in (inv@317@01 n$6@421@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef266|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef267|)))
(assert (=>
  (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
  (and
    (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))))
(assert (or
  (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
  (not (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01)))))
(push) ; 4
; [then-branch: 78 | n$6@421@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@418@01, n$6@421@01) != Null | live]
; [else-branch: 78 | !(n$6@421@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@418@01, n$6@421@01) != Null) | live]
(push) ; 5
; [then-branch: 78 | n$6@421@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@418@01, n$6@421@01) != Null]
(assert (and
  (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
  (not (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null))))
; [eval] (n$6.next in (g0 union g1))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef265|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef266|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef267|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$6@421@01) (Set_in (inv@312@01 n$6@421@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$6@421@01) (Set_in (inv@317@01 n$6@421@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0,01s
; (get-info :all-statistics)
; [eval] (g0 union g1)
(pop) ; 5
(push) ; 5
; [else-branch: 78 | !(n$6@421@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@418@01, n$6@421@01) != Null)]
(assert (not
  (and
    (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef266|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef267|)))
(assert (=>
  (and
    (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))
  (and
    (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null))))
  (and
    (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef265|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@418@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef266|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@418@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef267|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((n$6@421@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01)))
    (or
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (not (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))))
    (=>
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01)))
    (or
      (not
        (and
          (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
          (not
            (=
              ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01)
              $Ref.null))))
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))))
  :pattern ((Set_in ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) (Set_union g0@304@01 g1@305@01)))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31-aux|)))
(assert (forall ((n$6@421@01 $Ref)) (!
  (and
    (=>
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01)))
    (or
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (not (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))))
    (=>
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01)))
    (or
      (not
        (and
          (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
          (not
            (=
              ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01)
              $Ref.null))))
      (and
        (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))))
  :pattern ((Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31-aux|)))
(push) ; 3
(assert (not (forall ((n$6@421@01 $Ref)) (!
  (=>
    (and
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) (Set_union g0@304@01 g1@305@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) (Set_union g0@304@01 g1@305@01)))
  :pattern ((Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31|))))
(check-sat)
; unsat
(pop) ; 3
; 0,01s
; (get-info :all-statistics)
(assert (forall ((n$6@421@01 $Ref)) (!
  (=>
    (and
      (Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) (Set_union g0@304@01 g1@305@01)))
  :pattern ((Set_in ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) (Set_union g0@304@01 g1@305@01)))
  :pattern ((Set_in n$6@421@01 (Set_union g0@304@01 g1@305@01)) ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$6@421@01) n$6@421@01))
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@421@13@421@31|)))
; [eval] is_global_sroot((g0 union g1), Set(x0, x1))
; [eval] (g0 union g1)
; [eval] Set(x0, x1)
(push) ; 3
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n$0@422@01 $Ref)
(push) ; 4
; [eval] (n$0 in g)
(assert (Set_in n$0@422@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@423@01 ($Ref) $Ref)
(declare-fun img@424@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n$01@422@01 $Ref) (n$02@422@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n$01@422@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$01@422@01) n$01@422@01))
      (and
        (Set_in n$02@422@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) n$02@422@01) n$02@422@01))
      (= n$01@422@01 n$02@422@01))
    (= n$01@422@01 n$02@422@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n$0@422@01 $Ref)) (!
  (=>
    (Set_in n$0@422@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@423@01 n$0@422@01) n$0@422@01) (img@424@01 n$0@422@01)))
  :pattern ((Set_in n$0@422@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@423@01 n$0@422@01))
  :pattern ((img@424@01 n$0@422@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@424@01 r) (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@423@01 r) r))
  :pattern ((inv@423@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) r) r))
  :pattern ((inv@423@01 r))
  :qid |quant-u-465|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@425@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
      (img@424@01 r)
      (= r (inv@423@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@426@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
      (img@424@01 r)
      (= r (inv@423@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@425@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@425@01 r))
    $Perm.No)
  
  :qid |quant-u-467|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
      (img@424@01 r)
      (= r (inv@423@01 r)))
    (= (- $Perm.Write (pTaken@425@01 r)) $Perm.No))
  
  :qid |quant-u-468|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@426@01 r))
    $Perm.No)
  
  :qid |quant-u-469|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
      (img@424@01 r)
      (= r (inv@423@01 r)))
    (= (- (- $Perm.Write (pTaken@425@01 r)) (pTaken@426@01 r)) $Perm.No))
  
  :qid |quant-u-470|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@427@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@427@01  $FVF<next>)))
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r)))
    (=>
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r))
      (Set_in r ($FVF.domain_next (as sm@427@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@427@01  $FVF<next>))))
  :qid |qp.fvfDomDef271|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@427@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@427@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef268|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@427@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@427@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef269|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@427@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef270|)))
; [eval] (forall n$1: Ref ::(n$1 in g) && n$1.next != null ==> (n$1.next in g))
(declare-const n$1@428@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$1 in g) && n$1.next != null ==> (n$1.next in g)
; [eval] (n$1 in g) && n$1.next != null
; [eval] (n$1 in g)
(push) ; 5
; [then-branch: 79 | !(n$1@428@01 in g0@304@01 ∪ g1@305@01) | live]
; [else-branch: 79 | n$1@428@01 in g0@304@01 ∪ g1@305@01 | live]
(push) ; 6
; [then-branch: 79 | !(n$1@428@01 in g0@304@01 ∪ g1@305@01)]
(assert (not (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 79 | n$1@428@01 in g0@304@01 ∪ g1@305@01]
(assert (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01)))
; [eval] n$1.next != null
(declare-const sm@429@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(declare-const pm@430@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@430@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resPrmSumDef275|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resTrgDef276|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) n$1@428@01))
(push) ; 7
(assert (not (< $Perm.No ($FVF.perm_next (as pm@430@01  $FPM) n$1@428@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@430@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resPrmSumDef275|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resTrgDef276|)))
(assert (=>
  (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
  (and
    (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) n$1@428@01))))
(assert (or
  (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
  (not (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01)))))
(push) ; 5
; [then-branch: 80 | n$1@428@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@429@01, n$1@428@01) != Null | live]
; [else-branch: 80 | !(n$1@428@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@429@01, n$1@428@01) != Null) | live]
(push) ; 6
; [then-branch: 80 | n$1@428@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@429@01, n$1@428@01) != Null]
(assert (and
  (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
  (not (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null))))
; [eval] (n$1.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef272|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef273|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef274|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) n$1@428@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$1@428@01) (Set_in (inv@312@01 n$1@428@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$1@428@01) (Set_in (inv@317@01 n$1@428@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,01s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 80 | !(n$1@428@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@429@01, n$1@428@01) != Null)]
(assert (not
  (and
    (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (=>
  (and
    (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null)))
  (and
    (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) n$1@428@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null))))
  (and
    (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@430@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resPrmSumDef275|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resTrgDef276|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$1@428@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@305@14@305@22|))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
(assert (forall ((n$1@428@01 $Ref)) (!
  (=>
    (and
      (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@305@14@305@22|)))
; [eval] (roots subset g)
(push) ; 4
(assert (not (Set_subset (Set_unionone (Set_singleton x0@306@01) x1@307@01) (Set_union g0@304@01 g1@305@01))))
(check-sat)
; unsat
(pop) ; 4
; 0,01s
; (get-info :all-statistics)
(assert (Set_subset (Set_unionone (Set_singleton x0@306@01) x1@307@01) (Set_union g0@304@01 g1@305@01)))
(assert (is_global_sroot%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@427@01  $FVF<next>))
    ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n$0@422@01 $Ref)) (!
  (=>
    (Set_in n$0@422@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@423@01 n$0@422@01) n$0@422@01) (img@424@01 n$0@422@01)))
  :pattern ((Set_in n$0@422@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@423@01 n$0@422@01))
  :pattern ((img@424@01 n$0@422@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@424@01 r) (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@423@01 r) r))
  :pattern ((inv@423@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@427@01  $FVF<next>)))
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r)))
    (=>
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r))
      (Set_in r ($FVF.domain_next (as sm@427@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@427@01  $FVF<next>))))
  :qid |qp.fvfDomDef271|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@427@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@427@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef268|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
        (img@424@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@427@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@427@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef269|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@427@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef270|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef272|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@429@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef273|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@429@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef274|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@430@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resPrmSumDef275|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@430@01  $FPM) r))
  :qid |qp.resTrgDef276|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@423@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@418@01  $FVF<next>) r) r))
    :pattern ((inv@423@01 r))
    :qid |quant-u-465|))
  (forall ((n$1@428@01 $Ref)) (!
    (=>
      (and
        (Set_in n$1@428@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@429@01  $FVF<next>) n$1@428@01) (Set_union g0@304@01 g1@305@01)))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@305@14@305@22|))
  (Set_subset (Set_unionone (Set_singleton x0@306@01) x1@307@01) (Set_union g0@304@01 g1@305@01))
  (is_global_sroot%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@427@01  $FVF<next>))
      ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01))))
(push) ; 3
(assert (not (is_global_sroot ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@427@01  $FVF<next>))
    ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01))))
(check-sat)
; unsat
(pop) ; 3
; 0,97s
; (get-info :all-statistics)
(assert (is_global_sroot ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@427@01  $FVF<next>))
    ($Snap.combine $Snap.unit $Snap.unit))) (Set_union g0@304@01 g1@305@01) (Set_unionone (Set_singleton x0@306@01) x1@307@01)))
; [eval] acyclic_list_segment((g0 union g1))
; [eval] (g0 union g1)
(push) ; 3
; [eval] !((null in g))
; [eval] (null in g)
(declare-const n@431@01 $Ref)
(push) ; 4
; [eval] (n in g)
(assert (Set_in n@431@01 (Set_union g0@304@01 g1@305@01)))
(pop) ; 4
(declare-fun inv@432@01 ($Ref) $Ref)
(declare-fun img@433@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((n1@431@01 $Ref) (n2@431@01 $Ref)) (!
  (=>
    (and
      (and
        (Set_in n1@431@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) n1@431@01) n1@431@01))
      (and
        (Set_in n2@431@01 (Set_union g0@304@01 g1@305@01))
        ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) n2@431@01) n2@431@01))
      (= n1@431@01 n2@431@01))
    (= n1@431@01 n2@431@01))
  
  :qid |next-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0,00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((n@431@01 $Ref)) (!
  (=>
    (Set_in n@431@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@432@01 n@431@01) n@431@01) (img@433@01 n@431@01)))
  :pattern ((Set_in n@431@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@432@01 n@431@01))
  :pattern ((img@433@01 n@431@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@433@01 r) (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@432@01 r) r))
  :pattern ((inv@432@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (=>
    (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) r) r))
  :pattern ((inv@432@01 r))
  :qid |quant-u-472|)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@434@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
      (img@433@01 r)
      (= r (inv@432@01 r)))
    ($Perm.min
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@435@01 ((r $Ref)) $Perm
  (ite
    (and
      (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
      (img@433@01 r)
      (= r (inv@432@01 r)))
    ($Perm.min
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@434@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (pTaken@434@01 r))
    $Perm.No)
  
  :qid |quant-u-474|))))
(check-sat)
; unsat
(pop) ; 4
; 0,06s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
      (img@433@01 r)
      (= r (inv@432@01 r)))
    (= (- $Perm.Write (pTaken@434@01 r)) $Perm.No))
  
  :qid |quant-u-475|))))
(check-sat)
; unknown
(pop) ; 4
; 0,50s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)
      (pTaken@435@01 r))
    $Perm.No)
  
  :qid |quant-u-476|))))
(check-sat)
; unsat
(pop) ; 4
; 0,09s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
      (img@433@01 r)
      (= r (inv@432@01 r)))
    (= (- (- $Perm.Write (pTaken@434@01 r)) (pTaken@435@01 r)) $Perm.No))
  
  :qid |quant-u-477|))))
(check-sat)
; unsat
(pop) ; 4
; 0,08s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@436@01 $FVF<next>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@436@01  $FVF<next>)))
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r)))
    (=>
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r))
      (Set_in r ($FVF.domain_next (as sm@436@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@436@01  $FVF<next>))))
  :qid |qp.fvfDomDef280|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@436@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef277|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@436@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef278|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef279|)))
; [eval] (forall n$0: Ref ::(n$0 in g) && n$0.next != null ==> (n$0.next in g))
(declare-const n$0@437@01 $Ref)
(set-option :timeout 0)
(push) ; 4
; [eval] (n$0 in g) && n$0.next != null ==> (n$0.next in g)
; [eval] (n$0 in g) && n$0.next != null
; [eval] (n$0 in g)
(push) ; 5
; [then-branch: 81 | !(n$0@437@01 in g0@304@01 ∪ g1@305@01) | live]
; [else-branch: 81 | n$0@437@01 in g0@304@01 ∪ g1@305@01 | live]
(push) ; 6
; [then-branch: 81 | !(n$0@437@01 in g0@304@01 ∪ g1@305@01)]
(assert (not (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 81 | n$0@437@01 in g0@304@01 ∪ g1@305@01]
(assert (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01)))
; [eval] n$0.next != null
(declare-const sm@438@01 $FVF<next>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef281|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef282|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef283|)))
(declare-const pm@439@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@439@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resPrmSumDef284|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resTrgDef285|)))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) n$0@437@01))
(push) ; 7
(assert (not (< $Perm.No ($FVF.perm_next (as pm@439@01  $FPM) n$0@437@01))))
(check-sat)
; unsat
(pop) ; 7
; 0,06s
; (get-info :all-statistics)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef281|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef282|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef283|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@439@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resPrmSumDef284|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resTrgDef285|)))
(assert (=>
  (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
  (and
    (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
    ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) n$0@437@01))))
(assert (or
  (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
  (not (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01)))))
(push) ; 5
; [then-branch: 82 | n$0@437@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@438@01, n$0@437@01) != Null | live]
; [else-branch: 82 | !(n$0@437@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@438@01, n$0@437@01) != Null) | live]
(push) ; 6
; [then-branch: 82 | n$0@437@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@438@01, n$0@437@01) != Null]
(assert (and
  (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
  (not (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null))))
; [eval] (n$0.next in g)
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
      (=
        ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
    :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
    :qid |qp.fvfValDef281|))
  (forall ((r $Ref)) (!
    (=>
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
      (=
        ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
        ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
    :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
    :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
    :qid |qp.fvfValDef282|))
  (forall ((r $Ref)) (!
    (and
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
      ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
    :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
    :qid |qp.fvfResTrgDef283|))))
(assert ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) n$0@437@01))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and (img@313@01 n$0@437@01) (Set_in (inv@312@01 n$0@437@01) g0@304@01))
      $Perm.Write
      $Perm.No)
    (ite
      (and (img@318@01 n$0@437@01) (Set_in (inv@317@01 n$0@437@01) g1@305@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0,07s
; (get-info :all-statistics)
(pop) ; 6
(push) ; 6
; [else-branch: 82 | !(n$0@437@01 in g0@304@01 ∪ g1@305@01 && Lookup(next, sm@438@01, n$0@437@01) != Null)]
(assert (not
  (and
    (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef281|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef282|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef283|)))
(assert (=>
  (and
    (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null)))
  (and
    (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null))
    ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) n$0@437@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null))))
  (and
    (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
    (not (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef281|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef282|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef283|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@439@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resPrmSumDef284|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resTrgDef285|)))
; Nested auxiliary terms: non-globals (aux)
(push) ; 4
(assert (not (forall ((n$0@437@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))))
(check-sat)
; unsat
(pop) ; 4
; 0,07s
; (get-info :all-statistics)
(assert (forall ((n$0@437@01 $Ref)) (!
  (=>
    (and
      (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
      (not
        (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null)))
    (Set_in ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) (Set_union g0@304@01 g1@305@01)))
  
  :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|)))
(assert (acyclic_list_segment%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@436@01  $FVF<next>))
    $Snap.unit)) (Set_union g0@304@01 g1@305@01)))
(pop) ; 3
; Joined path conditions
(assert (forall ((n@431@01 $Ref)) (!
  (=>
    (Set_in n@431@01 (Set_union g0@304@01 g1@305@01))
    (and (= (inv@432@01 n@431@01) n@431@01) (img@433@01 n@431@01)))
  :pattern ((Set_in n@431@01 (Set_union g0@304@01 g1@305@01)))
  :pattern ((inv@432@01 n@431@01))
  :pattern ((img@433@01 n@431@01))
  :qid |next-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@433@01 r) (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01)))
    (= (inv@432@01 r) r))
  :pattern ((inv@432@01 r))
  :qid |next-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_next (as sm@436@01  $FVF<next>)))
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r)))
    (=>
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r))
      (Set_in r ($FVF.domain_next (as sm@436@01  $FVF<next>)))))
  :pattern ((Set_in r ($FVF.domain_next (as sm@436@01  $FVF<next>))))
  :qid |qp.fvfDomDef280|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r))
      (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01)))
    (=
      ($FVF.lookup_next (as sm@436@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef277|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
        (img@433@01 r))
      (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01)))
    (=
      ($FVF.lookup_next (as sm@436@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef278|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@436@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef279|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r))
  :qid |qp.fvfValDef281|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
    (=
      ($FVF.lookup_next (as sm@438@01  $FVF<next>) r)
      ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r)))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :pattern (($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r))
  :qid |qp.fvfValDef282|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.lookup_next (as sm@438@01  $FVF<next>) r))
  :qid |qp.fvfResTrgDef283|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_next (as pm@439@01  $FPM) r)
    (+
      (ite
        (and (img@313@01 r) (Set_in (inv@312@01 r) g0@304@01))
        $Perm.Write
        $Perm.No)
      (ite
        (and (img@318@01 r) (Set_in (inv@317@01 r) g1@305@01))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resPrmSumDef284|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_next ($FVF.lookup_next (as sm@438@01  $FVF<next>) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second $t@309@01))) r) r)
    ($FVF.loc_next ($FVF.lookup_next ($SortWrappers.$SnapTo$FVF<next> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@309@01)))))) r) r))
  :pattern (($FVF.perm_next (as pm@439@01  $FPM) r))
  :qid |qp.resTrgDef285|)))
(assert (and
  (forall ((r $Ref)) (!
    (=>
      (Set_in (inv@432@01 r) (Set_union g0@304@01 g1@305@01))
      ($FVF.loc_next ($FVF.lookup_next (as sm@429@01  $FVF<next>) r) r))
    :pattern ((inv@432@01 r))
    :qid |quant-u-472|))
  (forall ((n$0@437@01 $Ref)) (!
    (=>
      (and
        (Set_in n$0@437@01 (Set_union g0@304@01 g1@305@01))
        (not
          (= ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) $Ref.null)))
      (Set_in ($FVF.lookup_next (as sm@438@01  $FVF<next>) n$0@437@01) (Set_union g0@304@01 g1@305@01)))
    
    :qid |prog./silicon/silver/src/test/resources/graphs/static/tests/lists/framing2.vpr@312@14@312@22|))
  (acyclic_list_segment%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($SortWrappers.$FVF<next>To$Snap (as sm@436@01  $FVF<next>))
      $Snap.unit)) (Set_union g0@304@01 g1@305@01))))
(push) ; 3
(assert (not (acyclic_list_segment ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($SortWrappers.$FVF<next>To$Snap (as sm@436@01  $FVF<next>))
    $Snap.unit)) (Set_union g0@304@01 g1@305@01))))
(check-sat)
